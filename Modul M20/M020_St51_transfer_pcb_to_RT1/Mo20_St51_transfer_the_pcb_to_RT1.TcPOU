<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.16">
  <POU Name="Mo20_St51_transfer_the_pcb_to_RT1" Id="{0fb8d862-e7a0-4c40-9698-a56887cd0bf7}" SpecialFunc="None">
    <Declaration><![CDATA[
FUNCTION_BLOCK Mo20_St51_transfer_the_pcb_to_RT1
(*--------------------------------------------------------------------------------------
Preh IMA Automation Amberg GmbH

<DESC>
=INSERT DESCRIPTION FROM WORKFLOWPLAN=
</DESC>


<CHANGES>
At every change add date, version´s number, abbr. of name and describe change!

Date 		|	Version	|	Author	|	change description		
--------------------------------------------------------------------------------
2017-11-08	|	1.00	|	DWO		|	initial version

</CHANGES>
<VERSION>
1.00
</VERSION>

<DEPENDENCIES>
;
</DEPENDENCIES>



 -- overview of areas for steps --
Steps [000..099]: 	Whatever Block
Steps [100..199]:	Next Whatever Block

  
----------------------------------------------------------------------------------------*)



(* _____________________ *)
(* -- Standard-Inputs -- *)
VAR_INPUT
	OrderNr: 			INT :=1;		(* Nr. Actorder *)
	MoNr: 				INT:= 020;		(* Module-Number *)
	StNr: 				INT:= 51;		(* Stationsnumber *)
	BedienEinheit: 		ZENTR_DATA;		(* Central *)
	FaultID: 			BYTE := 0;		(* ID for Error Array *)
	DisplayNr: 			INT := 1;		(* Number of Textdisplay *)
	MPart: 				INT := 1;		(* Machinepart *)
	in_InitChainTxt:	STRING(39);		(* String for Step Chain Diagnosis *)
	in_sKebaKurz:		STRING(gcKebaStKurzLen) := '1234567890'; (* optional - can also be assigned in initialisation paragraph *)
	in_sKebaBez:		STRING(gcKebaStBezLen) 	:= '11111111112222222222333333333344444444445555555555'; (* optional - can also be assigned in initialisation paragraph *)
END_VAR


(* __________________ *)
(* -- RT-Interface -- *)
VAR_INPUT
	RtNr:				INT := 01;
	RtStNr:				SINT := 01;
	RtStartimpuls:		BOOL:=FALSE;	
END_VAR

VAR_IN_OUT
	//io_RtRegister:		ARRAY[1..6] OF ARRAY[1..4] OF DataTeil_pcb; // info for all parts within roundtable - the part for the station is accessed at [RtStNr]
	io_RtStarts:		DWORD; // bit array (dword) representing station is working on roundtable (flow based)
	io_RtFreigabe:		DWORD; // bit array (dword) representing station is giving permission for table to move (state based)
	io_RtFault:			DWORD; // bit array (dword) representing error at RtStNr of roundtable
	io_RtWaiting:		DWORD; // bit array (dword) representing waiting at RtStNr of roundtable
	io_RtWarning:		DWORD; // bit array (dword) representing warning at RtStNr of roundtable
END_VAR



(* ====== IF NO FEEDING STATION EXISTS PLEASE DELETE THIS PARAGRAPH AND ELEMINATE SUBSEQUENT ERRORS ====== *)
(* ____________________________ *)
(* -- Handshake with PCB Feeder -- *)
VAR_INPUT PERSISTENT
	in_bOffering			:ARRAY[1..3] OF BOOL;		//Silde
	in_bPartinHandlingST50	:BOOL:=FALSE;
END_VAR	

VAR_OUTPUT PERSISTENT
	out_bEnablePrework		:BOOL:=FALSE;
	out_bSlideReady			:ARRAY[1..3] OF BOOL;
END_VAR


VAR PERSISTENT
	SWI: 				BOOL := FALSE;	(* Impulse step is changing forward *)
	SWR:				BOOL := FALSE;	(* Impulse step is changing backwards *)
	Schritt: 			INT := 0;		(* Current step *)
	UZ: 				TON;			(* watchtime *)
	tonVertical:		TON;			(* watchtime before Gripper ON *)
	Fault: 				BOOL;			(* Stations Error *)
	Waiting:			BOOL;			(* Station Waiting *)
	Warning:			BOOL;			(* Station Warning *)
	Betrieb: 			BOOL;			(* Enable Steps *)
	StatEin: 			BOOL;			(* Station on *)
	AllInPos: 			BOOL;			(* all cylinders in position and not actuated manually *)
	Active:				BOOL;			(* stepchain is marked as active *)
	Transport:			BOOL;			(* manual transport is enabled *)
	InitRun:			BOOL;			(* goto homepos is enabled *)
	CycleRun:			BOOL;			(* mode for single cycle is enabled *)
	ManualRun:			BOOL;			(* move cylinders manually is enabled *)
	BackwardsRun:		BOOL;			(* backwards run is enabled *)
	tonSeitSwi:			TON;			(* time since last change of step *)
	tonSeitAllInPos:	TON;			(* time since AllInPos has become TRUE *)
	i:					INT;			(* index-runner for loops *)
	xx:					FB_StepTracker;	(* auto record steps *)
	StatString:			STRING(10);		(* '+MM=SS' *)
	StartCondition:		BOOL;			(* condition for starting station *)
	StartConditionEmptyRun: BOOL;
	bStart:				BOOL;			(* station's work on roundtable is running *)
	NestNr:				INT;			(* number of nest within fixation *)
	BDE_bCodeReaderOn:	BOOL;
	
	iPickPosition:		INT:=0;
	bPickProcess:		ARRAY[1..3] OF BOOL;
	bReadyToPick:		ARRAY[1..3] OF BOOL;
	bTakenover:			ARRAY[1..3] OF BOOL;
	rtREQSlide1:		r_trig;
	rtREQSlide2:		r_trig;
	rtREQSlide3:		r_trig;
	rtSlideBack:		r_trig;
	icounter:			INT:=1;
	bPartinSlide1:		BOOL;
	bPartinSlide2:		BOOL;
	bPartinSlide3:		BOOL;
	InPickProcess1:		rs;
	InPickProcess2:		rs;
	InPickProcess3:		rs;
	ReadyToPick1:		rs;
	ReadyToPick2:		rs;
	ReadyToPick3:		rs;
	SlideReady1:		rs;
	SlideReady2:		rs;
	SlideReady3:		rs;
	
	bPartNeeded					:BOOL:=FALSE;
	iPartsNeeded				:INT:=0;
	
	h:					INT;
	j:					INT;
END_VAR

VAR CONSTANT
	NEST1					:INT:=1;
	NEST2					:INT:=2;
	NEST3					:INT:=3;
	NEST4					:INT:=4;
END_VAR	

(* ___________________ *)
(* -- Error-Array 1 -- *)
VAR
	Errors1: ARRAY[1..ErrMaxBits] OF ERRDAT := [
	(* Error 01 *)		(Prio := ErrZyl, Nr:= 510, Txt:='Cavity 1       '),
	(* Error 02 *)		(Prio := ErrZyl, Nr:= 510, Txt:='Cavity 2       '),
	(* Error 03 *)		(Prio := ErrZyl, Nr:= 510, Txt:='Cavity 3       '),
	(* Error 04 *)		(Prio := ErrZyl, Nr:= 510, Txt:='Cavity 4       '),
	(* Error 05 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/05            '),
	(* Error 06 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/06            '),
	(* Error 07 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/07            '),
	(* Error 08 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/08            '),
	(* Error 09 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/09            '),
	(* Error 10 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/10            '),
	(* Error 11 *)		(Prio := ErrMeld, Nr:= 2710, Txt:='St51 Slide1'),//*************** waiting for feeding the PCBs
	(* Error 12 *)		(Prio := ErrMeld, Nr:= 2710, Txt:='St51 Slide2'),
	(* Error 13 *)		(Prio := ErrMeld, Nr:= 2710, Txt:='St51 Slide3'), 
	(* Error 14 *)		(Prio := ErrMeld, Nr:= 2711, Txt:='St51 Slide1'), //*************** waiting for feeding end
	(* Error 15 *)		(Prio := ErrMeld, Nr:= 2711, Txt:='St51 Slide2'), 
	(* Error 16 *)		(Prio := ErrMeld, Nr:= 2711, Txt:='St51 Slide3')];
	f1: ARRAY [1..ErrMaxBits] OF BOOL := [ErrMaxBits(FALSE)];
	Fehler1: ERRORANZ;
END_VAR

VAR CONSTANT
	feWaitReady				:ARRAY[1..3] OF INT:=[11,12,13];
	feWaitOfferEnd			:ARRAY[1..3] OF INT:=[14,15,16];
	feErrorDMCCodeReadXTimes1	:INT:=11;
	feErrorDMCCodeReadXTimes2	:INT:=12;
	
	feEmptyCheck1				:INT:=1;
	feEmptyCheck2				:INT:=2;
	feEmptyCheck3				:INT:=3;
	feEmptyCheck4				:INT:=4;
END_VAR



(* _____________________ *)
(* -- Local Variables -- *)
VAR PERSISTENT

	(* == Cylinders == *)
	zyl0_grip1						:ZYL0; (* MM1 *)
	
	zyl0_grip2						:ZYL0; (* MM2 *)
	
	zyl3_vertical_stroke			:ZYL3AC_B; (* MM3 *)
	ix_vertical_strokeA				:BOOL:=FALSE;
	ix_vertical_strokeC				:BOOL:=FALSE;
	ix_vertical_strokeB				:BOOL:=FALSE;		
	
	zyl2_interm_vertical_stroke		:zyl2; (* MM4 *)
	ix_interm_vertical_strokeA		:BOOL:=FALSE;
	ix_interm_vertical_strokeB		:BOOL:=FALSE;
	
	zyl2_hori_stroke				:zyl2; (* MM5 *)
	ix_hori_strokeA					:BOOL:=FALSE;
	ix_hori_strokeB					:BOOL:=FALSE;

	zyl2_silde_1					:zyl2; (* MM6 *)
	ix_silde_1A						:BOOL:=FALSE;
	ix_silde_1B						:BOOL:=FALSE;

	zyl2_silde_2					:zyl2; (* MM7 *)
	ix_silde_2A						:BOOL:=FALSE;
	ix_silde_2B						:BOOL:=FALSE;

	zyl2_silde_3					:zyl2; (* MM8 *)
	ix_silde_3A						:BOOL:=FALSE;
	ix_silde_3B						:BOOL:=FALSE;	

	(* == Sensors == *)
	ix_CavityCheck1				:BOOL:=FALSE;
	ix_CavityCheck2				:BOOL:=FALSE;
	ix_CavityCheck3				:BOOL:=FALSE;
	ix_CavityCheck4				:BOOL:=FALSE;
		
	(* ----- P1-ST51TA1 Horizontalhub ------ *)	
	ix_axX_P_Stop			:BOOL:=FALSE;
	ix_axX_N_Stop			:BOOL:=FALSE;
	ix_axX_Ready			:BOOL:=FALSE;
	ix_axX_STO_aktive		:BOOL:=FALSE;
	axXID					:USINT:=0;
	
	ix_axX_ServoBereit		:BOOL:=FALSE;
	ix_axX_MotionComplete	:BOOL:=FALSE;
	qx_axX_ReglerFreigabe	:BOOL:=FALSE;
	qx_axX_EndstufeFreigabe	:BOOL:=FALSE;
	
	(* position *)
	lraxXSpeedPositioning	:LREAL:=0.0;
	lraxXPickPosition1		:LREAL:=0.0;
	lraxXPickPosition2		:LREAL:=0.0;
	lraxXPickPosition3		:LREAL:=0.0;
	lraxXInsertPosition1	:LREAL:=0.0;
	lraxXInsertPosition2	:LREAL:=0.0;
	lraxXmittelPos			:LREAL:=0.0;		//reserve
	
	SchrittaxJumpBack		:INT:=0;
	_baxJumpBackDemanded	:BOOL:=FALSE;		//requirment for JumpBack
	_bStepBackAllowed		:BOOL:=FALSE;
	_bMoveAxisAllowed		:BOOL:=FALSE;
	_bArea1ToMoveAllowed	:BOOL:=FALSE;
	_bArea2ToMoveAllowed	:BOOL:=FALSE;
	_bArea3ToMoveAllowed	:BOOL:=FALSE;
	_bArea4ToMoveAllowed	:BOOL:=FALSE;
	_bArea5ToMoveAllowed	:BOOL:=FALSE;
	_bArea6ToMoveAllowed	:BOOL:=FALSE;
	
	strReadDMCCode1			:STRING(255);	(* the readed DMC code of UIFPCB *) 
	strReadDMCCode2			:STRING(255);	(* the readed DMC code of UIFPCB *) 
	dataHandlingPCB			: ARRAY[1..2] OF datateil_pcb;
	dataHandling			: ARRAY[1..2] OF datateil_pcb;
END_VAR

(* _____________________ *)
(* -- PCB router -- *)
VAR
	UZ1: 				TON;			(* watchtime *)
	UZ2: 				TON;			(* watchtime *)
	UZ3: 				TON;			(* watchtime *)
	UR:				R_TRIG;	
END_VAR
(* _____________________ *)
(* -- Function Blocks -- *)
VAR
	axX						:FB_Achse_mit_Keba;
END_VAR

(* _____________________ *)
(* -- Sesnsopart CR -- *)
VAR CONSTANT
	IP_CodeReader_BX1			:T_IPv4Addr	:= '192.168.20.251';	(* vision sensor Sensorpart *)
	IP_CodeReader_BX2			:T_IPv4Addr	:= '192.168.20.252';	(* vision sensor Sensorpart *)
END_VAR
 
VAR
	fb_CodeReaderBX1			:FB_CamSensopartV10;
	fb_CodeReaderBX2			:FB_CamSensopartV10;
	
	awErrorDMCCodeReadXtimes1	:AWFehler;
	awErrorDMCCodeReadXtimes2	:AWFehler;
END_VAR

(* ____________________ *)
(* -- LineController -- *)
VAR
	LC_Cavity1					:FB_LcStationCommandHandler;
	LC_Cavity2					:FB_LcStationCommandHandler;
	LC_Cavity3					:FB_LcStationCommandHandler;
	LC_Cavity4					:FB_LcStationCommandHandler;
	OutUserData					:ARRAY[1..100] OF BYTE;
	InUserData					:ARRAY[1..100] OF BYTE;		
	strTempTeileId				:STRING(40) := 'YYYYMMDDHHMMSS';
	TypeNo						:STRING(80);
	SerialNo					:STRING(80);
	udiIndex						:UDINT;

END_VAR

VAR
	OrderID						:DINT;
	OrderName					:STRING;
	OrderStatus					:WORD;
	TargetSize					:DINT;
	CurrentSize					:DINT;
	
	GmPartNumber				:STRING;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[(* ____________________ *)
(* -- Initialisation -- *)
IF neustart OR g_bOnlineChange THEN
	StatString 		:= RIGHT(CONCAT( '000',INT_TO_STRING(StNr) ),3); (* three digits station's prefix is being created automatically for station *)
	in_InitChainTxt := CONCAT( StatString, ' Transfer PCB to RT1' );
	in_sKebaKurz	:= CONCAT( StatString, ' PCB'); // 3+7 digits
	in_sKebaBez		:= in_InitChainTxt;
END_IF


KebaInitStation(
	Panelnummer		:= gKebaAktPanel,
	Aktiv			:= TRUE,
	Kurzbezeichnung	:= in_sKebaKurz,
	Bezeichnung		:= in_sKebaBez,
	ManuellAktiv	:= TRUE,
	RueckwaertsAktiv:= FALSE,
	GsAktiv			:= FALSE,
);


(* ________________________ *)
(* == Drive Dimensioning From FCT== *)

(* -- Data ML1-Axis ==53=020TA1 --
	Controller	CMMP-AS-C2-3A-M3
	Motor		EMMS-AS-70-M-LS-RM
	Axis		EGC-70-300-TB-KF-0H-GK
	Gear Ratio	1 : 1

	Application Environment
    Total LOAD M					= 4.6 KG
	
	Motor Basic
	Maximum Current	I_max			= 2.02 A
	Rated Current I_n				= 1.69 A
	
	Axis General Limitations
	max. Velocity v_max				= 4000.00 mm/s
	Shutdown Following Error 		= 20 mm
	Overspeed Protection I_prot		= 7000 mm/s
	
	Axis Stop Decelerations
	Deceleration a_max				= 20.121 m/s²
	
	Emergency-Stop-Ramp
    t_min = v_max / a_max      4000 mm/s / 20.121 m/s² =   198.8 ms
*)

(* _______________________________________ *)
(* -- Entry for Step Sequence Diagnosis -- *)
InitChain(
	Step 			:= Schritt,
	InitialState 	:= TRUE,
	Fault 			:= Fault,
	Waiting 		:= Waiting,
	Warning 		:= Warning,
	AllInPos 		:= AllInPos,
	RunOpenDoor 	:= TRUE,
	Txt 			:= in_InitChainTxt,
	BedienEinheit 	:= BedienEinheit,
	Active 			:= Active,
	Transport 		:= Transport,
	InitRun 		:= InitRun,
	CycleRun 		:= CycleRun,
	ManualRun 		:= ManualRun,
	BackwardsRun 	:= BackwardsRun);
InitRun := FALSE;


(* _______________ *)
(* -- Parameter -- *)
StatEin 	:= ActOrd[MPart].ord_stat[OrderNr].sd_ein;
BDE_bCodeReaderOn	:= ActOrd[MPart].ord_stat[OrderNr].sd_z1;

lraxXPickPosition1		:=85.51;				//85.14										
lraxXPickPosition2		:=-34.14;				//-34.44
lraxXPickPosition3		:=-154.62;				//-154.53
lraxXInsertPosition1	:=4.81;					//4.81
lraxXInsertPosition2	:=-35.02;				//-35.02
lraxXSpeedPositioning	:=100.0;

(* ____________ *)
(* -- Inputs -- *)
ix_CavityCheck1				:=_051_M20_MP1_BG1;
ix_CavityCheck2				:=_051_M20_MP1_BG2;
ix_CavityCheck3				:=_051_M20_MP1_BG3;
ix_CavityCheck4				:=_051_M20_MP1_BG4;

(*Axis Festo Input*)
ix_axX_P_Stop				:=_051_M20_MP1_BG1_P;
ix_axX_N_Stop				:=_051_M20_MP1_BG1_N;
ix_axX_Ready				:=_051_M20_P1_TA1_X1_24;
ix_axX_MotionComplete		:=_051_M20_P1_TA1_X1_12;
ix_axX_STO_aktive			:=_051_M20_P1_TA1_X40;

(*Cylinder Input*)
ix_vertical_strokeA			:=_051_M20_MP1_BG3_A;
ix_vertical_strokeB			:=_051_M20_MP1_BG3_B;
ix_vertical_strokeC			:=_051_M20_MP1_BG3_C;

ix_interm_vertical_strokeA	:=_051_M20_MP1_BG4_A;
ix_interm_vertical_strokeB	:=_051_M20_MP1_BG4_B;

ix_hori_strokeA				:=_051_M20_MP1_BG5_A;
ix_hori_strokeB				:=_051_M20_MP1_BG5_B;

ix_silde_1b					:=_051_M20_MP1_BG6_A;
ix_silde_1a					:=_051_M20_MP1_BG6_B;

ix_silde_2B					:=_051_M20_MP1_BG7_A;
ix_silde_2A					:=_051_M20_MP1_BG7_B;

ix_silde_3B				:=_051_M20_MP1_BG8_A;
ix_silde_3A				:=_051_M20_MP1_BG8_B;


(*DWOCOM Button Start*)
in_bOffering[1]:=FALSE;
in_bOffering[2]:=FALSE;
in_bOffering[3]:=FALSE;

(* _______________________ *)
(* -- Timer / Watchdogs -- *)
UZ( IN:= NOT SWI AND BedienEinheit.grundbed, PT:= T#5s );
tonSeitSwi( IN := NOT SWI AND Bedieneinheit.grundbed, PT := t#30d );
tonSeitAllInPos( IN := AllInPos AND Bedieneinheit.grundbed, PT := t#30d );
tonVertical( IN:= NOT SWI AND BedienEinheit.grundbed, PT:= T#1S );
UZ1( IN:= _IX_15_3 AND _IX_15_2 AND zyl2_silde_1.a , PT:= T#1S );
UZ2( IN:= _IX_15_5 AND _IX_15_4 AND zyl2_silde_2.a , PT:= T#1S );
UZ3( IN:= _IX_15_7 AND _IX_15_6 AND zyl2_silde_3.a , PT:= T#1S );
UR(clk:=(schritt = 70 OR schritt = 190));

(* DWOCOM Handshake with Button and schritt*)
//I15.3  Finish for part tray1 
//I15.5  Finish	for part tray2
//I15.7	 Finish for part tray3
//I15.2	 Ready for moving 
//I15.4	 Ready for moving
//I15.6	 Ready for moving
//I14.7  Auto mode
//I15.0	 Error 
//I15.1	 Ask for opening door
(*FZH
InPickProcess1(SET:= _IX_15_3 AND _IX_15_2 AND zyl2_silde_1.a AND UZ1.Q, RESET1:= bPickProcess[1] AND (schritt = 70 OR schritt = 190) AND iPickPosition = 1 , Q1=> bPickProcess[1]);
InPickProcess2(SET:= _IX_15_5 AND _IX_15_4 AND zyl2_silde_2.a AND UZ2.Q, RESET1:= bPickProcess[2] AND (schritt = 70 OR schritt = 190) AND iPickPosition = 2 , Q1=> bPickProcess[2]);
InPickProcess3(SET:= _IX_15_7 AND _IX_15_6 AND zyl2_silde_3.a AND UZ3.Q, RESET1:= bPickProcess[3] AND (schritt = 70 OR schritt = 190) AND iPickPosition = 3 , Q1=> bPickProcess[3]);
*)

(*
InPickProcess1(SET:= _IX_15_3 AND _IX_15_2 AND zyl2_silde_1.a AND UZ1.Q, RESET1:= bPickProcess[1] AND UR.Q AND iPickPosition = 1 AND zyl2_silde_1.b , Q1=> bPickProcess[1]);
InPickProcess2(SET:= _IX_15_5 AND _IX_15_4 AND zyl2_silde_2.a AND UZ2.Q, RESET1:= bPickProcess[2] AND UR.Q AND iPickPosition = 2 AND zyl2_silde_2.b , Q1=> bPickProcess[2]);
InPickProcess3(SET:= _IX_15_7 AND _IX_15_6 AND zyl2_silde_3.a AND UZ3.Q, RESET1:= bPickProcess[3] AND UR.Q AND iPickPosition = 3 AND zyl2_silde_3.b , Q1=> bPickProcess[3]);   

ReadyToPick1(SET:= bPickProcess[1] AND zyl2_silde_1.b, RESET1:= NOT bPickProcess[1] AND (schritt = 70 OR schritt = 190) AND iPickPosition = 1, Q1=> bReadyToPick[1]);
ReadyToPick2(SET:= bPickProcess[2] AND zyl2_silde_2.b, RESET1:= NOT bPickProcess[2] AND (schritt = 70 OR schritt = 190) AND iPickPosition = 2, Q1=> bReadyToPick[2]);
ReadyToPick3(SET:= bPickProcess[3] AND zyl2_silde_3.b, RESET1:= NOT bPickProcess[3] AND (schritt = 70 OR schritt = 190) AND iPickPosition = 3, Q1=> bReadyToPick[3]);

SlideReady1(SET:= NOT bPickProcess[1] AND zyl2_silde_1.a, RESET1:= bPickProcess[1], Q1=> out_bSlideReady[1]);
SlideReady2(SET:= NOT bPickProcess[2] AND zyl2_silde_2.a, RESET1:= bPickProcess[2], Q1=> out_bSlideReady[2]);
SlideReady3(SET:= NOT bPickProcess[3] AND zyl2_silde_3.a, RESET1:= bPickProcess[3], Q1=> out_bSlideReady[3]);

(*ZFH  Handshake with PCBcutter*)

_QX_15_1:=NOT ManualRun AND NOT  zyl2_silde_1.on AND zyl2_silde_1.A ;
_QX_15_2:=NOT ManualRun AND NOT  zyl2_silde_2.on AND zyl2_silde_2.A ;
_QX_15_3:=NOT ManualRun AND NOT  zyl2_silde_3.on AND zyl2_silde_3.A ;
*)
rtREQSlide1(CLK:=_IX_15_3);
rtREQSlide2(CLK:=_IX_15_5);
rtREQSlide3(CLK:=_IX_15_7);
IF rtREQSlide1.Q AND zyl2_silde_1.b THEN bPartinSlide1:=TRUE; END_IF
IF rtREQSlide2.Q AND zyl2_silde_2.b THEN bPartinSlide2:=TRUE; END_IF
IF rtREQSlide3.Q AND zyl2_silde_3.b THEN bPartinSlide3:=TRUE; END_IF
InPickProcess1(SET:= _IX_15_3 AND _IX_15_2 AND bPartinSlide1 AND UZ1.Q, RESET1:= (schritt = 70 OR schritt = 190)  AND iPickPosition = 1 AND zyl2_silde_1.A , Q1=> bPickProcess[1]);
InPickProcess2(SET:= _IX_15_5 AND _IX_15_4 AND bPartinSlide2 AND UZ2.Q, RESET1:= (schritt = 70 OR schritt = 190)  AND iPickPosition = 2 AND zyl2_silde_2.A , Q1=> bPickProcess[2]);
InPickProcess3(SET:= _IX_15_7 AND _IX_15_6 AND bPartinSlide3 AND UZ3.Q, RESET1:= (schritt = 70 OR schritt = 190)  AND iPickPosition = 3 AND zyl2_silde_3.A , Q1=> bPickProcess[3]);   
ReadyToPick1(SET:= bPickProcess[1] AND zyl2_silde_1.a, RESET1:= NOT bPickProcess[1] AND (schritt = 70 OR schritt = 190) AND iPickPosition = 1, Q1=> bReadyToPick[1]);
ReadyToPick2(SET:= bPickProcess[2] AND zyl2_silde_2.a, RESET1:= NOT bPickProcess[2] AND (schritt = 70 OR schritt = 190) AND iPickPosition = 2, Q1=> bReadyToPick[2]);
ReadyToPick3(SET:= bPickProcess[3] AND zyl2_silde_3.a, RESET1:= NOT bPickProcess[3] AND (schritt = 70 OR schritt = 190) AND iPickPosition = 3, Q1=> bReadyToPick[3]);
IF NOT bPickProcess[1] AND (schritt = 70 OR schritt = 190) AND iPickPosition = 1 AND bPartinSlide1 THEN bPartinSlide1:=FALSE; END_IF
IF NOT bPickProcess[2] AND (schritt = 70 OR schritt = 190) AND iPickPosition = 2 AND bPartinSlide2 THEN bPartinSlide2:=FALSE; END_IF
IF NOT bPickProcess[3] AND (schritt = 70 OR schritt = 190) AND iPickPosition = 3 AND bPartinSlide3 THEN bPartinSlide3:=FALSE; END_IF

rtSlideBack(CLK:=(NOT zyl2_silde_1.on and NOT zyl2_silde_2.on and NOT zyl2_silde_3.on));
IF rtSlideBack.Q THEN 
	icounter:=+1;
END_IF
IF 	icounter>3 THEN icounter:=1; END_IF

IF NOT (_IX_15_3 OR _IX_15_5 OR _IX_15_7) AND _IX_15_2 AND NOT bPartinSlide1 THEN
	zyl2_silde_1.on :=TRUE;
END_IF

//IF _IX_15_7 AND NOT zyl2_silde_3.on AND zyl2_silde_2.a AND _IX_15_2 AND _IX_14_7 THEN
IF (*_IX_15_7 AND*)  _IX_15_2 AND _IX_14_7 THEN
zyl2_silde_1.on:=NOT ManualRun AND NOT bPartinSlide1;
END_IF;
//IF _IX_15_3 AND NOT zyl2_silde_1.on AND zyl2_silde_3.a AND _IX_15_4 AND _IX_14_7 THEN
IF (*_IX_15_3 AND*) _IX_15_4 AND _IX_14_7 THEN
zyl2_silde_2.on:=NOT ManualRun AND NOT bPartinSlide2;
END_IF
//IF _IX_15_5 AND NOT zyl2_silde_2.on AND zyl2_silde_1.a AND _IX_15_6 AND _IX_14_7 THEN
IF (*_IX_15_5 AND*) _IX_15_6 AND _IX_14_7 THEN
zyl2_silde_3.on:=NOT ManualRun AND NOT bPartinSlide3;
END_IF

IF _IX_15_2 AND NOT _IX_14_7 THEN
	zyl2_silde_1.on:=FALSE;
END_IF

IF _IX_15_4 AND NOT _IX_14_7 THEN
	zyl2_silde_2.on:=FALSE;
END_IF

IF _IX_15_6 AND NOT _IX_14_7 THEN
	zyl2_silde_3.on:=FALSE;
END_IF

_QX_15_1:=NOT ManualRun AND zyl2_silde_1.on AND zyl2_silde_1.b ;
_QX_15_2:=NOT ManualRun AND zyl2_silde_2.on AND zyl2_silde_2.b ;
_QX_15_3:=NOT ManualRun AND zyl2_silde_3.on AND zyl2_silde_3.b ;
_QX_15_0:= NOT _IX_14_7 ;//_IX_15_1 AND NOT _051_M20_MP1_WZ8_QM6_MB1 AND NOT _051_M20_MP1_WZ8_QM6_MB2 AND NOT _051_M20_MP1_WZ8_QM7_MB1 AND NOT _051_M20_MP1_WZ8_QM7_MB2
          // AND NOT _051_M20_MP1_WZ8_QM8_MB1 AND NOT _051_M20_MP1_WZ8_QM8_MB2;


(* _______________ *)
(* -- Cylinders -- *)
zyl0_grip1(
	enable_man	:= Bedieneinheit.ventile_ok, 
	FNrMan		:= 605, 
	on_vz		:= T#100MS, 
	off_vz		:= T#100MS, 
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '1',
	ID			:= FaultId,
	Bild		:= picGreifermodul, 
	BildB		:= picGreifermodulInv,
 );

zyl0_grip2(
	enable_man	:= Bedieneinheit.ventile_ok, 
	FNrMan		:= 605, 
	on_vz		:= T#100MS, 
	off_vz		:= T#100MS, 
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '2',
	ID			:= FaultId,
	Bild		:= picGreifermodul, 
	BildB		:= picGreifermodulInv,
 );

zyl3_vertical_stroke(
	grundbed	:= Bedieneinheit.grundbed, 
	a			:= ix_vertical_strokeA, 
	b			:= ix_vertical_strokeB, 
	c			:= ix_vertical_strokeC, 
	enable_man	:= Bedieneinheit.ventile_ok, 
	FNr			:= 211, 
	FNrMan		:= 611, 
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '3',
	ID			:= FaultId, 
	Bild		:= picStandard, 
	Bild		:= picStandard, 
	BildB		:= picStandardInv, 
);

zyl2_interm_vertical_stroke(
	grundbed	:= Bedieneinheit.grundbed, 
	a			:= ix_interm_vertical_strokeA, 
	b			:= ix_interm_vertical_strokeB, 
	enable_man	:= Bedieneinheit.ventile_ok, 
	FNr			:= 214, 
	FNrMan		:= 614, 
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '4' ,
	ID			:= FaultId, 
	Bild		:= picStandard, 
	BildB		:= picStandardInv, 
 );
 
zyl2_hori_stroke(
	grundbed	:= Bedieneinheit.grundbed,
	a			:= ix_hori_strokeA,
	b			:= ix_hori_strokeB,
	enable_man	:= Bedieneinheit.ventile_ok,
	FNr			:= 210,
	FNrMan		:= 610,
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '5',
	ID			:= FaultId,
	Bild		:= picStandard,
	BildB		:= picStandardInv,
);

zyl2_silde_1(
	grundbed	:= Bedieneinheit.grundbed, 
	a			:= ix_silde_1A, 
	b			:= ix_silde_1B, 
	enable_man	:= Bedieneinheit.ventile_ok, 
	FNr			:= 200, 
	FNrMan		:= 600, 
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '6' ,
	ID			:= FaultId, 
	timeA		:= T#3.5S, 
	timeB		:= T#3.5S, 
	Bild		:= picStandard, 
	BildB		:= picStandardInv, 
 );

 zyl2_silde_2(
	grundbed	:= Bedieneinheit.grundbed, 
	a			:= ix_silde_2A, 
	b			:= ix_silde_2B, 
	enable_man	:= Bedieneinheit.ventile_ok, 
	FNr			:= 200, 
	FNrMan		:= 600, 
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '7' ,
	ID			:= FaultId, 
	timeA		:= T#3.5S, 
	timeB		:= T#3.5S, 
	Bild		:= picStandard, 
	BildB		:= picStandardInv, 
 );
 
 zyl2_silde_3(
	grundbed	:= Bedieneinheit.grundbed, 
	a			:= ix_silde_3A, 
	b			:= ix_silde_3B, 
	enable_man	:= Bedieneinheit.ventile_ok, 
	FNr			:= 200, 
	FNrMan		:= 600, 
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '8' ,
	ID			:= FaultId,
	timeA		:= T#3.5S, 
	timeB		:= T#3.5S,  
	Bild		:= picStandard, 
	BildB		:= picStandardInv, 
 );
 
AllInPos :=	zyl0_grip1.pos
		AND zyl0_grip2.pos
		AND zyl3_vertical_stroke.pos
		AND zyl2_interm_vertical_stroke.pos
		AND zyl2_hori_stroke.pos;

(* __________________ *)
(* -- Treat Errors -- *)
Fehler1( ID:= FaultID, FAnz:= DisplayNr, EF:= Errors1, F:= f1 );

Fault			:=	zyl0_grip1.err				(* Error´s of function blocks *)
				OR  zyl0_grip2.err
				OR 	zyl3_vertical_stroke.err
				OR  zyl2_interm_vertical_stroke.err
				OR  zyl2_hori_stroke.err
				OR	axX.out_bFault;
				
Warning := FALSE;
Waiting := FALSE;
FOR i := 1 TO ErrMaxBits BY 1 DO
	IF f1[i] THEN
		IF 		Errors1[i].Prio <= ErrZyl 			THEN Fault := TRUE;
		ELSIF	Errors1[i].Prio <= ErrEndl 			THEN Waiting := TRUE; f1[i] := FALSE;
		ELSIF	Errors1[i].Prio <= ErrWechselpos	THEN Warning := TRUE; f1[i] := FALSE; END_IF
	END_IF
END_FOR


// report Error, Waiting and Warning to cell
IF Fault 	THEN io_RtFault 	:= SETBIT32( io_RtFault,   RtStNr ); END_IF
IF Waiting 	THEN io_RtWaiting 	:= SETBIT32( io_RtWaiting, RtStNr ); END_IF
IF Warning	THEN io_RtWarning	:= SETBIT32( io_RtWarning, RtStNr ); END_IF

(* _____________________ *)
(* -- Line Controller -- *)
LC_Cavity1.in_Data.OutUserData := ADR(OutUserData);
LC_Cavity1.in_Data.OutUserData_BufferSize := SIZEOF(OutUserData);
LC_Cavity1(
		MoNr				:= MoNr, 
		StNr				:= StNr, 
		FaultID				:= FaultID, 
		DisplayNr			:= DisplayNr, 
		in_strBMK			:= 'LC', 
		in_bConnect			:= BedienEinheit.notaus_ok, 
		in_bEnableLog		:= TRUE, 
		in_sRemoteHost		:= IP_LineController, 
		in_uiRemotePort		:= 20511,//INT_TO_UINT(MoNr * 10000 + StNr + Nest1),
		in_uiStationID		:= 251,
		in_uiStationSubID	:= 1, 
		in_bTelegram64kB	:= FALSE, 
		in_bTypbeschrUebertr:= FALSE
);

LC_Cavity2.in_Data.OutUserData := ADR(OutUserData);
LC_Cavity2.in_Data.OutUserData_BufferSize := SIZEOF(OutUserData);

LC_Cavity2(
		MoNr				:= MoNr, 
		StNr				:= StNr, 
		FaultID				:= FaultID, 
		DisplayNr			:= DisplayNr, 
		in_strBMK			:= 'LC', 
		in_bConnect			:= BedienEinheit.notaus_ok, 
		in_bEnableLog		:= TRUE, 
		in_sRemoteHost		:= IP_LineController, 
		in_uiRemotePort		:= 20512,//INT_TO_UINT(MoNr * 10000 + StNr + Nest2),
		in_uiStationID		:= 251,
		in_uiStationSubID	:= 2, 
		in_bTelegram64kB	:= FALSE, 
		in_bTypbeschrUebertr:= FALSE
);

LC_Cavity3.in_Data.OutUserData := ADR(OutUserData);
LC_Cavity3.in_Data.OutUserData_BufferSize := SIZEOF(OutUserData);
LC_Cavity3(
		MoNr				:= MoNr, 
		StNr				:= StNr, 
		FaultID				:= FaultID, 
		DisplayNr			:= DisplayNr, 
		in_strBMK			:= 'LC', 
		in_bConnect			:= BedienEinheit.notaus_ok, 
		in_bEnableLog		:= TRUE, 
		in_sRemoteHost		:= IP_LineController, 
		in_uiRemotePort		:= 20513,//INT_TO_UINT(MoNr * 10000 + StNr + Nest1),
		in_uiStationID		:= 251,
		in_uiStationSubID	:= 3, 
		in_bTelegram64kB	:= FALSE, 
		in_bTypbeschrUebertr:= FALSE
);

LC_Cavity4.in_Data.OutUserData := ADR(OutUserData);
LC_Cavity4.in_Data.OutUserData_BufferSize := SIZEOF(OutUserData);

LC_Cavity4(
		MoNr				:= MoNr, 
		StNr				:= StNr, 
		FaultID				:= FaultID, 
		DisplayNr			:= DisplayNr, 
		in_strBMK			:= 'LC', 
		in_bConnect			:= BedienEinheit.notaus_ok, 
		in_bEnableLog		:= TRUE, 
		in_sRemoteHost		:= IP_LineController, 
		in_uiRemotePort		:= 20514,//INT_TO_UINT(MoNr * 10000 + StNr + Nest2),
		in_uiStationID		:= 251,
		in_uiStationSubID	:= 4, 
		in_bTelegram64kB	:= FALSE, 
		in_bTypbeschrUebertr:= FALSE
);

(* __________________________________ *)
(* -- Station - Allowed to Operate -- *)
Betrieb := 	Bedieneinheit.betrieb
		AND NOT Fault
		AND NOT ManualRun
		AND BedienEinheit.ventile_ok;


(* ____________________ *)
(* -- Start Station  -- *)
(*
IF 	RtStartimpuls THEN
	StartCondition 
		:= 	StatEin
		AND	arrCarrierData[RtNr][RtStNr][Nest1].PartDataPcb.teilestatus = srEmpty
		AND	arrCarrierData[RtNr][RtStNr][Nest2].PartDataPcb.teilestatus = srEmpty
		AND	arrCarrierData[RtNr][RtStNr][Nest3].PartDataPcb.teilestatus = srEmpty
		AND	arrCarrierData[RtNr][RtStNr][Nest4].PartDataPcb.teilestatus = srEmpty
		AND NOT ((	arrCarrierData[RtNr][2][NEST1].PartDataPcb.teilestatus > srEmpty
				OR	arrCarrierData[RtNr][2][NEST2].PartDataPcb.teilestatus > srEmpty
				OR	arrCarrierData[RtNr][2][NEST3].PartDataPcb.teilestatus > srEmpty
				OR	arrCarrierData[RtNr][2][NEST4].PartDataPcb.teilestatus > srEmpty
				OR	arrCarrierData[RtNr][3][NEST1].PartDataPcb.teilestatus > srEmpty
				OR	arrCarrierData[RtNr][3][NEST2].PartDataPcb.teilestatus > srEmpty
				OR	arrCarrierData[RtNr][3][NEST3].PartDataPcb.teilestatus > srEmpty
				OR	arrCarrierData[RtNr][3][NEST4].PartDataPcb.teilestatus > srEmpty)
			AND NOT (bReadyToPick[1] OR bReadyToPick[2] OR bReadyToPick[3])	);		
	IF StartCondition THEN bStart := TRUE; END_IF
END_IF
*)

IF 	RtStartimpuls THEN


	bPartNeeded	 := FALSE;
	iPartsNeeded := 0;

	// X-Parts are needed...
	FOR j := 1 TO 5 BY 1 DO
		IF arrCarrierData[1][j][1].PartDataPcb.teilestatus >= srGood THEN iPartsNeeded := iPartsNeeded + 1 ; END_IF
		IF arrCarrierData[1][j][2].PartDataPcb.teilestatus >= srGood THEN iPartsNeeded := iPartsNeeded + 1 ; END_IF
	END_FOR

	// ...some parts are already on it's way... 
	FOR h := 2 TO 4 BY 1 DO
		IF  arrCarrierData[2][h][1].PartDataPcb.teilestatus >= srbad THEN iPartsNeeded := iPartsNeeded - 1;END_IF
		IF  arrCarrierData[2][h][2].PartDataPcb.teilestatus >= srbad THEN iPartsNeeded := iPartsNeeded - 1;END_IF
		IF  arrCarrierData[2][h][3].PartDataPcb.teilestatus >= srbad THEN iPartsNeeded := iPartsNeeded - 1;END_IF
		IF  arrCarrierData[2][h][4].PartDataPcb.teilestatus >= srbad THEN iPartsNeeded := iPartsNeeded - 1;END_IF
	END_FOR
	
	IF in_bPartinHandlingST50 THEN iPartsNeeded := iPartsNeeded - 2 ; END_IF
	
	bPartNeeded := (iPartsNeeded > 0);

	StartCondition 			:= 	StatEin
							AND	(arrCarrierData[RtNr][RtStNr][Nest1].PartDataPcb.teilestatus = srEmpty AND NOT arrCarrierData[RtNr][RtStNr][Nest1].PartData.Mo20_St055.NotEmpty)
							AND	(arrCarrierData[RtNr][RtStNr][Nest2].PartDataPcb.teilestatus = srEmpty AND NOT arrCarrierData[RtNr][RtStNr][Nest2].PartData.Mo20_St055.NotEmpty)
							AND	(arrCarrierData[RtNr][RtStNr][Nest3].PartDataPcb.teilestatus = srEmpty AND NOT arrCarrierData[RtNr][RtStNr][Nest3].PartData.Mo20_St055.NotEmpty)
							AND	(arrCarrierData[RtNr][RtStNr][Nest4].PartDataPcb.teilestatus = srEmpty AND NOT arrCarrierData[RtNr][RtStNr][Nest4].PartData.Mo20_St055.NotEmpty)
							(*AND NOT ((	arrCarrierData[RtNr][2][NEST1].PartDataPcb.teilestatus > srEmpty
									OR	arrCarrierData[RtNr][2][NEST2].PartDataPcb.teilestatus > srEmpty
									OR	arrCarrierData[RtNr][2][NEST3].PartDataPcb.teilestatus > srEmpty
									OR	arrCarrierData[RtNr][2][NEST4].PartDataPcb.teilestatus > srEmpty
									OR	arrCarrierData[RtNr][3][NEST1].PartDataPcb.teilestatus > srEmpty
									OR	arrCarrierData[RtNr][3][NEST2].PartDataPcb.teilestatus > srEmpty
									OR	arrCarrierData[RtNr][3][NEST3].PartDataPcb.teilestatus > srEmpty
									OR	arrCarrierData[RtNr][3][NEST4].PartDataPcb.teilestatus > srEmpty)*)
							AND  (bReadyToPick[1] OR bReadyToPick[2] OR bReadyToPick[3])		
							AND NOT Bedieneinheit.mpart[Mpart].hm_leer;
						
	//  Empty Run is active, but parts are still needed (for parts in roundtable 2)
	StartConditionEmptyRun	:=		StatEin
								AND	arrCarrierData[RtNr][RtStNr][Nest1].PartDataPcb.teilestatus = srEmpty
								AND	arrCarrierData[RtNr][RtStNr][Nest2].PartDataPcb.teilestatus = srEmpty
								AND	arrCarrierData[RtNr][RtStNr][Nest3].PartDataPcb.teilestatus = srEmpty
								AND	arrCarrierData[RtNr][RtStNr][Nest4].PartDataPcb.teilestatus = srEmpty
								AND Bedieneinheit.mpart[Mpart].hm_leer
								AND bPartNeeded
                                AND FALSE;
						
	IF (StartCondition OR StartConditionEmptyRun) THEN bStart := TRUE; END_IF

END_IF


(* ________________ *)
(* -- Step-Chain -- *)
xx( iStep := Schritt );

(* reset flags *)
SWI := FALSE;

CASE Schritt OF
0:	xx.x := 'in basepos. - wait for prework or station´s start';
	IF  AllInPos
	AND bStart
	AND BedienEinheit.anl_ein
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF

1:	xx.x := 'in basepos. - wait for prework or station´s start';
	f1[feEmptyCheck1] :=ix_cavitycheck1 OR f1[feEmptyCheck1];
	f1[feEmptyCheck2] :=ix_cavitycheck2 OR f1[feEmptyCheck2];
	f1[feEmptyCheck3] :=ix_cavitycheck3 OR f1[feEmptyCheck3];
	f1[feEmptyCheck4] :=ix_cavitycheck4 OR f1[feEmptyCheck4];
	IF  AllInPos
	AND bStart
	AND BedienEinheit.anl_ein
	AND Betrieb 
	AND NOT f1[feEmptyCheck1]
	AND NOT f1[feEmptyCheck2]
	AND NOT f1[feEmptyCheck3]
	AND NOT f1[feEmptyCheck4]
	THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 4;
		SWI := TRUE;
	END_IF
	
5:	xx.x := 'Set PCB Pick Position ';
	schrittAxJumpBack		:=schritt;
	IF 	Betrieb
	THEN
	_bStepBackAllowed	:=FALSE;
			IF  (bReadyToPick[1]) THEN
				iPickPosition:=1;
			ELSIF (bReadyToPick[2] AND (NOT bReadyToPick[1])) THEN
				iPickPosition:=2;
			ELSIF (bReadyToPick[3] AND (NOT bReadyToPick[2]) AND (NOT bReadyToPick[1])) THEN
				iPickPosition:=3;
			END_IF
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF	
10:	xx.x := 'waiting for Offering of PCB';
	_bStepBackAllowed	:=FALSE;
	IF 	AllInPos
	AND Betrieb THEN
		(*warning message for waiting of slide*)	
		IF NOT bReadyToPick[iPickPosition] THEN
			f1[feWaitReady[iPickPosition]]	:=TRUE;	
		ELSIF  bReadyToPick[iPickPosition] THEN
			f1[feWaitReady[iPickPosition]]	:=FALSE;
			Schritt := Schritt + 10;
			SWI := TRUE;
		END_IF	
	END_IF		
	
20:	xx.x := 'ML1 PnP Cross Stroke -> return step';
	schrittAxJumpBack		:=schritt;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bBereitFuerPos
	THEN
		IF (iPickPosition = 1) THEN
			axX.in_lrPosSoll		:= lraxXPickPosition1;
		ELSIF (iPickPosition = 2) THEN
			axX.in_lrPosSoll		:= lraxXPickPosition2;
		ELSIF (iPickPosition = 3) THEN
			axX.in_lrPosSoll		:= lraxXPickPosition3;
		END_IF 
		axX.in_bStartPosAbsolute:=TRUE;
		(*ML1 drives to pick position 1/2/3 by jumpback process*)
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF		
		
30:	xx.x := 'ML1 PnP Cross Stroke -> Pick-Up Position';
	IF (iPickPosition = 1) THEN
			axX.in_lrPosSoll		:= lraxXPickPosition1;
	ELSIF (iPickPosition = 2) THEN
			axX.in_lrPosSoll		:= lraxXPickPosition2;
	ELSIF (iPickPosition = 3) THEN
			axX.in_lrPosSoll		:= lraxXPickPosition3;
	END_IF  
	axX.in_bStartPosAbsolute:=TRUE;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bMoveAbsoluteDone
	THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF		

35: xx.x := 'start reading DMC code';
	fb_CodeReaderBX1.in_bStartMessung := TRUE;
	fb_CodeReaderBX2.in_bStartMessung := TRUE;
	IF fb_CodeReaderBX1.out_bFertig
	OR NOT BDE_bCodeReaderOn 
	THEN
		_bStepBackAllowed	:=FALSE;
	(* -> evaluation vision check 1 *)
		IF fb_CodeReaderBX1.Fault
		OR NOT BDE_bCodeReaderOn
		OR (fb_CodeReaderBX1.arrEmpfangDatenkanal[8] <> 7)
		THEN
			//BDE Counter
			BDEIncCounter( FALSE, bcM20_St051_ReadDMCCodeNotRead_1, 1, ActOrd[MPart].ord_id, MPart);
			BDEIncCounter( TRUE	, bcM20_St051_ReadDMCCodeNotRead_1, 1, ActOrd[MPart].ord_id, MPart);	
			
			//AW X - times
			awErrorDMCCodeReadXtimes1.ischl := TRUE;
			
			//Write fbDataInfo
			dataHandlingPCB[1].iFehlercode 				:= bcM20_St051_ReadDMCCodeNotRead_1;
			dataHandlingPCB[1].teilestatus 				:= srBad;
			dataHandlingPCB[1].StNrSchlechtGesetzt 		:= StNr;	
		
			Schritt := 36;
			SWI := TRUE;			
		ELSE
			_bStepBackAllowed	:=FALSE;
      		 //DMC scan not read 			
			awErrorDMCCodeReadXtimes1.igut	 := TRUE;
	
			//read DMC Code of the UIFPCB
			strReadDMCCode1 := fb_CodeReaderBX1.out_strDetector_1;

			//Write fbDataInfo
			dataHandlingPCB[1].teilestatus 					 := srGood;
			dataHandlingPCB[1].Mo20_St051.bScanDMCCodePCBOk  := TRUE;
			//dataHandlingPCB[1].Mo20_St051.strReadDMCCodePCB  := strReadDMCCode1;
			dataHandlingPCB[1].strTeileId:= strReadDMCCode1;

			Schritt := 36;
			SWI := TRUE;		
		END_IF 		
 		awErrorDMCCodeReadXtimes1( cntmax := Fehlstop[OrderNr] );
		awErrorDMCCodeReadXtimes1.igut 	 	:= FALSE;
		awErrorDMCCodeReadXtimes1.ischl 	:= FALSE;
		f1[feErrorDMCCodeReadXTimes1] 	 := awErrorDMCCodeReadXtimes1.fehler;

	END_IF		

36: xx.x := 'start reading DMC code';
	fb_CodeReaderBX2.in_bStartMessung := TRUE;	
	IF fb_CodeReaderBX2.out_bFertig
	OR NOT BDE_bCodeReaderOn 
	THEN
		_bStepBackAllowed	:=FALSE;
	(* -> evaluation vision check 1 *)
		IF fb_CodeReaderBX2.Fault
		OR NOT BDE_bCodeReaderOn
		OR (fb_CodeReaderBX2.arrEmpfangDatenkanal[8] <> 7)
		THEN
			//BDE Counter
			BDEIncCounter( FALSE, bcM20_St051_ReadDMCCodeNotRead_2, 1, ActOrd[MPart].ord_id, MPart);
			BDEIncCounter( TRUE	, bcM20_St051_ReadDMCCodeNotRead_2, 1, ActOrd[MPart].ord_id, MPart);	
			
			//AW X - times
			awErrorDMCCodeReadXtimes2.ischl := TRUE;
			
			//Write fbDataInfo
			dataHandlingPCB[2].iFehlercode 				:= bcM20_St051_ReadDMCCodeNotRead_2;
			dataHandlingPCB[2].teilestatus 				:= srBad;
			dataHandlingPCB[2].StNrSchlechtGesetzt 		:= StNr;	
											
			Schritt := 40;
			SWI := TRUE;
		ELSE
			_bStepBackAllowed	:=FALSE;
      		 //DMC scan not read 			
			awErrorDMCCodeReadXtimes2.igut	 := TRUE;
	
			//read DMC Code of the UIFPCB
			strReadDMCCode2 := fb_CodeReaderBX2.out_strDetector_1;

			//Write fbDataInfo
			dataHandlingPCB[2].teilestatus 					 := srGood;
			dataHandlingPCB[2].Mo20_St051.bScanDMCCodePCBOk  := TRUE;
			//dataHandlingPCB[2].Mo20_St051.strReadDMCCodePCB  := strReadDMCCode2;
			dataHandlingPCB[2].strTeileId:= strReadDMCCode2;
								
			Schritt := 40;
			SWI := TRUE;
		END_IF 		
 		awErrorDMCCodeReadXtimes2( cntmax := Fehlstop[OrderNr] );
		awErrorDMCCodeReadXtimes2.igut 	 	:= FALSE;
		awErrorDMCCodeReadXtimes2.ischl 	:= FALSE;
		f1[feErrorDMCCodeReadXTimes2] 	 := awErrorDMCCodeReadXtimes2.fehler;
	END_IF

			
40:	xx.x := 'MM3 Vertical -> ON (downwards to pick-up position)';
	IF 	AllInPos
	AND Betrieb 
	AND tonVertical.q THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF	

50:	xx.x := 'MM1 MM2 Gripper 1&2 -> ON (Parts fix)';
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		dataHandling:=dataHandlingPCB;
		dataHandlingPCB[1].Init();
		dataHandlingPCB[2].Init();
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF	
	
60:	xx.x := 'MM3 Vertical -> OFF (upwards to home position)';
	IF 	AllInPos
	AND Betrieb 
	AND NOT ix_CavityCheck1
	AND NOT ix_CavityCheck2
	AND NOT ix_CavityCheck3
	AND NOT ix_CavityCheck4
	THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF		

70:	xx.x := 'MM4 Intermediate Stop Vertical-> ON (advanced to Stop Position)';
	xx.xx:= 'MM5 Horizontal Stroke -> ON (Insert Position)';
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF		
	


80:	xx.x := 'ML1 PnP Cross Stroke -> return step';
	schrittAxJumpBack		:=schritt;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bBereitFuerPos
	THEN
		axX.in_lrPosSoll		:= lraxXInsertPosition1;
		axX.in_bStartPosAbsolute:=TRUE;
		(*ML1 drives to insert position 1 by jumpback process*)
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF		
		
90:	xx.x := 'ML1 PnP Cross Stroke -> Insert Position 1';
	axX.in_lrPosSoll		:= lraxXInsertPosition1;
	axX.in_bStartPosAbsolute:=TRUE;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bMoveAbsoluteDone
	THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF		

100:	xx.x := 'MM3 Vertical -> ON (downwards to insert position)';
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF	

110:	xx.x := 'MM1 MM2 Gripper 1&2 -> OFF (Parts put)';
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF	
	
120:	xx.x := 'MM3 Vertical -> OFF (upwards to above position)';
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		
		IF ix_CavityCheck1 THEN
			arrCarrierData[RtNr][RtStNr][Nest1].PartDataPcb:=datahandling[1];
		ELSE
			arrCarrierData[RtNr][RtStNr][Nest1].PartDataPcb.Init();
		END_IF
		
		IF ix_CavityCheck3 THEN
			arrCarrierData[RtNr][RtStNr][Nest3].PartDataPcb:=datahandling[2];
		ELSE
			arrCarrierData[RtNr][RtStNr][Nest3].PartDataPcb.Init();
		END_IF
		dataHandling[1].Init();
		dataHandling[2].Init();
		Schritt := Schritt + 10;
		SWI := TRUE;

	END_IF		

130:	xx.x := 'MM4 Intermediate Stop Vertical-> OFF (retracted to Home Position)';
		xx.xx:= 'MM5 Horizontal Stroke -> OFF (Pick-Up Position)';
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF
(*
135:	xx.x := 'Set PCB Pick Position ';
	schrittAxJumpBack		:=schritt;
	IF 	Betrieb
	THEN
		_bStepBackAllowed	:=FALSE;
		iPickPosition:=iPickPosition+1;			
		IF iPickPosition > 3 THEN iPickPosition:=1; END_IF	
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF	
*)
135:xx.x := 'Set PCB Pick Position ';
	schrittAxJumpBack		:=schritt;
	IF 	Betrieb AND
		(bReadyToPick[1] OR bReadyToPick[2] OR bReadyToPick[3])
	THEN
	_bStepBackAllowed	:=FALSE;
			IF  (bReadyToPick[1]) THEN
				iPickPosition:=1;
			ELSIF (bReadyToPick[2] AND (NOT bReadyToPick[1])) THEN
				iPickPosition:=2;
			ELSIF (bReadyToPick[3] AND (NOT bReadyToPick[2]) AND (NOT bReadyToPick[1])) THEN
				iPickPosition:=3;
			END_IF
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF
	
140:	xx.x := 'ML1 PnP Cross Stroke -> return step';
	schrittAxJumpBack		:=schritt;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bBereitFuerPos
	THEN
		IF (iPickPosition = 1) THEN
			axX.in_lrPosSoll		:= lraxXPickPosition1;
		ELSIF (iPickPosition = 2) THEN
			axX.in_lrPosSoll		:= lraxXPickPosition2;
		ELSIF (iPickPosition = 3) THEN
			axX.in_lrPosSoll		:= lraxXPickPosition3;
		END_IF 
		axX.in_bStartPosAbsolute:=TRUE;
		(*ML1 drives to pick position 1/2/3 by jumpback process*)
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF		
	
150:	xx.x := 'ML1 PnP Cross Stroke -> Pick-Up Position';
	IF (iPickPosition = 1) THEN
			axX.in_lrPosSoll		:= lraxXPickPosition1;
	ELSIF (iPickPosition = 2) THEN
			axX.in_lrPosSoll		:= lraxXPickPosition2;
	ELSIF (iPickPosition = 3) THEN
			axX.in_lrPosSoll		:= lraxXPickPosition3;
	END_IF 
	axX.in_bStartPosAbsolute:=TRUE;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bMoveAbsoluteDone
	THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF	

155:	xx.x := 'waiting for PCBs feeding';
	IF 	AllInPos 
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		IF (uz.q AND NOT bReadyToPick[iPickPosition] )THEN
			f1[feWaitReady[iPickPosition]]	:=TRUE;	
		ELSIF bReadyToPick[iPickPosition] THEN
			f1[feWaitReady[iPickPosition]]	:=FALSE;
		Schritt := Schritt + 1;
		SWI := TRUE;
		END_IF	
	END_IF	

156: xx.x := 'start reading DMC code';
	fb_CodeReaderBX1.in_bStartMessung := TRUE;
	fb_CodeReaderBX2.in_bStartMessung := TRUE;
	IF fb_CodeReaderBX1.out_bFertig
	OR NOT BDE_bCodeReaderOn 
	THEN
		_bStepBackAllowed	:=FALSE;
	(* -> evaluation vision check 1 *)
		IF fb_CodeReaderBX1.Fault
		OR NOT BDE_bCodeReaderOn
		OR (fb_CodeReaderBX1.arrEmpfangDatenkanal[8] <> 7)
		THEN
			//BDE Counter
			BDEIncCounter( FALSE, bcM20_St051_ReadDMCCodeNotRead_1, 1, ActOrd[MPart].ord_id, MPart);
			BDEIncCounter( TRUE	, bcM20_St051_ReadDMCCodeNotRead_1, 1, ActOrd[MPart].ord_id, MPart);	
			
			//AW X - times
			awErrorDMCCodeReadXtimes1.ischl := TRUE;
			
			//Write fbDataInfo
			dataHandlingPCB[1].iFehlercode 				:= bcM20_St051_ReadDMCCodeNotRead_1;
			dataHandlingPCB[1].teilestatus 				:= srBad;
			dataHandlingPCB[1].StNrSchlechtGesetzt 		:= StNr;	
		
			Schritt := 157;
			SWI := TRUE;			
		ELSE
			_bStepBackAllowed	:=FALSE;
      		 //DMC scan not read 			
			awErrorDMCCodeReadXtimes1.igut	 := TRUE;
	
			//read DMC Code of the UIFPCB
			strReadDMCCode1 := fb_CodeReaderBX1.out_strDetector_1;

			//Write fbDataInfo
			dataHandlingPCB[1].teilestatus 					 := srGood;
			dataHandlingPCB[1].Mo20_St051.bScanDMCCodePCBOk  := TRUE;
			//dataHandlingPCB[1].Mo20_St051.strReadDMCCodePCB  := strReadDMCCode1;
			dataHandlingPCB[1].strTeileId:= strReadDMCCode1;
			Schritt := 157;
			SWI := TRUE;		
		END_IF 		
 		awErrorDMCCodeReadXtimes1( cntmax := Fehlstop[OrderNr] );
		awErrorDMCCodeReadXtimes1.igut 	 	:= FALSE;
		awErrorDMCCodeReadXtimes1.ischl 	:= FALSE;
		f1[feErrorDMCCodeReadXTimes1] 	 := awErrorDMCCodeReadXtimes1.fehler;

	END_IF		

157: xx.x := 'start reading DMC code';
	fb_CodeReaderBX2.in_bStartMessung := TRUE;	
	IF fb_CodeReaderBX2.out_bFertig
	OR NOT BDE_bCodeReaderOn 
	THEN
		_bStepBackAllowed	:=FALSE;
	(* -> evaluation vision check 1 *)
		IF fb_CodeReaderBX2.Fault
		OR NOT BDE_bCodeReaderOn
		OR (fb_CodeReaderBX2.arrEmpfangDatenkanal[8] <> 7)
		THEN
			//BDE Counter
			BDEIncCounter( FALSE, bcM20_St051_ReadDMCCodeNotRead_2, 1, ActOrd[MPart].ord_id, MPart);
			BDEIncCounter( TRUE	, bcM20_St051_ReadDMCCodeNotRead_2, 1, ActOrd[MPart].ord_id, MPart);	
			
			//AW X - times
			awErrorDMCCodeReadXtimes2.ischl := TRUE;
			
			//Write fbDataInfo
			dataHandlingPCB[2].iFehlercode 				:= bcM20_St051_ReadDMCCodeNotRead_2;
			dataHandlingPCB[2].teilestatus 				:= srBad;
			dataHandlingPCB[2].StNrSchlechtGesetzt 		:= StNr;	
											
			Schritt := 160;
			SWI := TRUE;
		ELSE
			_bStepBackAllowed	:=FALSE;
      		 //DMC scan not read 			
			awErrorDMCCodeReadXtimes2.igut	 := TRUE;
	
			//read DMC Code of the UIFPCB
			strReadDMCCode2 := fb_CodeReaderBX2.out_strDetector_1;

			//Write fbDataInfo
			dataHandlingPCB[2].teilestatus 					 := srGood;
			dataHandlingPCB[2].Mo20_St051.bScanDMCCodePCBOk  := TRUE;
			//dataHandlingPCB[2].Mo20_St051.strReadDMCCodePCB  := strReadDMCCode2;
			dataHandlingPCB[2].strTeileId:= strReadDMCCode2;
					
			Schritt := 160;
			SWI := TRUE;
		END_IF 		
 		awErrorDMCCodeReadXtimes2( cntmax := Fehlstop[OrderNr] );
		awErrorDMCCodeReadXtimes2.igut 	 	:= FALSE;
		awErrorDMCCodeReadXtimes2.ischl 	:= FALSE;
		f1[feErrorDMCCodeReadXTimes2] 	 := awErrorDMCCodeReadXtimes2.fehler;
	END_IF

	
160:	xx.x := 'MM3 Vertical -> ON (downwards to pick-up position)';
	IF 	AllInPos
	AND Betrieb
	AND tonVertical.q THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF	

170:	xx.x := 'MM1 MM2 Gripper 1&2 -> ON (Parts fix)';
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		dataHandling:=dataHandlingPCB;
		dataHandlingPCB[1].Init();
		dataHandlingPCB[2].Init();
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF	
	
180:	xx.x := 'MM3 Vertical -> OFF (upwards to home position)';
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF		

190:	xx.x := 'MM4 Intermediate Stop Vertical-> ON (advanced to Stop Position)';
		xx.xx:= 'MM5 Horizontal Stroke -> ON (Insert Position)';
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF	

200:	xx.x := 'ML1 PnP Cross Stroke -> return step';
	schrittAxJumpBack		:=schritt;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bBereitFuerPos
	THEN
		axX.in_lrPosSoll		:= lraxXInsertPosition2;
		axX.in_bStartPosAbsolute:=TRUE;
		(*ML1 drives to insert position 2 by jumpback process*)
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF		
		
210:	xx.x := 'ML1 PnP Cross Stroke -> Insert Position 2';
	axX.in_lrPosSoll		:= lraxXInsertPosition2;
	axX.in_bStartPosAbsolute:=TRUE;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bMoveAbsoluteDone
	THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF		

220:	xx.x := 'MM3 Vertical -> ON (downwards to insert position)';
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF	

230:	xx.x := 'MM1 MM2 Gripper 1&2 -> OFF (Parts put)';
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF	
	
240:	xx.x := 'MM3 Vertical -> OFF (upwards to above position)';
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		IF ix_CavityCheck2 THEN
			arrCarrierData[RtNr][RtStNr][Nest2].PartDataPcb:=datahandling[1];
		ELSE
			arrCarrierData[RtNr][RtStNr][Nest2].PartDataPcb.Init();
		END_IF
		
		IF ix_CavityCheck4 THEN
			arrCarrierData[RtNr][RtStNr][Nest4].PartDataPcb:=datahandling[2];
		ELSE
			arrCarrierData[RtNr][RtStNr][Nest4].PartDataPcb.Init();
		END_IF
		dataHandling[1].Init();
		dataHandling[2].Init();
		
		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF			



241:xx.x := 'Check Serial number in LineController';
	
	IF arrCarrierData[RtNr][RtStNr][Nest1].PartDatapcb.teilestatus = srempty THEN
		Schritt := Schritt + 5;
		SWI := TRUE; 
	ELSIF arrCarrierData[RtNr][RtStNr][Nest1].PartDatapcb.iFehlercode = bcM20_St051_ReadDMCCodeNotRead_1 THEN
		Schritt := Schritt + 5;
		SWI := TRUE;
	ELSIF NOT LC_Cavity1.out_bBusy THEN
		LC_Cavity1.in_Data.SerialNo:= arrCarrierData[RtNr][RtStNr][Nest1].PartDatapcb.strTeileId;			//+1 by each cycle
		LC_Cavity1.in_Data.TypeNo  := '80640-216/0003';
		LC_Cavity1.in_Data.AssyLocation := 0;
		LC_Cavity1.in_Data.OPcode := ENU_LC_OpCode.checkSNRState;
		LC_Cavity1.in_bSendTelegram := TRUE;
	END_IF

	IF LC_Cavity1.out_bBusy AND NOT LC_Cavity1.out_bError THEN
		Schritt := Schritt + 1;
		SWI := TRUE;
		LC_Cavity1.in_bSendTelegram := FALSE;
	END_IF

242: xx.x := 'Wait for result of OP15 = checkSNRState from LC';
	IF NOT LC_Cavity1.out_bBusy THEN
		IF NOT LC_Cavity1.out_bError AND LC_Cavity1.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackSucces THEN
			(* merge parts *)
			Schritt := Schritt + 1;
			SWI := TRUE;
		ELSE
			IF LC_Cavity1.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackReserved  THEN // TCP/IP-Fehler
				Schritt := 241;
				SWI := TRUE;
			
			END_IF
		END_IF
	END_IF	

243:xx.x := 'Check Serial number in LineController';

	IF NOT LC_Cavity1.out_bBusy THEN
		LC_Cavity1.in_Data.SerialNo:= arrCarrierData[RtNr][RtStNr][Nest1].PartDatapcb.strTeileId;			//+1 by each cycle
		LC_Cavity1.in_Data.TypeNo  := 'PCB_GM';
		arrCarrierData[RtNr][RtStNr][Nest1].PartDatapcb.strTypeNr:=LC_Cavity1.in_Data.TypeNo;
		LC_Cavity1.in_Data.AssyLocation := 0;
		LC_Cavity1.in_Data.OPcode := ENU_LC_OpCode.createMainpartFromRemote;
		LC_Cavity1.in_bSendTelegram := TRUE;
	END_IF

	IF LC_Cavity1.out_bBusy AND NOT LC_Cavity1.out_bError THEN
		Schritt := Schritt + 1;
		SWI := TRUE;
		LC_Cavity1.in_bSendTelegram := FALSE;
	END_IF

244: xx.x := 'Wait for result of OP15 = checkSNRState from LC';
	IF NOT LC_Cavity1.out_bBusy THEN
		IF NOT LC_Cavity1.out_bError AND LC_Cavity1.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackSucces THEN
			(* merge parts *)
			Schritt := Schritt + 1;
			SWI := TRUE;
		ELSE
			IF LC_Cavity1.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackReserved  THEN // TCP/IP-Fehler
				Schritt := 243;
				SWI := TRUE;
			
			END_IF
		END_IF
	END_IF		
	
245:xx.x := 'Upload result to LC';
	IF (arrCarrierData[RtNr][RtStNr][Nest1].PartDatapcb.teilestatus = srGood) THEN
		LC_Cavity1.UploadStateAndResultData(	arrCarrierData[RtNr][RtStNr][Nest1].PartDatapcb.strTypeNr,
										arrCarrierData[RtNr][RtStNr][Nest1].PartDatapcb.strTeileId,
										0,(*Fail_Location*)
										0(*Fail_Type*)
									);
	ELSIF (arrCarrierData[RtNr][RtStNr][Nest1].PartDatapcb.iFehlercode = bcM20_St051_PresenceError_1) THEN
		LC_Cavity1.UploadStateAndResultData(	arrCarrierData[RtNr][RtStNr][Nest1].PartData.strTypeNr,
										arrCarrierData[RtNr][RtStNr][Nest1].PartDatapcb.strTeileId,
										bcM20_St051_PresenceError_1,(*Fail_Location*)
										LCID_FAIL_PRESENCE//LCID_FAIL_PRESENCE(*Fail_Type*) 
									);
	END_IF
	IF (LC_Cavity1.comUploadStateAndResultData.bStarted OR LC_Cavity1.comUploadStateAndResultData.bDone) THEN
		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF;	
	
246:xx.x := 'Check Serial number in LineController';
	
	IF arrCarrierData[RtNr][RtStNr][Nest2].PartDatapcb.teilestatus = srempty THEN
		Schritt := Schritt + 5;
		SWI := TRUE; 
	ELSIF arrCarrierData[RtNr][RtStNr][Nest2].PartDatapcb.iFehlercode = bcM20_St051_ReadDMCCodeNotRead_1 THEN
		Schritt := Schritt + 5;
		SWI := TRUE;
	ELSIF NOT LC_Cavity2.out_bBusy THEN
		LC_Cavity2.in_Data.SerialNo:= arrCarrierData[RtNr][RtStNr][Nest2].PartDatapcb.strTeileId;			//+1 by each cycle
		LC_Cavity2.in_Data.TypeNo  := '80640-216/0003';
		LC_Cavity2.in_Data.AssyLocation := 0;
		LC_Cavity2.in_Data.OPcode := ENU_LC_OpCode.checkSNRState;
		LC_Cavity2.in_bSendTelegram := TRUE;
	END_IF

	IF LC_Cavity2.out_bBusy AND NOT LC_Cavity2.out_bError THEN
		Schritt := Schritt + 1;
		SWI := TRUE;
		LC_Cavity2.in_bSendTelegram := FALSE;
	END_IF

247: xx.x := 'Wait for result of OP15 = checkSNRState from LC';
	IF NOT LC_Cavity2.out_bBusy THEN
		IF NOT LC_Cavity2.out_bError AND LC_Cavity2.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackSucces THEN
			(* merge parts *)
			Schritt := Schritt + 1;
			SWI := TRUE;
		ELSE
			IF LC_Cavity2.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackReserved  THEN // TCP/IP-Fehler
				Schritt := 246;
				SWI := TRUE;
			
			END_IF
		END_IF
	END_IF	

248:xx.x := 'Check Serial number in LineController';

	IF NOT LC_Cavity2.out_bBusy THEN
		LC_Cavity2.in_Data.SerialNo:= arrCarrierData[RtNr][RtStNr][Nest2].PartDatapcb.strTeileId;			//+1 by each cycle
		LC_Cavity2.in_Data.TypeNo  := 'PCB_GM';
		arrCarrierData[RtNr][RtStNr][Nest2].PartDatapcb.strTypeNr:=LC_Cavity2.in_Data.TypeNo;
		LC_Cavity2.in_Data.AssyLocation := 0;
		LC_Cavity2.in_Data.OPcode := ENU_LC_OpCode.createMainpartFromRemote;
		LC_Cavity2.in_bSendTelegram := TRUE;
	END_IF

	IF LC_Cavity2.out_bBusy AND NOT LC_Cavity2.out_bError THEN
		Schritt := Schritt + 1;
		SWI := TRUE;
		LC_Cavity2.in_bSendTelegram := FALSE;
	END_IF

249: xx.x := 'Wait for result of OP15 = checkSNRState from LC';
	IF NOT LC_Cavity2.out_bBusy THEN
		IF NOT LC_Cavity2.out_bError AND LC_Cavity2.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackSucces THEN
			(* merge parts *)
			Schritt := Schritt + 1;
			SWI := TRUE;
		ELSE
			IF LC_Cavity2.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackReserved  THEN // TCP/IP-Fehler
				Schritt := 248;
				SWI := TRUE;
			
			END_IF
		END_IF
	END_IF		
	
250:xx.x := 'Upload result to LC';
	IF (arrCarrierData[RtNr][RtStNr][Nest2].PartDatapcb.teilestatus = srGood) THEN
		LC_Cavity2.UploadStateAndResultData(	arrCarrierData[RtNr][RtStNr][Nest2].PartDatapcb.strTypeNr,
										arrCarrierData[RtNr][RtStNr][Nest2].PartDatapcb.strTeileId,
										0,(*Fail_Location*)
										0(*Fail_Type*)
									);
	ELSIF (arrCarrierData[RtNr][RtStNr][Nest2].PartDatapcb.iFehlercode = bcM20_St051_PresenceError_2) THEN
		LC_Cavity2.UploadStateAndResultData(	arrCarrierData[RtNr][RtStNr][Nest2].PartDatapcb.strTypeNr,
										arrCarrierData[RtNr][RtStNr][Nest2].PartDatapcb.strTeileId,
										bcM20_St051_PresenceError_2,(*Fail_Location*)
										LCID_FAIL_PRESENCE//LCID_FAIL_PRESENCE(*Fail_Type*) 
									);
	END_IF
	IF (LC_Cavity2.comUploadStateAndResultData.bStarted OR LC_Cavity2.comUploadStateAndResultData.bDone) THEN
		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF;	
	
251:xx.x := 'Check Serial number in LineController';

	IF arrCarrierData[RtNr][RtStNr][Nest3].PartDatapcb.teilestatus = srempty THEN
		Schritt := Schritt + 5;
		SWI := TRUE; 
	ELSIF arrCarrierData[RtNr][RtStNr][Nest3].PartDatapcb.iFehlercode = bcM20_St051_ReadDMCCodeNotRead_2 THEN
		Schritt := Schritt + 5;
		SWI := TRUE;
	ELSIF NOT LC_Cavity3.out_bBusy THEN
		LC_Cavity3.in_Data.SerialNo:= arrCarrierData[RtNr][RtStNr][Nest3].PartDatapcb.strTeileId;			//+1 by each cycle
		LC_Cavity3.in_Data.TypeNo  := '80640-216/0003';
		LC_Cavity3.in_Data.AssyLocation := 0;
		LC_Cavity3.in_Data.OPcode := ENU_LC_OpCode.checkSNRState;
		LC_Cavity3.in_bSendTelegram := TRUE;
	END_IF

	IF LC_Cavity3.out_bBusy AND NOT LC_Cavity3.out_bError THEN
		Schritt := Schritt + 1;
		SWI := TRUE;
		LC_Cavity3.in_bSendTelegram := FALSE;
	END_IF

252: xx.x := 'Wait for result of OP15 = checkSNRState from LC';
	IF NOT LC_Cavity3.out_bBusy THEN
		IF NOT LC_Cavity3.out_bError AND LC_Cavity3.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackSucces THEN
			(* merge parts *)
			Schritt := Schritt + 1;
			SWI := TRUE;
		ELSE
			IF LC_Cavity3.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackReserved  THEN // TCP/IP-Fehler
				Schritt := 251;
				SWI := TRUE;
			
			END_IF
		END_IF
	END_IF	

253:xx.x := 'Check Serial number in LineController';

	IF NOT LC_Cavity3.out_bBusy THEN
		LC_Cavity3.in_Data.SerialNo:= arrCarrierData[RtNr][RtStNr][Nest3].PartDatapcb.strTeileId;			//+1 by each cycle
		LC_Cavity3.in_Data.TypeNo  := 'PCB_GM';
		arrCarrierData[RtNr][RtStNr][Nest3].PartDatapcb.strTypeNr:=LC_Cavity3.in_Data.TypeNo;
		LC_Cavity3.in_Data.AssyLocation := 0;
		LC_Cavity3.in_Data.OPcode := ENU_LC_OpCode.createMainpartFromRemote;
		LC_Cavity3.in_bSendTelegram := TRUE;
	END_IF

	IF LC_Cavity3.out_bBusy AND NOT LC_Cavity3.out_bError THEN
		Schritt := Schritt + 1;
		SWI := TRUE;
		LC_Cavity1.in_bSendTelegram := FALSE;
	END_IF

254: xx.x := 'Wait for result of OP15 = checkSNRState from LC';
	IF NOT LC_Cavity3.out_bBusy THEN
		IF NOT LC_Cavity3.out_bError AND LC_Cavity3.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackSucces THEN
			(* merge parts *)
			Schritt := Schritt + 1;
			SWI := TRUE;
		ELSE
			IF LC_Cavity3.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackReserved  THEN // TCP/IP-Fehler
				Schritt := 253;
				SWI := TRUE;
			
			END_IF
		END_IF
	END_IF		
	
255:xx.x := 'Upload result to LC';
	IF (arrCarrierData[RtNr][RtStNr][Nest3].PartDatapcb.teilestatus = srGood) THEN
		LC_Cavity3.UploadStateAndResultData(	arrCarrierData[RtNr][RtStNr][Nest3].PartDatapcb.strTypeNr,
										arrCarrierData[RtNr][RtStNr][Nest3].PartDatapcb.strTeileId,
										0,(*Fail_Location*)
										0(*Fail_Type*)
									);
	ELSIF (arrCarrierData[RtNr][RtStNr][Nest3].PartDatapcb.iFehlercode = bcM20_St051_PresenceError_3) THEN
		LC_Cavity3.UploadStateAndResultData(	arrCarrierData[RtNr][RtStNr][Nest3].PartDatapcb.strTypeNr,
										arrCarrierData[RtNr][RtStNr][Nest3].PartDatapcb.strTeileId,
										bcM20_St051_PresenceError_3,(*Fail_Location*)
										LCID_FAIL_PRESENCE//LCID_FAIL_PRESENCE(*Fail_Type*) 
									);
	END_IF
	IF (LC_Cavity3.comUploadStateAndResultData.bStarted OR LC_Cavity3.comUploadStateAndResultData.bDone) THEN
		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF;	
	
256:xx.x := 'Check Serial number in LineController';

	IF arrCarrierData[RtNr][RtStNr][Nest4].PartDatapcb.teilestatus = srempty THEN
		Schritt := Schritt + 24;
		SWI := TRUE;
	ELSIF arrCarrierData[RtNr][RtStNr][Nest4].PartDatapcb.iFehlercode = bcM20_St051_ReadDMCCodeNotRead_2 THEN
		Schritt := Schritt + 24;
		SWI := TRUE;
	ELSIF NOT LC_Cavity4.out_bBusy THEN
		LC_Cavity4.in_Data.SerialNo:= arrCarrierData[RtNr][RtStNr][Nest4].PartDatapcb.strTeileId;			//+1 by each cycle
		LC_Cavity4.in_Data.TypeNo  := '80640-216/0003';
		LC_Cavity4.in_Data.AssyLocation := 0;
		LC_Cavity4.in_Data.OPcode := ENU_LC_OpCode.checkSNRState;
		LC_Cavity4.in_bSendTelegram := TRUE;
	END_IF

	IF LC_Cavity4.out_bBusy AND NOT LC_Cavity4.out_bError THEN
		Schritt := Schritt + 1;
		SWI := TRUE;
		LC_Cavity4.in_bSendTelegram := FALSE;
	END_IF

257: xx.x := 'Wait for result of OP15 = checkSNRState from LC';
	IF NOT LC_Cavity4.out_bBusy THEN
		IF NOT LC_Cavity4.out_bError AND LC_Cavity4.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackSucces THEN
			(* merge parts *)
			Schritt := Schritt + 1;
			SWI := TRUE;
		ELSE
			IF LC_Cavity4.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackReserved  THEN // TCP/IP-Fehler
				Schritt := 256;
				SWI := TRUE;
			
			END_IF
		END_IF
	END_IF	

258:xx.x := 'Check Serial number in LineController';

	IF NOT LC_Cavity4.out_bBusy THEN
		LC_Cavity4.in_Data.SerialNo:= arrCarrierData[RtNr][RtStNr][Nest4].PartDatapcb.strTeileId;			//+1 by each cycle
		LC_Cavity4.in_Data.TypeNo  := 'PCB_GM';
		arrCarrierData[RtNr][RtStNr][Nest4].PartDatapcb.strTypeNr:=LC_Cavity4.in_Data.TypeNo;
		LC_Cavity4.in_Data.AssyLocation := 0;
		LC_Cavity4.in_Data.OPcode := ENU_LC_OpCode.createMainpartFromRemote;
		LC_Cavity4.in_bSendTelegram := TRUE;
	END_IF

	IF LC_Cavity4.out_bBusy AND NOT LC_Cavity4.out_bError THEN
		Schritt := Schritt + 1;
		SWI := TRUE;
		LC_Cavity4.in_bSendTelegram := FALSE;
	END_IF

259: xx.x := 'Wait for result of OP15 = checkSNRState from LC';
	IF NOT LC_Cavity4.out_bBusy THEN
		IF NOT LC_Cavity4.out_bError AND LC_Cavity4.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackSucces THEN
			(* merge parts *)
			Schritt := Schritt + 1;
			SWI := TRUE;
		ELSE
			IF LC_Cavity4.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackReserved  THEN // TCP/IP-Fehler
				Schritt := 258;
				SWI := TRUE;
			
			END_IF
		END_IF
	END_IF		
	
260:xx.x := 'Upload result to LC';
	IF (arrCarrierData[RtNr][RtStNr][Nest4].PartDatapcb.teilestatus = srGood) THEN
		LC_Cavity4.UploadStateAndResultData(	arrCarrierData[RtNr][RtStNr][Nest4].PartDatapcb.strTypeNr,
										arrCarrierData[RtNr][RtStNr][Nest4].PartDatapcb.strTeileId,
										0,(*Fail_Location*)
										0(*Fail_Type*)
									);
	ELSIF (arrCarrierData[RtNr][RtStNr][Nest2].PartDatapcb.iFehlercode = bcM20_St051_PresenceError_4) THEN
		LC_Cavity4.UploadStateAndResultData(	arrCarrierData[RtNr][RtStNr][Nest4].PartDatapcb.strTypeNr,
										arrCarrierData[RtNr][RtStNr][Nest4].PartDatapcb.strTeileId,
										bcM20_St051_PresenceError_4,(*Fail_Location*)
										LCID_FAIL_PRESENCE//LCID_FAIL_PRESENCE(*Fail_Type*) 
									);
	END_IF
	IF (LC_Cavity4.comUploadStateAndResultData.bStarted OR LC_Cavity4.comUploadStateAndResultData.bDone) THEN
		Schritt := Schritt + 20;
		bStart := FALSE;
		SWI := TRUE;
	END_IF;	
	
280:	xx.x := 'MM4 Intermediate Stop Vertical-> OFF (retracted to Home Position)';
		xx.xx:= 'MM5 Horizontal Stroke -> OFF (Pick-Up Position)';
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		schrittAxJumpBack	:=0;
		bStart := FALSE;
		Schritt := 0;
		SWI := TRUE;
	END_IF	
	
END_CASE


(* ____________________ *)
(* -- React to Steps -- *)
IF NOT ManualRun THEN
zyl0_grip1.on 					:= 	( (Schritt >= 50) AND (Schritt < 110) )
								OR	( (Schritt >= 170) AND (Schritt < 230) );	

zyl0_grip2.on 					:= 	( (Schritt >= 50) AND (Schritt < 110) )
								OR	( (Schritt >= 170) AND (Schritt < 230) );

zyl3_vertical_stroke.on			:= 	( (Schritt >= 40) AND (Schritt < 60) )
								OR	( (Schritt >= 160) AND (Schritt < 180) );	

zyl3_vertical_stroke.zwischen	:= 	( (Schritt >= 100) AND (Schritt < 120) )
								OR	( (Schritt >= 220) AND (Schritt < 240) );	

zyl2_interm_vertical_stroke.on	:= 	( (Schritt >= 70) AND (Schritt < 130) )
								OR	( (Schritt >= 190) AND (Schritt < 280) );	
						
zyl2_hori_stroke.on				:= 	( (Schritt >= 70) AND (Schritt < 130) )
								OR	( (Schritt >= 190) AND (Schritt < 280) );
END_IF
(*
(* -- React to Sildes Controll -- *)
IF NOT ManualRun THEN
	zyl2_silde_1.on				:=bPickProcess[1];
	zyl2_silde_2.on				:=bPickProcess[2];
	zyl2_silde_3.on				:=bPickProcess[3];
END_IF
*)
(* -- Axes Festo Servocontroller -- *)
axXID	:=cAx_M020_St51_TA1;



(* prevent structure crash*) //DWOCOM values need to be checked

_bArea1ToMoveAllowed		:=	(axX.out_lrPosIst>(lraxXPickPosition1 - 1))     //(Toleranz) value is not right, should be inputted before ST commission
						  AND 	(axX.out_lrPosIst<(lraxXPickPosition1 + 1));
_bArea2ToMoveAllowed		:=	(axX.out_lrPosIst>(lraxXPickPosition2 - 1))     //(Toleranz) value is not right, should be inputted before ST commission
						  AND 	(axX.out_lrPosIst<(lraxXPickPosition2 + 1));
_bArea3ToMoveAllowed		:=	(axX.out_lrPosIst>(lraxXPickPosition3 - 1))     //(Toleranz) value is not right, should be inputted before ST commission
						  AND 	(axX.out_lrPosIst<(lraxXPickPosition3 + 1));
_bArea4ToMoveAllowed		:=	(axX.out_lrPosIst>(lraxXInsertPosition1 - 5.00))    //(Toleranz) value is not right, should be inputted before ST commission
						  AND 	(axX.out_lrPosIst<(lraxXInsertPosition1 + 5.00));
_bArea5ToMoveAllowed		:=	(axX.out_lrPosIst>(lraxXInsertPosition2 - 5.00))    //(Toleranz) value is not right, should be inputted before ST commission
						  AND 	(axX.out_lrPosIst<(lraxXInsertPosition2 + 5.00));
						  
_bMoveAxisAllowed			:=	(zyl3_vertical_stroke.a
						AND NOT  zyl3_vertical_stroke.y);

//Jump back if...
(*
IF(		Bedieneinheit.notaus_ok = FALSE			// if jumpback is allowed
	OR	Bedieneinheit.ventile_ok =FALSE
	OR  Bedieneinheit.grundbed = FALSE
	OR  Bedieneinheit.schutz_ok = FALSE
	OR  axX.out_bFault
	OR ( (    ( NOT _bArea1ToMoveAllowed AND  (iPickPosition = 1))
			OR( NOT _bArea2ToMoveAllowed AND  (iPickPosition = 2))
			OR( NOT _bArea3ToMoveAllowed AND  (iPickPosition = 3)))
	    AND (schritt > 30 AND schritt <=70))
	OR (NOT _bArea4ToMoveAllowed
	    AND (schritt > 90 AND schritt <=140))
	OR (NOT _bArea5ToMoveAllowed
		AND i >	0								//for initial condition, the elek. stroke could be anywhere
	    AND (schritt > 210 OR schritt <=20))
	AND _bStepBackAllowed)
 THEN 
	_baxJumpBackDemanded	:=TRUE;
	
ELSIF _baxJumpBackDemanded						//start the process of jumpback
	AND Betrieb
 THEN 
	_baxJumpBackDemanded	:=FALSE;
	Schritt :=	SchrittAxJumpBack;
	SWI	:= TRUE;

END_IF
*)


(*-------- Axis Input --------*)

axX(
	BedienEinheit							:= BedienEinheit, 
	FaultID									:= FaultID, 
	DisplayNr								:= DisplayNr, 
	ixP_Stop								:= ix_axX_P_Stop AND _bMoveAxisAllowed, 
	ixN_Stop								:= ix_axX_N_Stop AND _bMoveAxisAllowed, 
	ixRef									:= FALSE, 									
	in_strAchsbezeichnung					:= '=51-TA1', 
	in_strP_Stop							:= '=051-BG1.P', 
	in_strN_Stop							:= '=051-BG1.N', 
	ixBtb									:= BedienEinheit.grundbed OR ix_axX_Ready, 
	in_bSvvVersorgt							:= BedienEinheit.hauptstrom_ok, 
	in_bSvvFreigabe							:= BedienEinheit.grundbed AND BedienEinheit.schutz_ok, 
	in_bSoftwareEnable						:= StatEin, 
	in_lrVelocityPercentAuto				:= lraxXSpeedPositioning, 
	in_lrVelocityPercentManual				:= lraxXSpeedPositioning/5, 
	in_lrVelocityGuardOpen					:= 25.0, 
	Axis									:= g_arrAxisRef [axXID], 
	);	

	
	axX.in_bJogForward			:= FALSE;
	axX.in_bJogBackwards		:= FALSE;
	axX.in_bStartPosAbsolute	:= FALSE;
	axX.in_bStartPosAbsolute_2	:= FALSE;					//normally dont need to use it
	axX.in_bNotHalt				:= FALSE;
	axX.in_lrAcceleration		:= 0;
	axX.in_lrDeceleration		:= 0;
	axX.in_bStopTransport		:= NOT bedieneinheit.betr_ein;
	
	
	F_InitAchseOhneKoordsysteme(
		iAchsId						:= axXID, 
		iActionButtonSlow			:= -1, 
		iActionButtonFast			:= -1, 
		strBetriebsmittelname		:= 'M020=St51-TA1', 
		strKlartextname				:= 'X-Axis', 
		strEinheitennameWeg			:= 'mm', 
		strEinheitennameSpeed		:= 'mm/s', 
		bAbsolutAchse				:= FALSE,  				  //not sure 
		 );						
	



	//Insert target- and actuel Position in Axis structure
	g_Achsen[axXID].iAnzKoordsysteme													:=1;
	g_Achsen[axXID].arr_stCoord[cCoordMachine].strName									:='Position';
	g_Achsen[axXID].arr_stCoord[cCoordMachine].lrIstPos									:=axX.out_lrPosIst;
	g_Achsen[axXID].arr_stCoord[cCoordMachine].lrSollPos								:=axX.in_lrPosSoll;



(* == Code Reader Sensopart V10-CR-A1-R6D check DMC code == *)
fb_CodeReaderBX1(
	MoNr						:= MoNr, 
	BedienEinheit				:= BedienEinheit, 
	FaultID						:= FaultID_CodeReader_M20_St51_1, 
	DisplayNr					:= DisplayNr, 
	MPart						:= MPart, 
	StatString					:= StatString, 
	in_sNameDevice_10digits		:= '  =51-BX1', 
	in_byteJobNr				:= 1,
	in_sRemoteHost				:= IP_CodeReader_BX1, 
	in_bBetriebsartFreilaufend	:= FALSE, 
);
fb_CodeReaderBX1.in_bStartMessung := FALSE;	
	
fb_CodeReaderBX2(
	MoNr						:= MoNr, 
	BedienEinheit				:= BedienEinheit, 
	FaultID						:= FaultID_CodeReader_M20_St51_2, 
	DisplayNr					:= DisplayNr, 
	MPart						:= MPart, 
	StatString					:= StatString, 
	in_sNameDevice_10digits		:= '  =51-BX2', 
	in_byteJobNr				:= 1,
	in_sRemoteHost				:= IP_CodeReader_BX2, 
	in_bBetriebsartFreilaufend	:= FALSE, 
);
fb_CodeReaderBX2.in_bStartMessung := FALSE;		
	
(* _____________________________________ *)
(* -- Stop Roundtable Condition-Based -- *)
IF  	 (zyl3_vertical_stroke.b OR zyl3_vertical_stroke.c OR zyl3_vertical_stroke.y OR NOT zyl3_vertical_stroke.a )
	AND  (zyl2_hori_stroke.b OR zyl2_hori_stroke.y OR NOT zyl2_hori_stroke.a )
THEN 
	F_ResetFrgRtWithText(TRUE, RtNr, RtStNr, '051MM4 §Vertical§ §not§ §in§ §base-pos.§', io_RtFreigabe); (*DWOCOM Name should be changed, too long if write every cyl. down*)
END_IF


(* ______________________________________ *)
(* -- Report Station is working on RT  -- *)
io_RtStarts := CSETBIT32(io_RtStarts, RtStNr, bStart);


(* _________________ *)
(* -- Set outputs -- *)

(*Festo Serco Output*)
_051_M20_P1_TA1_X1_9		:=axX.qxEnable;								//qx_axX_ReglerFreigabe    DWOCOM
_051_M20_P1_TA1_X1_21		:=axX.qxEnable;								//qx_axX_EndstufeFreigabe	DWOCOM

IF ManualRun THEN (* assign cylinderoutputs .y (by "AND Bedieneinheit.ventile_ok") *)
	_051_M20_MP1_WZ8_QM1_MB1		:=		zyl0_grip1.y AND Bedieneinheit.ventile_ok;
	_051_M20_MP1_WZ8_QM1_MB2		:=	NOT zyl0_grip1.y AND Bedieneinheit.ventile_ok;
	
	_051_M20_MP1_WZ8_QM2_MB1		:=		zyl0_grip2.y AND Bedieneinheit.ventile_ok;
	_051_M20_MP1_WZ8_QM2_MB2		:=	NOT zyl0_grip2.y AND Bedieneinheit.ventile_ok;
	
	_051_M20_MP1_WZ8_QM3_MB1		:=		zyl3_vertical_stroke.y AND Bedieneinheit.ventile_ok;
	_051_M20_MP1_WZ8_QM3_MB2		:=	NOT zyl3_vertical_stroke.y AND Bedieneinheit.ventile_ok;
	
	_051_M20_MP1_WZ8_QM4_MB1		:=		zyl2_interm_vertical_stroke.y AND Bedieneinheit.ventile_ok;
	_051_M20_MP1_WZ8_QM4_MB2		:=	NOT zyl2_interm_vertical_stroke.y AND Bedieneinheit.ventile_ok;
	
	_051_M20_MP1_WZ8_QM5_MB1		:=		zyl2_hori_stroke.y AND Bedieneinheit.ventile_ok;
	_051_M20_MP1_WZ8_QM5_MB2		:=	NOT zyl2_hori_stroke.y AND Bedieneinheit.ventile_ok;
	
	_051_M20_MP1_WZ8_QM6_MB1		:=		zyl2_silde_1.y AND Bedieneinheit.ventile_ok AND NOT _IX_15_1;
	_051_M20_MP1_WZ8_QM6_MB2		:=	NOT zyl2_silde_1.y AND Bedieneinheit.ventile_ok AND NOT _IX_15_1;
	
	_051_M20_MP1_WZ8_QM7_MB1		:=		zyl2_silde_2.y AND Bedieneinheit.ventile_ok AND NOT _IX_15_1;
	_051_M20_MP1_WZ8_QM7_MB2		:=	NOT zyl2_silde_2.y AND Bedieneinheit.ventile_ok AND NOT _IX_15_1;
	
	_051_M20_MP1_WZ8_QM8_MB1		:=		zyl2_silde_3.y AND Bedieneinheit.ventile_ok AND NOT _IX_15_1;
	_051_M20_MP1_WZ8_QM8_MB2		:=	NOT zyl2_silde_3.y AND Bedieneinheit.ventile_ok AND NOT _IX_15_1;

ELSE (* assign cylinderoutputs .on (by "AND Bedieneinheit.ventile_ok") *)
	_051_M20_MP1_WZ8_QM1_MB1		:=		zyl0_grip1.on AND Bedieneinheit.ventile_ok;
	_051_M20_MP1_WZ8_QM1_MB2		:=	NOT zyl0_grip1.on AND Bedieneinheit.ventile_ok;
	
	_051_M20_MP1_WZ8_QM2_MB1		:=		zyl0_grip2.on AND Bedieneinheit.ventile_ok;
	_051_M20_MP1_WZ8_QM2_MB2		:=	NOT zyl0_grip2.on AND Bedieneinheit.ventile_ok;
	
	_051_M20_MP1_WZ8_QM3_MB1		:=		(zyl3_vertical_stroke.on OR zyl3_vertical_stroke.zwischen) AND Bedieneinheit.ventile_ok;
	_051_M20_MP1_WZ8_QM3_MB2		:=	NOT (zyl3_vertical_stroke.on OR zyl3_vertical_stroke.zwischen) AND Bedieneinheit.ventile_ok;
	
	_051_M20_MP1_WZ8_QM4_MB1		:=		zyl2_interm_vertical_stroke.on AND Bedieneinheit.ventile_ok;
	_051_M20_MP1_WZ8_QM4_MB2		:=	NOT zyl2_interm_vertical_stroke.on AND Bedieneinheit.ventile_ok;
	
	_051_M20_MP1_WZ8_QM5_MB1		:=		zyl2_hori_stroke.on AND Bedieneinheit.ventile_ok;
	_051_M20_MP1_WZ8_QM5_MB2		:=	NOT zyl2_hori_stroke.on AND Bedieneinheit.ventile_ok;
	
	_051_M20_MP1_WZ8_QM6_MB1		:=		zyl2_silde_1.on AND Bedieneinheit.ventile_ok;// AND NOT _IX_15_1 AND _IX_15_2 ;
	_051_M20_MP1_WZ8_QM6_MB2		:=	NOT zyl2_silde_1.on AND Bedieneinheit.ventile_ok;// AND NOT _IX_15_1 AND _IX_15_2 ;
	
	_051_M20_MP1_WZ8_QM7_MB1		:=		zyl2_silde_2.on AND Bedieneinheit.ventile_ok;// AND NOT _IX_15_1 AND _IX_15_4;
	_051_M20_MP1_WZ8_QM7_MB2		:=	NOT zyl2_silde_2.on AND Bedieneinheit.ventile_ok;// AND NOT _IX_15_1 AND _IX_15_4;
	
	_051_M20_MP1_WZ8_QM8_MB1		:=		zyl2_silde_3.on AND Bedieneinheit.ventile_ok;// AND NOT _IX_15_1 AND _IX_15_6;
	_051_M20_MP1_WZ8_QM8_MB2		:=	NOT zyl2_silde_3.on AND Bedieneinheit.ventile_ok;// AND NOT _IX_15_1 AND _IX_15_6;
	
END_IF
]]></ST>
    </Implementation>
    <LineIds Name="Mo20_St51_transfer_the_pcb_to_RT1">
      <LineId Id="7910" Count="83" />
      <LineId Id="9033" Count="2" />
      <LineId Id="9032" Count="0" />
      <LineId Id="9031" Count="0" />
      <LineId Id="7994" Count="25" />
      <LineId Id="10353" Count="0" />
      <LineId Id="8020" Count="11" />
      <LineId Id="9998" Count="2" />
      <LineId Id="10727" Count="0" />
      <LineId Id="10683" Count="0" />
      <LineId Id="10315" Count="0" />
      <LineId Id="10317" Count="8" />
      <LineId Id="10327" Count="4" />
      <LineId Id="11404" Count="0" />
      <LineId Id="11403" Count="0" />
      <LineId Id="10333" Count="2" />
      <LineId Id="10337" Count="14" />
      <LineId Id="11406" Count="0" />
      <LineId Id="11408" Count="1" />
      <LineId Id="11407" Count="0" />
      <LineId Id="11413" Count="0" />
      <LineId Id="11405" Count="0" />
      <LineId Id="11416" Count="1" />
      <LineId Id="11415" Count="0" />
      <LineId Id="11418" Count="1" />
      <LineId Id="11414" Count="0" />
      <LineId Id="11421" Count="1" />
      <LineId Id="11420" Count="0" />
      <LineId Id="11440" Count="1" />
      <LineId Id="11443" Count="1" />
      <LineId Id="11446" Count="1" />
      <LineId Id="12964" Count="3" />
      <LineId Id="11445" Count="0" />
      <LineId Id="11430" Count="0" />
      <LineId Id="13611" Count="0" />
      <LineId Id="11424" Count="0" />
      <LineId Id="11431" Count="1" />
      <LineId Id="13612" Count="0" />
      <LineId Id="11423" Count="0" />
      <LineId Id="11433" Count="1" />
      <LineId Id="13613" Count="0" />
      <LineId Id="11425" Count="0" />
      <LineId Id="11427" Count="0" />
      <LineId Id="13285" Count="0" />
      <LineId Id="12613" Count="0" />
      <LineId Id="13286" Count="4" />
      <LineId Id="12614" Count="0" />
      <LineId Id="13292" Count="2" />
      <LineId Id="13291" Count="0" />
      <LineId Id="13295" Count="0" />
      <LineId Id="11428" Count="1" />
      <LineId Id="11426" Count="0" />
      <LineId Id="10352" Count="0" />
      <LineId Id="10314" Count="0" />
      <LineId Id="10304" Count="0" />
      <LineId Id="10284" Count="0" />
      <LineId Id="8033" Count="158" />
      <LineId Id="11027" Count="73" />
      <LineId Id="8192" Count="0" />
      <LineId Id="8206" Count="10" />
      <LineId Id="9424" Count="0" />
      <LineId Id="8217" Count="17" />
      <LineId Id="9329" Count="1" />
      <LineId Id="9333" Count="0" />
      <LineId Id="9337" Count="0" />
      <LineId Id="9360" Count="7" />
      <LineId Id="9370" Count="0" />
      <LineId Id="9373" Count="4" />
      <LineId Id="9398" Count="1" />
      <LineId Id="9378" Count="1" />
      <LineId Id="9396" Count="1" />
      <LineId Id="9380" Count="2" />
      <LineId Id="9400" Count="11" />
      <LineId Id="9383" Count="0" />
      <LineId Id="9385" Count="3" />
      <LineId Id="9412" Count="2" />
      <LineId Id="9389" Count="0" />
      <LineId Id="9391" Count="1" />
      <LineId Id="15241" Count="0" />
      <LineId Id="9393" Count="2" />
      <LineId Id="9332" Count="0" />
      <LineId Id="9331" Count="0" />
      <LineId Id="8235" Count="17" />
      <LineId Id="14574" Count="2" />
      <LineId Id="14590" Count="1" />
      <LineId Id="14593" Count="0" />
      <LineId Id="14589" Count="0" />
      <LineId Id="14577" Count="2" />
      <LineId Id="14595" Count="3" />
      <LineId Id="14594" Count="0" />
      <LineId Id="14580" Count="2" />
      <LineId Id="8276" Count="0" />
      <LineId Id="14583" Count="0" />
      <LineId Id="12546" Count="4" />
      <LineId Id="12553" Count="6" />
      <LineId Id="12564" Count="0" />
      <LineId Id="12566" Count="0" />
      <LineId Id="12503" Count="0" />
      <LineId Id="8277" Count="89" />
      <LineId Id="12502" Count="0" />
      <LineId Id="8367" Count="46" />
      <LineId Id="12501" Count="0" />
      <LineId Id="8414" Count="8" />
      <LineId Id="14257" Count="0" />
      <LineId Id="8423" Count="23" />
      <LineId Id="9036" Count="0" />
      <LineId Id="9038" Count="2" />
      <LineId Id="9037" Count="0" />
      <LineId Id="8447" Count="3" />
      <LineId Id="10705" Count="0" />
      <LineId Id="10709" Count="6" />
      <LineId Id="10706" Count="2" />
      <LineId Id="8460" Count="45" />
      <LineId Id="9047" Count="0" />
      <LineId Id="9041" Count="0" />
      <LineId Id="8508" Count="0" />
      <LineId Id="9043" Count="2" />
      <LineId Id="9048" Count="0" />
      <LineId Id="9046" Count="0" />
      <LineId Id="8509" Count="0" />
      <LineId Id="9050" Count="1" />
      <LineId Id="9049" Count="0" />
      <LineId Id="8510" Count="3" />
      <LineId Id="9042" Count="0" />
      <LineId Id="8514" Count="21" />
      <LineId Id="12598" Count="2" />
      <LineId Id="12615" Count="0" />
      <LineId Id="12601" Count="10" />
      <LineId Id="12597" Count="0" />
      <LineId Id="12612" Count="0" />
      <LineId Id="8536" Count="35" />
      <LineId Id="12596" Count="0" />
      <LineId Id="8573" Count="99" />
      <LineId Id="12500" Count="0" />
      <LineId Id="8673" Count="36" />
      <LineId Id="10716" Count="0" />
      <LineId Id="10718" Count="6" />
      <LineId Id="10717" Count="0" />
      <LineId Id="8719" Count="45" />
      <LineId Id="9052" Count="9" />
      <LineId Id="8768" Count="6" />
      <LineId Id="11757" Count="0" />
      <LineId Id="11839" Count="0" />
      <LineId Id="11860" Count="0" />
      <LineId Id="11862" Count="0" />
      <LineId Id="12624" Count="0" />
      <LineId Id="12638" Count="1" />
      <LineId Id="11864" Count="0" />
      <LineId Id="13929" Count="2" />
      <LineId Id="12637" Count="0" />
      <LineId Id="11865" Count="25" />
      <LineId Id="11861" Count="0" />
      <LineId Id="11910" Count="0" />
      <LineId Id="11912" Count="4" />
      <LineId Id="12619" Count="0" />
      <LineId Id="11917" Count="23" />
      <LineId Id="11891" Count="0" />
      <LineId Id="11911" Count="0" />
      <LineId Id="11893" Count="16" />
      <LineId Id="11892" Count="0" />
      <LineId Id="11941" Count="0" />
      <LineId Id="11943" Count="0" />
      <LineId Id="12628" Count="0" />
      <LineId Id="12640" Count="1" />
      <LineId Id="11945" Count="0" />
      <LineId Id="13933" Count="1" />
      <LineId Id="13932" Count="0" />
      <LineId Id="12642" Count="0" />
      <LineId Id="11946" Count="32" />
      <LineId Id="12618" Count="0" />
      <LineId Id="11979" Count="42" />
      <LineId Id="11942" Count="0" />
      <LineId Id="12022" Count="0" />
      <LineId Id="12024" Count="1" />
      <LineId Id="12643" Count="1" />
      <LineId Id="12026" Count="0" />
      <LineId Id="13936" Count="1" />
      <LineId Id="13935" Count="0" />
      <LineId Id="12645" Count="0" />
      <LineId Id="12027" Count="32" />
      <LineId Id="12617" Count="0" />
      <LineId Id="12060" Count="45" />
      <LineId Id="12635" Count="0" />
      <LineId Id="12646" Count="1" />
      <LineId Id="12107" Count="0" />
      <LineId Id="13939" Count="1" />
      <LineId Id="13938" Count="0" />
      <LineId Id="12648" Count="0" />
      <LineId Id="12108" Count="32" />
      <LineId Id="12616" Count="0" />
      <LineId Id="12141" Count="41" />
      <LineId Id="12499" Count="0" />
      <LineId Id="12183" Count="0" />
      <LineId Id="12023" Count="0" />
      <LineId Id="11756" Count="0" />
      <LineId Id="8776" Count="5" />
      <LineId Id="14920" Count="0" />
      <LineId Id="8782" Count="57" />
      <LineId Id="14599" Count="0" />
      <LineId Id="8840" Count="184" />
      <LineId Id="9" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>