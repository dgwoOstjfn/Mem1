<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.16">
  <POU Name="Mo20_St53_pnp_and_assembling_foil" Id="{44578566-c3b1-4f12-8277-56d9eb1d8109}" SpecialFunc="None">
    <Declaration><![CDATA[
FUNCTION_BLOCK Mo20_St53_pnp_and_assembling_foil
(*--------------------------------------------------------------------------------------
Preh IMA Automation Amberg GmbH

<DESC>
=INSERT DESCRIPTION FROM WORKFLOWPLAN=
</DESC>


<CHANGES>
At every change add date, version´s number, abbr. of name and describe change!

Date 		|	Version	|	Author	|	change description		
--------------------------------------------------------------------------------
2017-11-14	|	1.00	|	DWO		|	initial version

</CHANGES>
<VERSION>
1.00
</VERSION>

<DEPENDENCIES>
;
</DEPENDENCIES>



 -- overview of areas for steps --
Steps [000..099]: 	Whatever Block
Steps [100..199]:	Next Whatever Block

  
----------------------------------------------------------------------------------------*)



(* _____________________ *)
(* -- Standard-Inputs -- *)
VAR_INPUT
	OrderNr: 			INT :=E_TAB_MO_20_ST_53_2;		(* Nr. Actorder *)
	MoNr: 				INT:= 020;		(* Module-Number *)
	StNr: 				INT:= 51;		(* Stationsnumber *)
	BedienEinheit: 		ZENTR_DATA;		(* Central *)
	FaultID: 			BYTE := 0;		(* ID for Error Array *)
	DisplayNr: 			INT := 1;		(* Number of Textdisplay *)
	MPart: 				INT := 1;		(* Machinepart *)
	in_InitChainTxt:	STRING(39);		(* String for Step Chain Diagnosis *)
	in_sKebaKurz:		STRING(gcKebaStKurzLen) := '1234567890'; (* optional - can also be assigned in initialisation paragraph *)
	in_sKebaBez:		STRING(gcKebaStBezLen) 	:= '11111111112222222222333333333344444444445555555555'; (* optional - can also be assigned in initialisation paragraph *)
END_VAR


(* __________________ *)
(* -- RT-Interface -- *)
VAR_INPUT
	RtNr:				INT := 01;
	RtStNr:				SINT := 01;
	RtStartimpuls:		BOOL:=FALSE;	
END_VAR

VAR_IN_OUT
	//io_RtRegister:		ARRAY[1..6] OF ARRAY[1..4] OF DataTeil_pcb; // info for all parts within roundtable - the part for the station is accessed at [RtStNr]
	io_RtStarts:		DWORD; // bit array (dword) representing station is working on roundtable (flow based)
	io_RtFreigabe:		DWORD; // bit array (dword) representing station is giving permission for table to move (state based)
	io_RtFault:			DWORD; // bit array (dword) representing error at RtStNr of roundtable
	io_RtWaiting:		DWORD; // bit array (dword) representing waiting at RtStNr of roundtable
	io_RtWarning:		DWORD; // bit array (dword) representing warning at RtStNr of roundtable
END_VAR



(* ====== IF NO FEEDING STATION EXISTS PLEASE DELETE THIS PARAGRAPH AND ELEMINATE SUBSEQUENT ERRORS ====== *)
(* ____________________________ *)
(* -- Handshake with Foil Feeder -- *)
VAR_INPUT PERSISTENT
	in_bPartIsReadyToTakeOver		:BOOL:=FALSE;	(* handshake with pick and place *)
	in_bVisionSensorRuns	 		:BOOL:=FALSE;   (* handshake from vision sensor *)
END_VAR
VAR_OUTPUT PERSISTENT
	out_bEnablePrework				:BOOL:=FALSE;
	out_bPartIsTakeOver				:BOOL:=FALSE;	(* handshake from pick and place *)
	out_bPartIsTakeOver2				:BOOL:=FALSE;	(* handshake from pick and place *)
	out_bStartVisionSensor			:BOOL:=FALSE;	(* handshake with vision sensor *)
	out_byteVisionSensorJobNo		:BYTE;			(* Job 1 number for Vision sensor *)
END_VAR


VAR PERSISTENT
	SWI: 				BOOL := FALSE;	(* Impulse step is changing forward *)
	SWR:				BOOL := FALSE;	(* Impulse step is changing backwards *)
	Schritt: 			INT := 0;		(* Current step *)
	UZ: 				TON;			(* watchtime *)
	Fault: 				BOOL;			(* Stations Error *)
	Waiting:			BOOL;			(* Station Waiting *)
	Warning:			BOOL;			(* Station Warning *)
	Betrieb: 			BOOL;			(* Enable Steps *)
	StatEin: 			BOOL;			(* Station on *)
	AllInPos: 			BOOL;			(* all cylinders in position and not actuated manually *)
	Active:				BOOL;			(* stepchain is marked as active *)
	Transport:			BOOL;			(* manual transport is enabled *)
	InitRun:			BOOL;			(* goto homepos is enabled *)
	CycleRun:			BOOL;			(* mode for single cycle is enabled *)
	ManualRun:			BOOL;			(* move cylinders manually is enabled *)
	BackwardsRun:		BOOL;			(* backwards run is enabled *)
	tonSeitSwi:			TON;			(* time since last change of step *)
	tonSeitAllInPos:	TON;			(* time since AllInPos has become TRUE *)
	i:					INT;			(* index-runner for loops *)
	xx:					FB_StepTracker;	(* auto record steps *)
	StatString:			STRING(10);		(* '+MM=SS' *)
	StartCondition:		BOOL;			(* condition for starting station *)
	bStart:				BOOL;			(* station's work on roundtable is running *)
	NestNr:				INT;			(* number of nest within fixation *)
	
END_VAR

VAR CONSTANT
	NEST1					:INT:=1;
	NEST2					:INT:=2;
	NEST3					:INT:=3;
	NEST4					:INT:=4;
END_VAR

(* ___________________ *)
(* -- Error-Array 1 -- *)
VAR
	Errors1: ARRAY[1..ErrMaxBits] OF ERRDAT := [
	(* Error 01 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/01            '),
	(* Error 02 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/02            '),
	(* Error 03 *)		(Prio := ErrZyl, Nr:=2056, Txt:='=510-BX1'),
	(* Error 04 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/04            '),
	(* Error 05 *)		(Prio := ErrZyl, Nr:= 1903, Txt:='=St53 Vacuum 1'),
	(* Error 06 *)		(Prio := ErrZyl, Nr:= 1903, Txt:='=St53 Vacuum 2'),
	(* Error 07 *)		(Prio := ErrZyl, Nr:= 1903, Txt:='=St53 Vacuum 3'),
	(* Error 08 *)		(Prio := ErrZyl, Nr:= 1903, Txt:='=St53 Vacuum 4'),
	(* Error 09 *)		(Prio := ErrZyl, 	Nr:= 6502, Txt:='               '),
	(* Error 10 *)		(Prio := ErrZyl, 	Nr:= 6504, Txt:='               '),
	(* Error 11 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/11            '),
	(* Error 12 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/11            '),
	(* Error 13 *)		(Prio := ErrZyl, Nr:= 421, Txt:='=St53 BGx   '),
	(* Error 14 *)		(Prio := ErrMeld, Nr:= 2401, Txt:='=St53 BGx   '),
	(* Error 15 *)		(Prio := ErrMeld, Nr:= 2510, Txt:='=St53 P&P '), 
	(* Error 16 *)		(Prio := ErrMeld, Nr:= 2511, Txt:='=St53 P&P ')];
	f1: ARRAY [1..ErrMaxBits] OF BOOL := [ErrMaxBits(FALSE)];
	Fehler1: ERRORANZ;
END_VAR
VAR CONSTANT
	
	feVisionSensorBad		:INT:=3;
	feVacuum_1_Pressure		:INT:=5;
	feVacuum_2_Pressure		:INT:=6;
	feVacuum_3_Pressure		:INT:=7;
	feVacuum_4_Pressure		:INT:=8;
	
	feFoilEmptyCheck		:INT:=13;
	feFoilPresenceCheck		:INT:=14;
	feWaitOffering			:INT:=15;
	feWaitOfferEnd			:INT:=16;

	feLcCheckSNRStateFailed:				INT := 9;
	feLcGetRecipeFailed:					INT := 10;

END_VAR



(* _____________________ *)
(* -- Local Variables -- *)
VAR PERSISTENT
	BDE_bInsertEndless			:BOOL:=FALSE;
	
	(* == Cylinders == *)
	zyl0_pnp_Vacuum1			:zyl0; (* MM1 *)

	zyl0_pnp_Vacuum2			:zyl0; (* MM2 *)
	
	zyl0_pnp_Vacuum3			:zyl0; (* MM3 *)

	zyl0_pnp_Vacuum4			:zyl0; (* MM4 *)
	
	zyl2_vertical_stroke1		:zyl2; (* MM5 *)
	ix_vertical_stroke1A		:BOOL:=FALSE;
	ix_vertical_stroke1B		:BOOL:=FALSE;	
	
	zyl2_vertical_stroke2		:zyl2; (* MM6 *)
	ix_vertical_stroke2A		:BOOL:=FALSE;
	ix_vertical_stroke2B		:BOOL:=FALSE;
	
	zyl2_vertical_stroke3		:zyl2; (* MM7 *)
	ix_vertical_stroke3A		:BOOL:=FALSE;
	ix_vertical_stroke3B		:BOOL:=FALSE;
	
	zyl2_vertical_stroke4		:zyl2; (* MM8 *)	
	ix_vertical_stroke4A		:BOOL:=FALSE;
	ix_vertical_stroke4B		:BOOL:=FALSE;
	
	tonWaitPressON				:TON;
	tonVacuumOn					:TON;				
	(* ----- Sensor ------ *)
	ix_CheckFoilPresence		:BOOL:=FALSE;
	
	ix_CheckVacuum_1			:BOOL:=FALSE;
	ix_CheckVacuum_2			:BOOL:=FALSE;
	ix_CheckVacuum_3			:BOOL:=FALSE;
	ix_CheckVacuum_4			:BOOL:=FALSE;
	
	(* ----- P1-ST53-TA1 Horizontalhub ------ *)	
	ix_axX_P_Stop			:BOOL:=FALSE;
	ix_axX_N_Stop			:BOOL:=FALSE;
	ix_axX_Ready			:BOOL:=FALSE;
	ix_axX_STO_aktive		:BOOL:=FALSE;	
	axXID					:USINT:=8;
	
	ix_axX_ServoBereit		:BOOL:=FALSE;
	ix_axX_MotionComplete	:BOOL:=FALSE;
	qx_axX_ReglerFreigabe	:BOOL:=FALSE;
	qx_axX_EndstufeFreigabe	:BOOL:=FALSE;
	
	(* position *)
	lraxXSpeedPositioning	:LREAL:=0.0;
	lraxXHomePosition		:LREAL:=0.0;
	lraxXPickPosition1		:LREAL:=0.0;
	lraxXPickPosition2		:LREAL:=0.0;
	lraxXPickPosition3		:LREAL:=0.0;
	lraxXPickPosition4		:LREAL:=0.0;
	lraxXInsertPosition		:LREAL:=0.0;
	
	SchrittaxJumpBack		:INT:=0;
	_baxJumpBackDemanded	:BOOL:=FALSE;		//requirment for JumpBack
	_bStepBackAllowed		:BOOL:=FALSE;
	_bMoveAxisAllowed		:BOOL:=FALSE;
	_bArea1ToMoveAllowed	:BOOL:=FALSE;
	_bArea2ToMoveAllowed	:BOOL:=FALSE;
	_bArea3ToMoveAllowed	:BOOL:=FALSE;
	_bArea4ToMoveAllowed	:BOOL:=FALSE;
	_bArea5ToMoveAllowed	:BOOL:=FALSE;
	
	(* ST53-BX1 Sensopart V20-OB-A2-R12 *)	
	ixVisionSensorReady				:BOOL:= FALSE;	(* hardware ready *)
	
	BDE_bVisionSensorOn				:BOOL := FALSE;	(* station runs with Vision sensor *)
	BDE_byteVisionSensorJobNo		:BYTE;			(* Job 1 number for Vision sensor *)
	
END_VAR

VAR CONSTANT
	//IP_VisionSensor_BX1				:T_IPv4Addr	:= '192.168.10.101';	(* vision sensor Sensopart *)
END_VAR


(* _____________________ *)
(* -- Function Blocks -- *)
VAR
	tonVacuumTimeOut			:TON;

	awFoilSuckIn1				:AWFEHLER;		//X-Times Error
	awFoilSuckIn2				:AWFEHLER;		//X-Times Error
	awFoilSuckIn3				:AWFEHLER;		//X-Times Error
	awFoilSuckIn4				:AWFEHLER;		//X-Times Error
	(* Festo Servoachse *)
	axX						:FB_Achse_mit_Keba;	
	(* Vision Sensor *)
	fbVisionSensor			:FB_CamSensopartV10;
	
	
	tonVertical1			:TON;
	tonVertical2			:TON;
	tonVertical3			:TON;
	tonVertical4			:TON;
	
END_VAR

(* ____________________ *)
(* -- LineController -- *)
VAR
	LC_Cavity1					:FB_LcStationCommandHandler;
	LC_Cavity2					:FB_LcStationCommandHandler;
	LC_Cavity3					:FB_LcStationCommandHandler;
	LC_Cavity4					:FB_LcStationCommandHandler;
	TypeNo						:STRING(40);
	SerialNo					:STRING(14);
	DataIndex					:UDINT := 1;

END_VAR

VAR PERSISTENT
	OutUserData					:ARRAY[1..100] OF BYTE;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(* ____________________ *)
(* -- Initialisation -- *)
IF neustart OR g_bOnlineChange THEN
	StatString 		:= RIGHT(CONCAT( '000',INT_TO_STRING(StNr) ),3); (* three digits station's prefix is being created automatically for station *)
	in_InitChainTxt := CONCAT( StatString, ' Assembly Foil' );
	in_sKebaKurz	:= CONCAT( StatString, ' Assembly'); // 3+7 digits
	in_sKebaBez		:= in_InitChainTxt;
END_IF


KebaInitStation(
	Panelnummer		:= gKebaAktPanel,
	Aktiv			:= TRUE,
	Kurzbezeichnung	:= in_sKebaKurz,
	Bezeichnung		:= in_sKebaBez,
	ManuellAktiv	:= TRUE,
	RueckwaertsAktiv:= FALSE,
	GsAktiv			:= FALSE,
);


(* ________________________ *)
(* == Drive Dimensioning == *)

(* -- Data X-Axis ==20=053TA2 --
     MOTOR                                 EMMS-AS-55-M-LS-TM
           Max Rotary Speed                6600 1/min
           Nominal Current                 1,19 A(rms)
           Nominal Voltage                 360 VDC
 
     GEARING                               - 
           Transmission                    -
           max input rotary speed          -
           max output torque               -
     
     GUIDANCE RAIL / AXIS                  EGC- 80- 450-BS-10P-KF-0H-ML-GK
           Feed Constant                   10	mm/rev.
           Max Torque                      0,75	Nm    
           Max Speed                       3000	mm/s
           Max Acceleration                15 	m/s²
           Max Masse                       / 	kg	PBAIBN
           Max Force             (Fmax)    600 	N
 
PBAIBN
     JUDGEMENT / DIMENSIONING
           Overall Mass to Move  (M)       2 kg (approximately)
 
           Way/Revolution                  12 mm/rev.
           v_max @ 6000 UPM (v_max)        1200 mm/s
 
 
           Increments / Revolution         2^20 = 1048576 (at fieldbus)
           => scaling factor               0.000011444091796875 mm/inc.

            Maximum Acceleration
                a_max = Fmax / M           50 N / 2 kg   -> 25 m/s²
 
           Emergency-Stop-Ramp
                t_min = v_max / a_max      1200 mm/s / 25 m/s² =   48 ms
     
           => Emergency stop ramp not allowed to be shorter than
              				    48 ms


		LIMITS FOR MOTOR PARAMETERS TO PROTECT GUIDANCE RAIL 
			M_max (Rail) = (50N * 0.012m) / (2 * pi) = 0.095Nm
			I_max (Rail) = 0.095 Nm / 0.21Nm/A = 0,45A 
			due to field loss + friction ... I_max was limited to 1.2A at DriveGUI
*)


(* _______________________________________ *)
(* -- Entry for Step Sequence Diagnosis -- *)
InitChain(
	Step 			:= Schritt,
	InitialState 	:= TRUE,
	Fault 			:= Fault,
	Waiting 		:= Waiting,
	Warning 		:= Warning,
	AllInPos 		:= AllInPos,
	RunOpenDoor 	:= TRUE,
	Txt 			:= in_InitChainTxt,
	BedienEinheit 	:= BedienEinheit,
	Active 			:= Active,
	Transport 		:= Transport,
	InitRun 		:= InitRun,
	CycleRun 		:= CycleRun,
	ManualRun 		:= ManualRun,
	BackwardsRun 	:= BackwardsRun);
InitRun := FALSE;


(* _______________ *)
(* -- Parameter -- *)
StatEin 					:= ActOrd[MPart].ord_stat[E_TAB_MO_20_ST_53_1].sd_ein;
BDE_bVisionSensorOn			:= ActOrd[MPart].ord_stat[OrderNr].sd_z1;
BDE_bInsertEndless			:= ActOrd[MPart].ord_stat[OrderNr].sd_z2 AND Main.M20.RT_100.ixTischInPosition;


(* ____________ *)
(* -- Inputs -- *)
(*Axis Festo Input*)
ix_axX_P_Stop			:=_053_M20_MP1_BG1_P;
ix_axX_N_Stop			:=_053_M20_MP1_BG1_N;
ix_axX_Ready			:=_053_M20_P1_TA1_X1_24;
ix_axX_MotionComplete	:=_053_M20_P1_TA1_X1_12;
ix_axX_STO_aktive		:=_053_M20_P1_TA1_X40;

(*Cylinder Input*)
ix_vertical_stroke1A	:=_053_M20_MP1_BG5_A;
ix_vertical_stroke1B	:=_053_M20_MP1_BG5_B;

ix_vertical_stroke2A	:=_053_M20_MP1_BG6_A;
ix_vertical_stroke2B	:=_053_M20_MP1_BG6_B;

ix_vertical_stroke3A	:=_053_M20_MP1_BG7_A;
ix_vertical_stroke3B	:=_053_M20_MP1_BG7_B;

ix_vertical_stroke4A	:=_053_M20_MP1_BG8_A;
ix_vertical_stroke4B	:=_053_M20_MP1_BG8_B;

ix_CheckVacuum_1		:=_053_M20_MP1_QM1_BP1_4;
ix_CheckVacuum_2		:=_053_M20_MP1_QM2_BP1_4;
ix_CheckVacuum_3		:=_053_M20_MP1_QM3_BP1_4;
ix_CheckVacuum_4		:=_053_M20_MP1_QM4_BP1_4;

ix_CheckFoilPresence	:= _053_M20_MP1_BG1;


(* _______________________ *)
(* -- Timer / Watchdogs -- *)
UZ( IN:= NOT SWI AND BedienEinheit.grundbed, PT:= T#5S );
tonSeitSwi( IN := NOT SWI AND Bedieneinheit.grundbed, PT := t#30d );
tonSeitAllInPos( IN := AllInPos AND Bedieneinheit.grundbed, PT := T#30D );

tonWaitPressON( IN:= ((schritt=430) AND BedienEinheit.grundbed), PT:= T#100MS );			//FZH   change from 1s to 100ms 
tonVacuumOn( IN:= (NOT SWI AND BedienEinheit.grundbed), PT:= T#1S );

tonVertical1( IN:= (Schritt = 30), PT:= T#0.5S );
tonVertical2( IN:= (Schritt = 130), PT:= T#0.5S );
tonVertical3( IN:= (Schritt = 230), PT:= T#0.5S );
tonVertical4( IN:= (Schritt = 330), PT:= T#0.5S );


(* _______________ *)
(* -- Cylinders -- *)
zyl0_pnp_Vacuum1(
	enable_man	:= BedienEinheit.notaus_ok, 
	FNrMan		:= 699, 
	on_vz		:= T#100MS, 
	off_vz		:= T#100MS, 
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '1',
	ID			:= FaultId,
	Bild		:= picKnebelschalterOff,   			
	BildB		:= picKnebelschalterOn,	
 );
 
 zyl0_pnp_Vacuum2(
	enable_man	:= BedienEinheit.notaus_ok, 
	FNrMan		:= 699, 
	on_vz		:= T#100MS, 
	off_vz		:= T#100MS, 
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '2',
	ID			:= FaultId,
	Bild		:= picKnebelschalterOff,   			
	BildB		:= picKnebelschalterOn,	
 );
 
 zyl0_pnp_Vacuum3(
	enable_man	:= BedienEinheit.notaus_ok, 
	FNrMan		:= 699, 
	on_vz		:= T#100MS, 
	off_vz		:= T#100MS, 
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '3',
	ID			:= FaultId,
	Bild		:= picKnebelschalterOff,   			
	BildB		:= picKnebelschalterOn,	
 );
 
 zyl0_pnp_Vacuum4(
	enable_man	:= BedienEinheit.notaus_ok, 
	FNrMan		:= 699, 
	on_vz		:= T#100MS, 
	off_vz		:= T#100MS, 
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '4',
	ID			:= FaultId,
	Bild		:= picKnebelschalterOff,   			
	BildB		:= picKnebelschalterOn,	
 );

 zyl2_vertical_stroke1(
	grundbed	:= Bedieneinheit.grundbed,
	a			:= ix_vertical_stroke1A,
	b			:= ix_vertical_stroke1B,
	enable_man	:= Bedieneinheit.ventile_ok,
	FNr			:= 211,
	FNrMan		:= 611,
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '5',
	ID			:= FaultId,
);

 zyl2_vertical_stroke2(
	grundbed	:= Bedieneinheit.grundbed,
	a			:= ix_vertical_stroke2A,
	b			:= ix_vertical_stroke2B,
	enable_man	:= Bedieneinheit.ventile_ok,
	FNr			:= 211,
	FNrMan		:= 611,
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '6',
	ID			:= FaultId,
);

 zyl2_vertical_stroke3(
	grundbed	:= Bedieneinheit.grundbed,
	a			:= ix_vertical_stroke3A,
	b			:= ix_vertical_stroke3B,
	enable_man	:= Bedieneinheit.ventile_ok,
	FNr			:= 211,
	FNrMan		:= 611,
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '7',
	ID			:= FaultId,
);

 zyl2_vertical_stroke4(
	grundbed	:= Bedieneinheit.grundbed,
	a			:= ix_vertical_stroke4A,
	b			:= ix_vertical_stroke4B,
	enable_man	:= Bedieneinheit.ventile_ok,
	FNr			:= 211,
	FNrMan		:= 611,
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '8',
	ID			:= FaultId,
);

AllInPos 		:=	zyl0_pnp_Vacuum1.pos
				AND zyl0_pnp_Vacuum2.pos
				AND zyl0_pnp_Vacuum3.pos
				AND zyl0_pnp_Vacuum4.pos
				AND zyl2_vertical_stroke1.pos
				AND zyl2_vertical_stroke2.pos
				AND zyl2_vertical_stroke3.pos
				AND zyl2_vertical_stroke4.pos;

(* __________________ *)
(* -- Treat Errors -- *)
Fehler1( ID:= FaultID, FAnz:= DisplayNr, EF:= Errors1, F:= f1 );

Fault			:=	zyl0_pnp_Vacuum1.err				(* Error´s of function blocks *)
				OR  zyl0_pnp_Vacuum2.err
				OR 	zyl0_pnp_Vacuum3.err
				OR  zyl0_pnp_Vacuum4.err
				OR  zyl2_vertical_stroke1.err
				OR  zyl2_vertical_stroke2.err
				OR  zyl2_vertical_stroke3.err
				OR  zyl2_vertical_stroke4.err
				OR	axX.out_bFault
				OR  fbVisionSensor.Fault;
				
Warning := fbVisionSensor.Warning;
Waiting := axX.out_bWaiting
		OR fbVisionSensor.Waiting;
		
FOR i := 1 TO ErrMaxBits BY 1 DO
	IF f1[i] THEN
		IF 		Errors1[i].Prio <= ErrZyl 			THEN Fault := TRUE;
		ELSIF	Errors1[i].Prio <= ErrEndl 			THEN Waiting := TRUE; f1[i] := FALSE;
		ELSIF	Errors1[i].Prio <= ErrWechselpos	THEN Warning := TRUE; f1[i] := FALSE; END_IF
	END_IF
END_FOR


// report Error, Waiting and Warning to cell
IF Fault 	THEN io_RtFault 	:= SETBIT32( io_RtFault,   RtStNr ); END_IF
IF Waiting 	THEN io_RtWaiting 	:= SETBIT32( io_RtWaiting, RtStNr ); END_IF
IF Warning	THEN io_RtWarning	:= SETBIT32( io_RtWarning, RtStNr ); END_IF


(* Create Errrors / Misc. Errors *)


(* _____________________ *)
(* -- Line Controller -- *)
LC_Cavity1.in_Data.OutUserData := ADR(OutUserData);
LC_Cavity1.in_Data.OutUserData_BufferSize := SIZEOF(OutUserData);
LC_Cavity1(
		MoNr				:= MoNr, 
		StNr				:= StNr, 
		FaultID				:= FaultID, 
		DisplayNr			:= DisplayNr, 
		in_strBMK			:= 'LC', 
		in_bConnect			:= BedienEinheit.notaus_ok, 
		in_bEnableLog		:= TRUE, 
		in_sRemoteHost		:= IP_LineController, 
		in_uiRemotePort		:= 20531,//INT_TO_UINT(MoNr * 10000 + StNr + Nest1),
		in_uiStationID		:= 253,
		in_uiStationSubID	:= 1, 
		in_bTelegram64kB	:= FALSE, 
		in_bTypbeschrUebertr:= FALSE
);

LC_Cavity2.in_Data.OutUserData := ADR(OutUserData);
LC_Cavity2.in_Data.OutUserData_BufferSize := SIZEOF(OutUserData);

LC_Cavity2(
		MoNr				:= MoNr, 
		StNr				:= StNr, 
		FaultID				:= FaultID, 
		DisplayNr			:= DisplayNr, 
		in_strBMK			:= 'LC', 
		in_bConnect			:= BedienEinheit.notaus_ok, 
		in_bEnableLog		:= TRUE, 
		in_sRemoteHost		:= IP_LineController, 
		in_uiRemotePort		:= 20532,//INT_TO_UINT(MoNr * 10000 + StNr + Nest2),
		in_uiStationID		:= 253,
		in_uiStationSubID	:= 2, 
		in_bTelegram64kB	:= FALSE, 
		in_bTypbeschrUebertr:= FALSE
);

LC_Cavity3.in_Data.OutUserData := ADR(OutUserData);
LC_Cavity3.in_Data.OutUserData_BufferSize := SIZEOF(OutUserData);
LC_Cavity3(
		MoNr				:= MoNr, 
		StNr				:= StNr, 
		FaultID				:= FaultID, 
		DisplayNr			:= DisplayNr, 
		in_strBMK			:= 'LC', 
		in_bConnect			:= BedienEinheit.notaus_ok, 
		in_bEnableLog		:= TRUE, 
		in_sRemoteHost		:= IP_LineController, 
		in_uiRemotePort		:= 20533,//INT_TO_UINT(MoNr * 10000 + StNr + Nest1),
		in_uiStationID		:= 253,
		in_uiStationSubID	:= 3, 
		in_bTelegram64kB	:= FALSE, 
		in_bTypbeschrUebertr:= FALSE
);

LC_Cavity4.in_Data.OutUserData := ADR(OutUserData);
LC_Cavity4.in_Data.OutUserData_BufferSize := SIZEOF(OutUserData);

LC_Cavity4(
		MoNr				:= MoNr, 
		StNr				:= StNr, 
		FaultID				:= FaultID, 
		DisplayNr			:= DisplayNr, 
		in_strBMK			:= 'LC', 
		in_bConnect			:= BedienEinheit.notaus_ok, 
		in_bEnableLog		:= TRUE, 
		in_sRemoteHost		:= IP_LineController, 
		in_uiRemotePort		:= 20534,//INT_TO_UINT(MoNr * 10000 + StNr + Nest2),
		in_uiStationID		:= 253,
		in_uiStationSubID	:= 4, 
		in_bTelegram64kB	:= FALSE, 
		in_bTypbeschrUebertr:= FALSE
);

(* __________________________________ *)
(* -- Station - Allowed to Operate -- *)
Betrieb := 	Bedieneinheit.betrieb
		AND NOT Fault
		AND NOT ManualRun
		AND BedienEinheit.ventile_ok;

(*		
arrCarrierData[RtNr][RtStNr][Nest1].PartDataPcb.teilestatus:=srgood;					(*FZHCOM*)
arrCarrierData[RtNr][RtStNr][Nest2].PartDataPcb.teilestatus:=srgood;					(*FZHCOM*)
arrCarrierData[RtNr][RtStNr][Nest3].PartDataPcb.teilestatus:=srgood;					(*FZHCOM*)
arrCarrierData[RtNr][RtStNr][Nest4].PartDataPcb.teilestatus:=srgood;					(*FZHCOM*)
*)		
(* ____________________ *)
(* -- Start Station  -- *)
IF 	RtStartimpuls THEN
	StartCondition 
		:= 	StatEin
		AND	arrCarrierData[RtNr][RtStNr][Nest1].PartDataPcb.teilestatus > srEmpty
		AND	arrCarrierData[RtNr][RtStNr][Nest2].PartDataPcb.teilestatus > srEmpty
		AND	arrCarrierData[RtNr][RtStNr][Nest3].PartDataPcb.teilestatus > srEmpty
		AND	arrCarrierData[RtNr][RtStNr][Nest4].PartDataPcb.teilestatus > srEmpty;
					
	IF StartCondition THEN bStart := TRUE; END_IF
END_IF

(* ________________ *)
(* -- Parameter for Axis -- *)
lraxXSpeedPositioning	:=90.0;
lraxXHomePosition		:=-2.4;
lraxXPickPosition1		:= DINT_TO_LREAL(ActOrd[MPart].ord_stat[E_TAB_MO_20_ST_53_2].sd_p5)/100;
lraxXPickPosition2		:= DINT_TO_LREAL(ActOrd[MPart].ord_stat[E_TAB_MO_20_ST_53_2].sd_p6)/100;
lraxXPickPosition3		:= DINT_TO_LREAL(ActOrd[MPart].ord_stat[E_TAB_MO_20_ST_53_2].sd_p7)/100;
lraxXPickPosition4		:= DINT_TO_LREAL(ActOrd[MPart].ord_stat[E_TAB_MO_20_ST_53_2].sd_p8)/100;
lraxXInsertPosition		:= DINT_TO_LREAL(ActOrd[MPart].ord_stat[E_TAB_MO_20_ST_53_2].sd_p4)/100;
(* Value Record by commisioning
lraxXPickPosition1		:=-2.4;
lraxXPickPosition2		:=37.7;
lraxXPickPosition3		:=77.7;
lraxXPickPosition4		:=117.7;
lraxXInsertPosition		:=346.45;  (*DWOCOM confirm 03/22/2018*)
*)

(* ________________ *)
(* -- Step-Chain -- *)
xx( iStep := Schritt );
out_bEnablePrework		 	:= NOT Bedieneinheit.mpart[Mpart].hm_leer;	
out_bPartIsTakeOver			:= FALSE;	
out_bStartVisionSensor		:= FALSE;

(* reset flags *)
SWI := FALSE;
out_bPartIsTakeOver2 := FALSE;
CASE Schritt OF
0:	xx.x := 'in basepos. - wait for prework or station´s start';
	IF  AllInPos
	AND bStart
	AND BedienEinheit.anl_ein
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		//Schritt := Schritt + 110;			//DWOCOM test for single cyl.
		Schritt := Schritt + 10;  
		SWI := TRUE;
	END_IF

02: xx.x := 'CheckSerialnumberState (OP15) in LineController';	
	IF arrCarrierData[RtNr][RtStNr][Nest1].PartDatapcb.teilestatus = srempty or arrCarrierData[RtNr][RtStNr][Nest1].PartDatapcb.teilestatus = srbad THEN
		Schritt := Schritt + 1;
		SWI := TRUE; 
	ELSE
	LC_Cavity1.checkSNRState(arrCarrierData[RtNr][RtStNr][NEST1].PartDataPcb.strTypeNr,arrCarrierData[RtNr][RtStNr][NEST1].PartDataPcb.strTeileId,0);
	IF LC_Cavity1.comcheckSNRState.bDone THEN
		IF LC_Cavity1.comcheckSNRState.bValid 
		THEN
				Schritt := Schritt+1;
				SWI := TRUE;
		ELSIF LC_Cavity1.out_Data.ACK_Numer = 10 THEN
				Schritt := Schritt+1;
				SWI := TRUE;
		ELSE // Error from LineController
			f1[feLcCheckSNRStateFailed] := TRUE;
			IF NOT f1[feLcCheckSNRStateFailed] THEN
				arrCarrierData[RtNr][RtStNr][NEST1].PartDataPcb.teilestatus:=srBad;
				Schritt := Schritt+1;
				SWI := TRUE;
			END_IF
		END_IF
	END_IF	
	END_IF	
	

03: xx.x := 'CheckSerialnumberState (OP15) in LineController';
	IF arrCarrierData[RtNr][RtStNr][Nest2].PartDatapcb.teilestatus = srempty OR arrCarrierData[RtNr][RtStNr][Nest2].PartDatapcb.teilestatus = srbad THEN
		Schritt := Schritt + 1;
		SWI := TRUE; 
	ELSE
	LC_Cavity2.checkSNRState(arrCarrierData[RtNr][RtStNr][NEST2].PartDataPcb.strTypeNr,arrCarrierData[RtNr][RtStNr][NEST2].PartDataPcb.strTeileId,0);
	IF LC_Cavity2.comcheckSNRState.bDone THEN
		IF LC_Cavity2.comcheckSNRState.bValid 
		THEN
				Schritt := Schritt+1;
				SWI := TRUE;
	    ELSIF LC_Cavity2.out_Data.ACK_Numer = 10 THEN
				Schritt := Schritt+1;
				SWI := TRUE;
		ELSE // Error from LineController
			f1[feLcCheckSNRStateFailed] := TRUE;
			IF NOT f1[feLcCheckSNRStateFailed] THEN
				arrCarrierData[RtNr][RtStNr][NEST2].PartDataPcb.teilestatus:=srBad;
				Schritt := Schritt+1;
				SWI := TRUE;
			END_IF
		END_IF
	END_IF	
	END_IF	
	

04: xx.x := 'CheckSerialnumberState (OP15) in LineController';
	IF arrCarrierData[RtNr][RtStNr][Nest3].PartDatapcb.teilestatus = srempty OR arrCarrierData[RtNr][RtStNr][Nest3].PartDatapcb.teilestatus = srbad THEN
		Schritt := Schritt + 1;
		SWI := TRUE; 
	ELSE
	LC_Cavity3.checkSNRState(arrCarrierData[RtNr][RtStNr][NEST3].PartDataPcb.strTypeNr,arrCarrierData[RtNr][RtStNr][NEST3].PartDataPcb.strTeileId,0);
	IF LC_Cavity3.comcheckSNRState.bDone THEN
		IF LC_Cavity3.comcheckSNRState.bValid 
		THEN
				Schritt := Schritt+1;
				SWI := TRUE;
		ELSIF LC_Cavity3.out_Data.ACK_Numer = 10 THEN
				Schritt := Schritt+1;
				SWI := TRUE;
		ELSE // Error from LineController
			f1[feLcCheckSNRStateFailed] := TRUE;
			IF NOT f1[feLcCheckSNRStateFailed] THEN
				arrCarrierData[RtNr][RtStNr][NEST3].PartDataPcb.teilestatus:=srBad;
				Schritt := Schritt+1;
				SWI := TRUE;
			END_IF
		END_IF
	END_IF		

	END_IF	
	
05: xx.x := 'CheckSerialnumberState (OP15) in LineController';
	IF arrCarrierData[RtNr][RtStNr][Nest4].PartDatapcb.teilestatus = srempty OR arrCarrierData[RtNr][RtStNr][Nest4].PartDatapcb.teilestatus = srbad THEN
		Schritt := Schritt + 1;
		SWI := TRUE; 
	ELSE
	LC_Cavity4.checkSNRState(arrCarrierData[RtNr][RtStNr][NEST4].PartDataPcb.strTypeNr,arrCarrierData[RtNr][RtStNr][NEST4].PartDataPcb.strTeileId,0);
	IF LC_Cavity4.comcheckSNRState.bDone THEN
		IF LC_Cavity4.comcheckSNRState.bValid 
		THEN
				Schritt := Schritt+5;
				SWI := TRUE;
		ELSIF LC_Cavity4.out_Data.ACK_Numer = 10 THEN
				Schritt := Schritt+1;
				SWI := TRUE;
		ELSE // Error from LineController
			f1[feLcCheckSNRStateFailed] := TRUE;
			IF NOT f1[feLcCheckSNRStateFailed] THEN
				arrCarrierData[RtNr][RtStNr][NEST4].PartDataPcb.teilestatus:=srBad;
				Schritt := Schritt+5;
				SWI := TRUE;
			END_IF
		END_IF
	END_IF		
	END_IF	
	
	
10:	xx.x := 'ML1 Elek. Cross Stroke -> return step';
	schrittAxJumpBack		:=schritt;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bBereitFuerPos
	THEN		
		axX.in_lrPosSoll		:= lraxXPickPosition1;
		axX.in_bStartPosAbsolute:=TRUE;
		(*ML1 drives to pick position 1 by jumpback process*)
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF		
		
20:	xx.x := 'ML1 Elek. Cross Stroke -> Pick-Up Position 1';
	axX.in_lrPosSoll		:= lraxXPickPosition1;
	axX.in_bStartPosAbsolute:=TRUE;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bMoveAbsoluteDone
	THEN
		IF arrCarrierData[RtNr][RtStNr][Nest1].PartDataPcb.teilestatus>=srbad THEN 
			_bStepBackAllowed	:=FALSE;
			Schritt := Schritt + 10;
			SWI := TRUE;
		ELSE
			Schritt := 110;
			SWI := TRUE;
		END_IF
	END_IF		

30:	xx.x := 'waiting for Foil Offering'; 
	IF 	AllInPos
	AND Betrieb 
    AND tonVertical1.Q 
	AND in_bPartIsReadyToTakeOver THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 10;			
		SWI := TRUE;	
	END_IF	
	
40:	xx.x := 'MM5 Vertical 1 -> ON (downwards to pick-up position)';
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF	
	
45:	xx.x := 'MM1 Vacuum 1 -> ON (Foil suck)';
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF	

50:	xx.x := 'waiting for Vacuum Pressure Checking';			//the foil shounld be holded by the vacuum in 1sec(uz.q) after vertical cyl. arriving pick-up position
	IF AllInPos
	AND Betrieb
	THEN
		IF ix_CheckVacuum_1 OR UZ.Q THEN
			(* -> start transport control *)
			(* -> wait for transport is ready *)
			out_bPartIsTakeOver := TRUE;
			Schritt := Schritt + 5;
			SWI := TRUE;
		END_IF 
	END_IF

55:	xx.x := 'wait for transport is ready';
	IF NOT in_bPartIsReadyToTakeOver
	THEN
		(* -> MM5 Vertical -> OFF (base pos.) *)
		out_bPartIsTakeOver := TRUE;
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF	
	
60:	xx.x := 'MM5 Vertical 1 -> OFF (upwards to home position)';
	IF 	AllInPos
	AND Betrieb  THEN
		out_bPartIsTakeOver2 := TRUE;
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 50;
		//Schritt := 400;				//DWOCOM single test
		SWI := TRUE;
	END_IF	

(*70:	xx.x := 'waiting for Foil Presence Checking';								//function test, presence controll
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		IF ix_CheckFoilPresence AND ix_CheckVacuum_1  THEN 						
			f1[feFoilEmptyCheck] :=TRUE;
		END_IF
		IF  NOT f1[feFoilEmptyCheck] THEN										//fehler reset by reset button,whatever the foil presence or not
			Schritt := Schritt + 40;
			SWI := TRUE;
		END_IF		
	END_IF
*)

110:	xx.x := 'ML1 Elek. Cross Stroke -> return step';
	schrittAxJumpBack		:=schritt;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bBereitFuerPos
	THEN		
		axX.in_lrPosSoll		:= lraxXPickPosition2;
		axX.in_bStartPosAbsolute:=TRUE;
		(*ML1 drives to pick position 2 by jumpback process*)
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF		
		
120:	xx.x := 'ML1 Elek. Cross Stroke -> Pick-Up Position 2';
	axX.in_lrPosSoll		:= lraxXPickPosition2;
	axX.in_bStartPosAbsolute:=TRUE;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bMoveAbsoluteDone
	THEN
		IF arrCarrierData[RtNr][RtStNr][Nest2].PartDataPcb.teilestatus>=srbad THEN 
			_bStepBackAllowed	:=FALSE;
			Schritt := Schritt + 10;
			SWI := TRUE;
		ELSE
			Schritt := 210;
			SWI := TRUE;
		END_IF
	END_IF		

130:	xx.x := 'waiting for Foil Offering'; 
	IF 	AllInPos
	AND Betrieb 
    AND tonVertical2.Q 
	AND in_bPartIsReadyToTakeOver THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 10;			
		SWI := TRUE;	
	END_IF	
	
140:	xx.x := 'MM6 Vertical 2 -> ON (downwards to pick-up position)';
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF	
	
145:	xx.x := 'MM2 Vacuum 2 -> ON (Foil suck)';
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF	

150:	xx.x := 'waiting for Vacuum Pressure Checking';			//the foil shounld be holded by the vacuum in 1sec(uz.q) after vertical cyl. arriving pick-up position
	IF AllInPos
	AND Betrieb
	THEN
		IF ix_CheckVacuum_2 OR UZ.Q THEN
			(* -> start transport control *)
			(* -> wait for transport is ready *)
			out_bPartIsTakeOver := TRUE;
			Schritt := Schritt + 5;
			SWI := TRUE;
		END_IF 
	END_IF

155:	xx.x := 'wait for transport is ready';
	IF NOT in_bPartIsReadyToTakeOver
	THEN
		(* -> MM5 Vertical -> OFF (base pos.) *)
		out_bPartIsTakeOver := TRUE;
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF	
	
160:	xx.x := 'MM6 Vertical 2 -> OFF (upwards to home position)';
	IF 	AllInPos
	AND Betrieb  THEN
		out_bPartIsTakeOver2 := TRUE;
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 50;
		//Schritt :=400;
		SWI := TRUE;
	END_IF	

(*170:	xx.x := 'waiting for Foil Presence Checking';								//function test, presence controll
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		IF ix_CheckFoilPresence AND ix_CheckVacuum_2  THEN 						
			f1[feFoilEmptyCheck] :=TRUE;
		END_IF
		IF  NOT f1[feFoilEmptyCheck] THEN										//fehler reset by reset button,whatever the foil presence or not
			Schritt := Schritt + 40;
			SWI := TRUE;
		END_IF		
	END_IF
*)

210:	xx.x := 'ML1 Elek. Cross Stroke -> return step';
	schrittAxJumpBack		:=schritt;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bBereitFuerPos
	THEN		
		axX.in_lrPosSoll		:= lraxXPickPosition3;
		axX.in_bStartPosAbsolute:=TRUE;
		(*ML1 drives to pick position 3 by jumpback process*)
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF		
		
220:	xx.x := 'ML1 Elek. Cross Stroke -> Pick-Up Position 3';
	axX.in_lrPosSoll		:= lraxXPickPosition3;
	axX.in_bStartPosAbsolute:=TRUE;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bMoveAbsoluteDone
	THEN
		IF arrCarrierData[RtNr][RtStNr][Nest3].PartDataPcb.teilestatus>=srbad THEN 
			_bStepBackAllowed	:=FALSE;
			Schritt := Schritt + 10;
			SWI := TRUE;
		ELSE
			Schritt := 310;
			SWI := TRUE;
		END_IF
	END_IF		

230:	xx.x := 'waiting for Foil Offering'; 
	IF 	AllInPos
	AND Betrieb  
    AND tonVertical3.Q
	AND in_bPartIsReadyToTakeOver THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 10;			
		SWI := TRUE;	
	END_IF	
	
240:	xx.x := 'MM7 Vertical 3 -> ON (downwards to pick-up position)';
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF	
	
245:	xx.x := 'MM3 Vacuum 3 -> ON (Foil suck)';
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF	

250:	xx.x := 'waiting for Vacuum Pressure Checking';			//the foil shounld be holded by the vacuum in 1sec(uz.q) after vertical cyl. arriving pick-up position
	IF AllInPos
	AND Betrieb
	THEN
		IF ix_CheckVacuum_3 OR UZ.Q THEN
			(* -> start transport control *)
			(* -> wait for transport is ready *)
			out_bPartIsTakeOver := TRUE;
			Schritt := Schritt + 5;
			SWI := TRUE;
		END_IF 
	END_IF

255:	xx.x := 'wait for transport is ready';
	IF NOT in_bPartIsReadyToTakeOver
	THEN
		(* -> MM7 Vertical -> OFF (base pos.) *)
		out_bPartIsTakeOver := TRUE;
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF	
	
260:	xx.x := 'MM7 Vertical 3 -> OFF (upwards to home position)';
	IF 	AllInPos
	AND Betrieb  THEN
		out_bPartIsTakeOver2 := TRUE;
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 50;
		//Schritt := 400;
		SWI := TRUE;
	END_IF	

(*270:	xx.x := 'waiting for Foil Presence Checking';								//function test, presence controll
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		IF ix_CheckFoilPresence AND ix_CheckVacuum_3  THEN 						
			f1[feFoilEmptyCheck] :=TRUE;
		END_IF
		IF  NOT f1[feFoilEmptyCheck] THEN										//fehler reset by reset button,whatever the foil presence or not
			Schritt := Schritt + 40;
			SWI := TRUE;
		END_IF		
	END_IF
*)	

310:	xx.x := 'ML1 Elek. Cross Stroke -> return step';
	schrittAxJumpBack		:=schritt;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bBereitFuerPos
	THEN		
		axX.in_lrPosSoll		:= lraxXPickPosition4;
		axX.in_bStartPosAbsolute:=TRUE;
		(*ML1 drives to pick position 4 by jumpback process*)
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF		
		
320:	xx.x := 'ML1 Elek. Cross Stroke -> Pick-Up Position 4';
	axX.in_lrPosSoll		:= lraxXPickPosition4;
	axX.in_bStartPosAbsolute:=TRUE;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bMoveAbsoluteDone
	THEN
		IF arrCarrierData[RtNr][RtStNr][Nest4].PartDataPcb.teilestatus>=srbad THEN 
			_bStepBackAllowed	:=FALSE;
			Schritt := Schritt + 10;
			SWI := TRUE;
		ELSE
			Schritt := 400;
			SWI := TRUE;
		END_IF
	END_IF		

330:	xx.x := 'waiting for Foil Offering'; 
	IF 	AllInPos
	AND Betrieb 
    AND tonVertical4.Q 
	AND in_bPartIsReadyToTakeOver THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 10;			
		SWI := TRUE;	
	END_IF	
	
340:	xx.x := 'MM8 Vertical 4 -> ON (downwards to pick-up position)';
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF	
	
345:	xx.x := 'MM4 Vacuum 4 -> ON (Foil suck)';
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF	

350:	xx.x := 'waiting for Vacuum Pressure Checking';			//the foil shounld be holded by the vacuum in 1sec(uz.q) after vertical cyl. arriving pick-up position
	IF AllInPos
	AND Betrieb
	THEN
		IF ix_CheckVacuum_4 OR UZ.Q THEN
			(* -> start transport control *)
			(* -> wait for transport is ready *)
			out_bPartIsTakeOver := TRUE;
			Schritt := Schritt + 5;
			SWI := TRUE;
		END_IF 
	END_IF

355:	xx.x := 'wait for transport is ready';
	IF NOT in_bPartIsReadyToTakeOver
	THEN
		(* -> MM8 Vertical -> OFF (base pos.) *)
		out_bPartIsTakeOver := TRUE;
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF	
	
360:	xx.x := 'MM8 Vertical 4 -> OFF (upwards to home position)';
	IF 	AllInPos
	AND Betrieb  THEN
		out_bPartIsTakeOver2 := TRUE;
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 40;
		SWI := TRUE;
	END_IF	

(*370:	xx.x := 'waiting for Foil Presence Checking';								//function test, presence controll
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		IF ix_CheckFoilPresence AND ix_CheckVacuum_4  THEN 						
			f1[feFoilEmptyCheck] :=TRUE;
		END_IF
		IF  NOT f1[feFoilEmptyCheck] THEN										//fehler reset by reset button,whatever the foil presence or not
			Schritt := Schritt + 40;
			SWI := TRUE;
		END_IF		
	END_IF
*)	
	
400:	xx.x := 'ML1 Elek. Cross Stroke -> return step';
	schrittAxJumpBack		:=schritt;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bBereitFuerPos
	THEN		
		axX.in_lrPosSoll		:= lraxXInsertPosition;
		axX.in_bStartPosAbsolute:=TRUE;
		(*ML1 drives to Insert Position by jumpback process*)
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF		
		
410:	xx.x := 'ML1 Elek. Cross Stroke -> Insert Position';
	axX.in_lrPosSoll		:= lraxXInsertPosition;
	axX.in_bStartPosAbsolute:=TRUE;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bMoveAbsoluteDone
	THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF			
	
420:	xx.x	:= 'MM5 Vertical 1 -> ON (downwards to insert position)';
		xx.xx 	:= 'MM6 Vertical 2 -> ON (downwards to insert position)';
		xx.xxx  := 'MM7 Vertical 3 -> ON (downwards to insert position)';
		xx.xxxx := 'MM8 Vertical 4 -> ON (downwards to insert position)';
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF	
	
430:	xx.x	:= 'MM1 Vacuum 1 -> OFF (Foil put)';
		xx.xx 	:= 'MM2 Vacuum 2 -> OFF (Foil put)';
		xx.xxx  := 'MM3 Vacuum 3 -> OFF (Foil put)';
		xx.xxxx := 'MM4 Vacuum 4 -> OFF (Foil put)';
	IF 	AllInPos
	AND Betrieb 
	AND tonWaitPressON.Q THEN
		schrittAxJumpBack	:=0;
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF

440:	xx.x	:= 'MM5 Vertical 1 -> OFF (upwards to home position)';
		xx.xx 	:= 'MM6 Vertical 2 -> OFF (upwards to home position)';
		xx.xxx  := 'MM7 Vertical 3 -> OFF (upwards to home position)';
		xx.xxxx := 'MM8 Vertical 4 -> OFF (upwards to home position)';
	IF AllInPos
	AND Betrieb
	THEN
		_QX_23_1:=TRUE;       //0920 added, avoid failure check becuase of flashing
		Schritt := Schritt + 4;
		SWI := TRUE;
	END_IF	

444:	xx.x := 'ML1 Elek. Cross Stroke -> return step';
	schrittAxJumpBack		:=schritt;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bBereitFuerPos
	THEN		
		axX.in_lrPosSoll		:= lraxXHomePosition;
		axX.in_bStartPosAbsolute:=TRUE;
		(*ML1 drives to Insert Position by jumpback process*)
		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF		
		
445:	xx.x := 'ML1 Elek. Cross Stroke -> Home Position';
	axX.in_lrPosSoll		:= lraxXHomePosition;
	axX.in_bStartPosAbsolute:=TRUE;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bMoveAbsoluteDone
	THEN
		_bStepBackAllowed	:=FALSE;
		IF 	BDE_bVisionSensorOn 
		THEN
			out_bStartVisionSensor 		:= TRUE;
			out_byteVisionSensorJobNo 	:= 1;		(*DWOCOM*)
			(* -> start vision sensor BX1 *)
			Schritt := Schritt + 5;
			SWI := TRUE;
		ELSE
			(* -> vision sensor is off *)
			Schritt := Schritt + 10;
			SWI := TRUE;
		END_IF 
	END_IF	
	
450:	xx.x := 'BX1 start vision sensor';
	out_bStartVisionSensor := TRUE;
	IF in_bVisionSensorRuns
	THEN
		(* -> wait for vision sensor is ready *)
		out_bStartVisionSensor := FALSE;
		
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF

455:	xx.x := 'wait for vision sensor is ready';
	IF NOT in_bVisionSensorRuns
	THEN
		Schritt := Schritt + 5;  //DWO TEST
		SWI := TRUE;
	END_IF

460: xx.xx:= 'LineController socket ready';
	IF	NOT LC_Cavity1.out_bBusy THEN

		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF

461:xx.x := 'Upload result to LC';
	IF arrCarrierData[RtNr][RtStNr][NEST1].PartDataPcb.teilestatus = srGood THEN
		LC_Cavity1.UploadStateAndResultData(arrCarrierData[RtNr][RtStNr][NEST1].PartDataPcb.strTypeNr,
										arrCarrierData[RtNr][RtStNr][NEST1].PartDataPcb.strTeileId,
										0,(*Fail_Location*)
										0(*Fail_Type*)
									);
	ELSIF arrCarrierData[RtNr][RtStNr][NEST1].PartDataPcb.StNrSchlechtGesetzt=53 THEN
		LC_Cavity1.UploadStateAndResultData(arrCarrierData[RtNr][RtStNr][NEST1].PartDataPcb.strTypeNr,
										arrCarrierData[RtNr][RtStNr][NEST1].PartDataPcb.strTeileId,
										bcM20_St053_FoilCheckNOK_1,(*Fail_Location*)
										LCID_FAIL_VISION_CHECK(*Fail_Type*)
									);
	ELSE
		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF

	IF (LC_Cavity1.comUploadStateAndResultData.bStarted OR LC_Cavity1.comUploadStateAndResultData.bDone) THEN
		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF;	

462: xx.xx:= 'LineController socket ready';
	IF	NOT LC_Cavity2.out_bBusy THEN

		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF

463:xx.x := 'Upload result to LC';
	IF arrCarrierData[RtNr][RtStNr][NEST2].PartDataPcb.teilestatus = srGood THEN
		LC_Cavity2.UploadStateAndResultData(arrCarrierData[RtNr][RtStNr][NEST2].PartDataPcb.strTypeNr,
										arrCarrierData[RtNr][RtStNr][NEST2].PartDataPcb.strTeileId,
										0,(*Fail_Location*)
										0(*Fail_Type*)
									);
	ELSIF arrCarrierData[RtNr][RtStNr][NEST2].PartDataPcb.StNrSchlechtGesetzt=53 THEN
		LC_Cavity2.UploadStateAndResultData(arrCarrierData[RtNr][RtStNr][NEST2].PartDataPcb.strTypeNr,
										arrCarrierData[RtNr][RtStNr][NEST2].PartDataPcb.strTeileId,
										bcM20_St053_FoilCheckNOK_2,(*Fail_Location*)
										LCID_FAIL_VISION_CHECK(*Fail_Type*)
									);
	ELSE
		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF

	IF (LC_Cavity2.comUploadStateAndResultData.bStarted OR LC_Cavity2.comUploadStateAndResultData.bDone) THEN
		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF;	

464: xx.xx:= 'LineController socket ready';
	IF	NOT LC_Cavity3.out_bBusy THEN

		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF

465:xx.x := 'Upload result to LC';
	IF arrCarrierData[RtNr][RtStNr][NEST3].PartDataPcb.teilestatus = srGood THEN
		LC_Cavity3.UploadStateAndResultData(arrCarrierData[RtNr][RtStNr][NEST3].PartDataPcb.strTypeNr,
										arrCarrierData[RtNr][RtStNr][NEST3].PartDataPcb.strTeileId,
										0,(*Fail_Location*)
										0(*Fail_Type*)
									);
	ELSIF arrCarrierData[RtNr][RtStNr][NEST3].PartDataPcb.StNrSchlechtGesetzt=53 THEN
		LC_Cavity3.UploadStateAndResultData(arrCarrierData[RtNr][RtStNr][NEST3].PartDataPcb.strTypeNr,
										arrCarrierData[RtNr][RtStNr][NEST3].PartDataPcb.strTeileId,
										bcM20_St053_FoilCheckNOK_3,(*Fail_Location*)
										LCID_FAIL_VISION_CHECK(*Fail_Type*)
									);
	ELSE
		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF

	IF (LC_Cavity3.comUploadStateAndResultData.bStarted OR LC_Cavity3.comUploadStateAndResultData.bDone) THEN
		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF;	

466: xx.xx:= 'LineController socket ready';
	IF	NOT LC_Cavity4.out_bBusy THEN

		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF

467:xx.x := 'Upload result to LC';
	IF arrCarrierData[RtNr][RtStNr][NEST4].PartDataPcb.teilestatus = srGood THEN
		LC_Cavity4.UploadStateAndResultData(arrCarrierData[RtNr][RtStNr][NEST4].PartDataPcb.strTypeNr,
										arrCarrierData[RtNr][RtStNr][NEST4].PartDataPcb.strTeileId,
										0,(*Fail_Location*)
										0(*Fail_Type*)
									);
	ELSIF arrCarrierData[RtNr][RtStNr][NEST4].PartDataPcb.StNrSchlechtGesetzt=53 THEN
		LC_Cavity4.UploadStateAndResultData(arrCarrierData[RtNr][RtStNr][NEST4].PartDataPcb.strTypeNr,
										arrCarrierData[RtNr][RtStNr][NEST4].PartDataPcb.strTeileId,
										bcM20_St053_FoilCheckNOK_4,(*Fail_Location*)
										LCID_FAIL_VISION_CHECK(*Fail_Type*)
									);
	ELSE
		Schritt := Schritt + 3;
		SWI := TRUE;
	END_IF

	IF (LC_Cavity4.comUploadStateAndResultData.bStarted OR LC_Cavity4.comUploadStateAndResultData.bDone) THEN
		Schritt := Schritt + 3;
		SWI := TRUE;
	END_IF;		
	

470:	xx.x := 'reset start from roundtable';
	IF AllInPos
	AND Betrieb
	THEN
		bStart := FALSE; 
		Schritt := 0;
		SWI := TRUE;
	END_IF
		
END_CASE


(* ____________________ *)
(* -- React to Steps -- *)
IF NOT ManualRun THEN
	zyl0_pnp_Vacuum1.on 				:= 	 (Schritt >= 45) AND (Schritt < 430);
	
	zyl0_pnp_Vacuum2.on 				:= 	 (Schritt >= 145) AND (Schritt < 430);
	
	zyl0_pnp_Vacuum3.on 				:= 	 (Schritt >= 245) AND (Schritt < 430);
	
	zyl0_pnp_Vacuum4.on 				:= 	 (Schritt >= 345) AND (Schritt < 430);
	
	zyl2_vertical_stroke1.on 			:= 	 ((Schritt >= 40) AND (Schritt < 60))
										  OR ((Schritt >= 420) AND (Schritt < 440));
								
	zyl2_vertical_stroke2.on 			:= 	 ((Schritt >= 140) AND (Schritt < 160))
										  OR ((Schritt >= 420) AND (Schritt < 440));
										  
	zyl2_vertical_stroke3.on 			:= 	 ((Schritt >= 240) AND (Schritt < 260))
										  OR ((Schritt >= 420) AND (Schritt < 440));
										  
	zyl2_vertical_stroke4.on 			:= 	 ((Schritt >= 340) AND (Schritt < 360))
										  OR ((Schritt >= 420) AND (Schritt < 440));

END_IF



(* -- Axes Festo Servocontroller -- *)
axXID	:=cAx_M20_St53_TA1;



(* prevent structure crash*)

_bArea1ToMoveAllowed		:=	(axX.out_lrPosIst>(lraxXPickPosition1 - 5.00))     //(Toleranz) value is not right, should be inputted before ST commission
						  AND 	(axX.out_lrPosIst<(lraxXPickPosition1 + 5.00));
_bArea2ToMoveAllowed		:=	(axX.out_lrPosIst>(lraxXPickPosition2 - 5.00))     //(Toleranz) value is not right, should be inputted before ST commission
						  AND 	(axX.out_lrPosIst<(lraxXPickPosition2 + 5.00));
_bArea3ToMoveAllowed		:=	(axX.out_lrPosIst>(lraxXPickPosition3 - 5.00))     //(Toleranz) value is not right, should be inputted before ST commission
						  AND 	(axX.out_lrPosIst<(lraxXPickPosition3 + 5.00));
_bArea4ToMoveAllowed		:=	(axX.out_lrPosIst>(lraxXPickPosition4 - 5.00))     //(Toleranz) value is not right, should be inputted before ST commission
						  AND 	(axX.out_lrPosIst<(lraxXPickPosition4 + 5.00));
_bArea5ToMoveAllowed		:=	(axX.out_lrPosIst>(lraxXInsertPosition - 5.00))    //(Toleranz) value is not right, should be inputted before ST commission
						  AND 	(axX.out_lrPosIst<(lraxXInsertPosition + 5.00));

						  
_bMoveAxisAllowed			:=	(zyl2_vertical_stroke1.a AND NOT  zyl2_vertical_stroke1.y)
							AND (zyl2_vertical_stroke2.a AND NOT  zyl2_vertical_stroke2.y)
							AND (zyl2_vertical_stroke3.a AND NOT  zyl2_vertical_stroke3.y)
							AND (zyl2_vertical_stroke4.a AND NOT  zyl2_vertical_stroke4.y);

(*
//Jump back if...
IF(		Bedieneinheit.notaus_ok = FALSE			// if jumpback is allowed
	OR	Bedieneinheit.ventile_ok =FALSE
	OR  Bedieneinheit.grundbed = FALSE
	OR  Bedieneinheit.schutz_ok = FALSE
	OR  axX.out_bFault
	OR  ( NOT   _bArea1ToMoveAllowed
		AND (schritt > 20 AND schritt <=70))
	OR  ( NOT   _bArea2ToMoveAllowed
		AND (schritt > 120 AND schritt <=170))
	OR  ( NOT   _bArea3ToMoveAllowed
		AND (schritt > 220 AND schritt <=270))
	OR  ( NOT   _bArea4ToMoveAllowed
		AND (schritt > 320 AND schritt <=370))
	OR  ( NOT   _bArea1ToMoveAllowed
		AND (schritt > 410 AND schritt <=450))
	AND _bStepBackAllowed)
 THEN 
	_baxJumpBackDemanded	:=TRUE;
	
ELSIF _baxJumpBackDemanded						//start the process of jumpback
	AND Betrieb
 THEN 
	_baxJumpBackDemanded	:=FALSE;
	Schritt :=	SchrittAxJumpBack;
	SWI	:= TRUE;

END_IF
*)


(*-------- Axis Input --------*)

axX(
	BedienEinheit							:= BedienEinheit, 
	FaultID									:= FaultID, 
	DisplayNr								:= DisplayNr, 
	ixP_Stop								:= ix_axX_P_Stop AND _bMoveAxisAllowed, 
	ixN_Stop								:= ix_axX_N_Stop AND _bMoveAxisAllowed, 
	ixRef									:= FALSE, 									
	in_strAchsbezeichnung					:= '=53-TA1', 
	in_strP_Stop							:= '=053-BG1.P', 
	in_strN_Stop							:= '=053-BG1.N', 
	ixBtb									:= Bedieneinheit.grundbed OR ix_axX_Ready, 
	in_bSvvVersorgt							:= BedienEinheit.hauptstrom_ok, 
	in_bSvvFreigabe							:= BedienEinheit.grundbed AND BedienEinheit.schutz_ok, 
	in_bSoftwareEnable						:= StatEin, 
	in_lrVelocityPercentAuto				:= lraxXSpeedPositioning, 
	in_lrVelocityPercentManual				:= lraxXSpeedPositioning*0.8, 
	in_lrVelocityGuardOpen					:= 25.0, 
	Axis									:= g_arrAxisRef [axXID], 
	);	

	
	axX.in_bJogForward			:= FALSE;
	axX.in_bJogBackwards		:= FALSE;
	axX.in_bStartPosAbsolute	:= FALSE;
	axX.in_bStartPosAbsolute_2	:= FALSE;					//normally dont need to use it
	axX.in_bNotHalt				:= FALSE;
	axX.in_lrAcceleration		:= 0;
	axX.in_lrDeceleration		:= 0;
	axX.in_bStopTransport		:= NOT bedieneinheit.betr_ein;
	
	
	F_InitAchseOhneKoordsysteme(
		iAchsId						:= axXID, 
		iActionButtonSlow			:= -1, 
		iActionButtonFast			:= -1, 
		strBetriebsmittelname		:= 'M020=St20-TA1', 
		strKlartextname				:= 'X-Axis', 
		strEinheitennameWeg			:= 'mm', 
		strEinheitennameSpeed		:= 'mm/s', 
		bAbsolutAchse				:= FALSE,  				  //not sure 
		 );						
	



	//Insert target- and actuel Position in Axis structure
	g_Achsen[axXID].iAnzKoordsysteme													:=1;
	g_Achsen[axXID].arr_stCoord[cCoordMachine].strName									:='Position';
	g_Achsen[axXID].arr_stCoord[cCoordMachine].lrIstPos									:=axX.out_lrPosIst;
	g_Achsen[axXID].arr_stCoord[cCoordMachine].lrSollPos								:=axX.in_lrPosSoll;



(* _____________________________________ *)
(* -- Stop Roundtable Condition-Based -- *)
IF  NOT 	(   (zyl2_vertical_stroke1.a 	AND NOT zyl2_vertical_stroke1.b	AND NOT zyl2_vertical_stroke1.y)
			AND (zyl2_vertical_stroke2.a 	AND NOT zyl2_vertical_stroke2.b	AND NOT zyl2_vertical_stroke2.y)
			AND (zyl2_vertical_stroke3.a 	AND NOT zyl2_vertical_stroke3.b	AND NOT zyl2_vertical_stroke3.y)
			AND (zyl2_vertical_stroke4.a 	AND NOT zyl2_vertical_stroke4.b	AND NOT zyl2_vertical_stroke4.y))
THEN 
	F_ResetFrgRtWithText(TRUE, RtNr, RtStNr, '053MM5/6/7/8 §Vertical§ §not§ §in§ §base-pos.§', io_RtFreigabe);
END_IF

IF BDE_bInsertEndless
THEN 
	F_ResetFrgRtWithText(TRUE, RtNr, RtStNr, '053 §Insert§ §Endless§', io_RtFreigabe);
END_IF
(* ______________________________________ *)
(* -- Report Station is working on RT  -- *)
io_RtStarts := CSETBIT32(io_RtStarts, RtStNr, bStart);


(* _________________ *)
(* -- Set outputs -- *)

_053_M20_P1_TA1_X1_9		:=axX.qxEnable;
_053_M20_P1_TA1_X1_21		:=axX.qxEnable;

IF ManualRun THEN (* assign cylinderoutputs .y (by "AND Bedieneinheit.ventile_ok") *)
	_053_M20_MP1_QM1_X1			:= 	zyl0_pnp_Vacuum1.y	AND BedienEinheit.notaus_ok;
	_053_M20_MP1_QM2_X1			:= 	zyl0_pnp_Vacuum2.y	AND BedienEinheit.notaus_ok;
	_053_M20_MP1_QM3_X1			:= 	zyl0_pnp_Vacuum3.y	AND BedienEinheit.notaus_ok;
	_053_M20_MP1_QM4_X1			:= 	zyl0_pnp_Vacuum4.y	AND BedienEinheit.notaus_ok;
	_053_M20_MP1_WZ9_QM5_MB1	:= 		zyl2_vertical_stroke1.y	AND Bedieneinheit.ventile_ok;
	_053_M20_MP1_WZ9_QM5_MB2	:=	NOT	zyl2_vertical_stroke1.y	AND Bedieneinheit.ventile_ok;
	_053_M20_MP1_WZ9_QM6_MB1	:= 		zyl2_vertical_stroke2.y	AND Bedieneinheit.ventile_ok;
	_053_M20_MP1_WZ9_QM6_MB2	:=	NOT	zyl2_vertical_stroke2.y	AND Bedieneinheit.ventile_ok;
	_053_M20_MP1_WZ9_QM7_MB1	:= 		zyl2_vertical_stroke3.y	AND Bedieneinheit.ventile_ok;
	_053_M20_MP1_WZ9_QM7_MB2	:=	NOT	zyl2_vertical_stroke3.y	AND Bedieneinheit.ventile_ok;
	_053_M20_MP1_WZ9_QM8_MB1	:= 		zyl2_vertical_stroke4.y	AND Bedieneinheit.ventile_ok;
	_053_M20_MP1_WZ9_QM8_MB2	:=	NOT	zyl2_vertical_stroke4.y	AND Bedieneinheit.ventile_ok;
ELSE (* assign cylinderoutputs .on (by "AND Bedieneinheit.ventile_ok") *)
	_053_M20_MP1_QM1_X1			:= 	zyl0_pnp_Vacuum1.on	AND BedienEinheit.notaus_ok;
	_053_M20_MP1_QM2_X1			:= 	zyl0_pnp_Vacuum2.on	AND BedienEinheit.notaus_ok;
	_053_M20_MP1_QM3_X1			:= 	zyl0_pnp_Vacuum3.on	AND BedienEinheit.notaus_ok;
	_053_M20_MP1_QM4_X1			:= 	zyl0_pnp_Vacuum4.on	AND BedienEinheit.notaus_ok;
	_053_M20_MP1_WZ9_QM5_MB1	:= 		zyl2_vertical_stroke1.on	AND Bedieneinheit.ventile_ok;
	_053_M20_MP1_WZ9_QM5_MB2	:=	NOT	zyl2_vertical_stroke1.on	AND Bedieneinheit.ventile_ok;
	_053_M20_MP1_WZ9_QM6_MB1	:= 		zyl2_vertical_stroke2.on	AND Bedieneinheit.ventile_ok;
	_053_M20_MP1_WZ9_QM6_MB2	:=	NOT	zyl2_vertical_stroke2.on	AND Bedieneinheit.ventile_ok;
	_053_M20_MP1_WZ9_QM7_MB1	:= 		zyl2_vertical_stroke3.on	AND Bedieneinheit.ventile_ok;
	_053_M20_MP1_WZ9_QM7_MB2	:=	NOT	zyl2_vertical_stroke3.on	AND Bedieneinheit.ventile_ok;
	_053_M20_MP1_WZ9_QM8_MB1	:= 		zyl2_vertical_stroke4.on	AND Bedieneinheit.ventile_ok;
	_053_M20_MP1_WZ9_QM8_MB2	:=	NOT	zyl2_vertical_stroke4.on	AND Bedieneinheit.ventile_ok;
END_IF

]]></ST>
    </Implementation>
    <LineIds Name="Mo20_St53_pnp_and_assembling_foil">
      <LineId Id="589" Count="4" />
      <LineId Id="789" Count="2" />
      <LineId Id="960" Count="0" />
      <LineId Id="959" Count="0" />
      <LineId Id="792" Count="8" />
      <LineId Id="5975" Count="4" />
      <LineId Id="6286" Count="16" />
      <LineId Id="5997" Count="26" />
      <LineId Id="154" Count="0" />
      <LineId Id="6024" Count="0" />
      <LineId Id="595" Count="19" />
      <LineId Id="175" Count="4" />
      <LineId Id="7068" Count="0" />
      <LineId Id="180" Count="2" />
      <LineId Id="615" Count="0" />
      <LineId Id="184" Count="0" />
      <LineId Id="5375" Count="4" />
      <LineId Id="185" Count="0" />
      <LineId Id="5380" Count="0" />
      <LineId Id="186" Count="0" />
      <LineId Id="616" Count="0" />
      <LineId Id="5381" Count="0" />
      <LineId Id="5383" Count="1" />
      <LineId Id="5382" Count="0" />
      <LineId Id="5386" Count="1" />
      <LineId Id="5385" Count="0" />
      <LineId Id="5389" Count="1" />
      <LineId Id="5388" Count="0" />
      <LineId Id="5392" Count="0" />
      <LineId Id="5391" Count="0" />
      <LineId Id="5394" Count="2" />
      <LineId Id="5398" Count="0" />
      <LineId Id="5397" Count="0" />
      <LineId Id="5713" Count="0" />
      <LineId Id="5393" Count="0" />
      <LineId Id="617" Count="0" />
      <LineId Id="188" Count="3" />
      <LineId Id="4012" Count="0" />
      <LineId Id="4011" Count="0" />
      <LineId Id="4698" Count="0" />
      <LineId Id="10309" Count="2" />
      <LineId Id="10308" Count="0" />
      <LineId Id="193" Count="0" />
      <LineId Id="10313" Count="0" />
      <LineId Id="10312" Count="0" />
      <LineId Id="618" Count="1" />
      <LineId Id="2813" Count="8" />
      <LineId Id="7404" Count="0" />
      <LineId Id="2823" Count="0" />
      <LineId Id="2243" Count="0" />
      <LineId Id="2837" Count="0" />
      <LineId Id="2839" Count="8" />
      <LineId Id="7405" Count="0" />
      <LineId Id="2849" Count="0" />
      <LineId Id="2838" Count="0" />
      <LineId Id="2850" Count="0" />
      <LineId Id="2852" Count="8" />
      <LineId Id="7406" Count="0" />
      <LineId Id="2862" Count="0" />
      <LineId Id="2851" Count="0" />
      <LineId Id="2863" Count="0" />
      <LineId Id="2865" Count="8" />
      <LineId Id="7407" Count="0" />
      <LineId Id="2875" Count="0" />
      <LineId Id="2864" Count="0" />
      <LineId Id="2876" Count="11" />
      <LineId Id="2258" Count="0" />
      <LineId Id="2889" Count="11" />
      <LineId Id="2888" Count="0" />
      <LineId Id="8480" Count="0" />
      <LineId Id="2903" Count="10" />
      <LineId Id="2901" Count="0" />
      <LineId Id="2915" Count="11" />
      <LineId Id="2914" Count="0" />
      <LineId Id="3158" Count="0" />
      <LineId Id="210" Count="0" />
      <LineId Id="2259" Count="3" />
      <LineId Id="2927" Count="2" />
      <LineId Id="218" Count="0" />
      <LineId Id="620" Count="1" />
      <LineId Id="221" Count="1" />
      <LineId Id="2263" Count="4" />
      <LineId Id="2930" Count="2" />
      <LineId Id="2268" Count="0" />
      <LineId Id="3653" Count="0" />
      <LineId Id="2269" Count="0" />
      <LineId Id="224" Count="1" />
      <LineId Id="3654" Count="1" />
      <LineId Id="226" Count="7" />
      <LineId Id="622" Count="1" />
      <LineId Id="1138" Count="2" />
      <LineId Id="239" Count="0" />
      <LineId Id="241" Count="2" />
      <LineId Id="9105" Count="0" />
      <LineId Id="9107" Count="73" />
      <LineId Id="9106" Count="0" />
      <LineId Id="244" Count="0" />
      <LineId Id="627" Count="1" />
      <LineId Id="247" Count="3" />
      <LineId Id="8800" Count="0" />
      <LineId Id="251" Count="1" />
      <LineId Id="8799" Count="0" />
      <LineId Id="8796" Count="2" />
      <LineId Id="253" Count="5" />
      <LineId Id="1480" Count="0" />
      <LineId Id="3159" Count="1" />
      <LineId Id="259" Count="2" />
      <LineId Id="263" Count="0" />
      <LineId Id="7677" Count="0" />
      <LineId Id="7669" Count="0" />
      <LineId Id="7671" Count="2" />
      <LineId Id="8475" Count="0" />
      <LineId Id="7675" Count="1" />
      <LineId Id="8478" Count="0" />
      <LineId Id="8524" Count="0" />
      <LineId Id="8528" Count="0" />
      <LineId Id="8525" Count="1" />
      <LineId Id="8523" Count="0" />
      <LineId Id="7670" Count="0" />
      <LineId Id="8527" Count="0" />
      <LineId Id="264" Count="3" />
      <LineId Id="6860" Count="1" />
      <LineId Id="268" Count="0" />
      <LineId Id="6862" Count="0" />
      <LineId Id="269" Count="0" />
      <LineId Id="271" Count="0" />
      <LineId Id="273" Count="0" />
      <LineId Id="2270" Count="6" />
      <LineId Id="8468" Count="0" />
      <LineId Id="2277" Count="1" />
      <LineId Id="283" Count="0" />
      <LineId Id="9181" Count="0" />
      <LineId Id="9634" Count="0" />
      <LineId Id="9637" Count="0" />
      <LineId Id="9635" Count="1" />
      <LineId Id="9662" Count="0" />
      <LineId Id="9664" Count="16" />
      <LineId Id="9663" Count="0" />
      <LineId Id="9183" Count="0" />
      <LineId Id="9198" Count="2" />
      <LineId Id="9639" Count="2" />
      <LineId Id="9681" Count="0" />
      <LineId Id="9683" Count="16" />
      <LineId Id="9682" Count="0" />
      <LineId Id="9638" Count="0" />
      <LineId Id="9215" Count="2" />
      <LineId Id="9643" Count="2" />
      <LineId Id="9701" Count="0" />
      <LineId Id="9719" Count="0" />
      <LineId Id="9702" Count="16" />
      <LineId Id="9700" Count="0" />
      <LineId Id="9642" Count="0" />
      <LineId Id="9233" Count="1" />
      <LineId Id="9647" Count="2" />
      <LineId Id="9720" Count="0" />
      <LineId Id="9722" Count="16" />
      <LineId Id="9721" Count="0" />
      <LineId Id="9646" Count="0" />
      <LineId Id="3180" Count="0" />
      <LineId Id="9182" Count="0" />
      <LineId Id="3181" Count="5" />
      <LineId Id="3192" Count="0" />
      <LineId Id="3194" Count="6" />
      <LineId Id="3216" Count="0" />
      <LineId Id="3208" Count="5" />
      <LineId Id="9063" Count="0" />
      <LineId Id="3214" Count="1" />
      <LineId Id="9064" Count="3" />
      <LineId Id="2663" Count="0" />
      <LineId Id="4423" Count="0" />
      <LineId Id="3314" Count="2" />
      <LineId Id="10319" Count="0" />
      <LineId Id="6838" Count="0" />
      <LineId Id="3317" Count="0" />
      <LineId Id="3322" Count="1" />
      <LineId Id="3218" Count="0" />
      <LineId Id="3313" Count="0" />
      <LineId Id="3219" Count="6" />
      <LineId Id="3964" Count="0" />
      <LineId Id="3966" Count="0" />
      <LineId Id="3968" Count="4" />
      <LineId Id="3965" Count="0" />
      <LineId Id="3226" Count="1" />
      <LineId Id="6839" Count="9" />
      <LineId Id="3233" Count="0" />
      <LineId Id="6850" Count="1" />
      <LineId Id="6853" Count="5" />
      <LineId Id="6849" Count="0" />
      <LineId Id="3234" Count="3" />
      <LineId Id="8529" Count="0" />
      <LineId Id="3238" Count="1" />
      <LineId Id="8479" Count="0" />
      <LineId Id="3240" Count="0" />
      <LineId Id="2787" Count="0" />
      <LineId Id="3242" Count="0" />
      <LineId Id="3245" Count="3" />
      <LineId Id="3251" Count="1" />
      <LineId Id="4955" Count="0" />
      <LineId Id="3257" Count="3" />
      <LineId Id="3243" Count="0" />
      <LineId Id="3275" Count="0" />
      <LineId Id="6863" Count="0" />
      <LineId Id="3325" Count="19" />
      <LineId Id="9068" Count="6" />
      <LineId Id="3347" Count="1" />
      <LineId Id="4983" Count="0" />
      <LineId Id="6864" Count="2" />
      <LineId Id="10320" Count="0" />
      <LineId Id="6867" Count="35" />
      <LineId Id="6904" Count="10" />
      <LineId Id="8530" Count="0" />
      <LineId Id="6915" Count="1" />
      <LineId Id="8469" Count="0" />
      <LineId Id="6917" Count="14" />
      <LineId Id="3402" Count="0" />
      <LineId Id="3244" Count="0" />
      <LineId Id="3403" Count="19" />
      <LineId Id="9075" Count="6" />
      <LineId Id="3425" Count="1" />
      <LineId Id="4995" Count="0" />
      <LineId Id="6932" Count="2" />
      <LineId Id="10321" Count="0" />
      <LineId Id="6935" Count="35" />
      <LineId Id="6972" Count="10" />
      <LineId Id="8531" Count="0" />
      <LineId Id="6983" Count="1" />
      <LineId Id="8483" Count="0" />
      <LineId Id="6985" Count="14" />
      <LineId Id="3241" Count="0" />
      <LineId Id="3481" Count="20" />
      <LineId Id="9082" Count="6" />
      <LineId Id="3504" Count="1" />
      <LineId Id="5007" Count="0" />
      <LineId Id="7000" Count="2" />
      <LineId Id="10322" Count="0" />
      <LineId Id="7003" Count="35" />
      <LineId Id="7040" Count="10" />
      <LineId Id="8532" Count="0" />
      <LineId Id="7051" Count="16" />
      <LineId Id="3480" Count="0" />
      <LineId Id="3559" Count="0" />
      <LineId Id="3563" Count="22" />
      <LineId Id="3560" Count="1" />
      <LineId Id="3605" Count="9" />
      <LineId Id="3625" Count="0" />
      <LineId Id="3616" Count="5" />
      <LineId Id="4013" Count="0" />
      <LineId Id="8205" Count="0" />
      <LineId Id="3622" Count="2" />
      <LineId Id="3615" Count="0" />
      <LineId Id="3626" Count="4" />
      <LineId Id="7070" Count="2" />
      <LineId Id="8520" Count="0" />
      <LineId Id="10019" Count="0" />
      <LineId Id="8521" Count="0" />
      <LineId Id="3562" Count="0" />
      <LineId Id="3638" Count="0" />
      <LineId Id="8486" Count="20" />
      <LineId Id="8509" Count="10" />
      <LineId Id="8507" Count="0" />
      <LineId Id="8485" Count="0" />
      <LineId Id="8484" Count="0" />
      <LineId Id="7093" Count="15" />
      <LineId Id="3931" Count="0" />
      <LineId Id="9254" Count="5" />
      <LineId Id="7109" Count="1" />
      <LineId Id="7113" Count="8" />
      <LineId Id="9252" Count="0" />
      <LineId Id="7123" Count="2" />
      <LineId Id="9650" Count="2" />
      <LineId Id="7126" Count="4" />
      <LineId Id="7112" Count="0" />
      <LineId Id="9260" Count="0" />
      <LineId Id="9262" Count="19" />
      <LineId Id="9654" Count="1" />
      <LineId Id="9653" Count="0" />
      <LineId Id="9282" Count="4" />
      <LineId Id="7111" Count="0" />
      <LineId Id="9288" Count="19" />
      <LineId Id="9656" Count="2" />
      <LineId Id="9308" Count="5" />
      <LineId Id="9287" Count="0" />
      <LineId Id="9315" Count="19" />
      <LineId Id="9659" Count="2" />
      <LineId Id="9335" Count="5" />
      <LineId Id="9314" Count="0" />
      <LineId Id="9261" Count="0" />
      <LineId Id="7131" Count="0" />
      <LineId Id="7133" Count="6" />
      <LineId Id="7132" Count="0" />
      <LineId Id="3930" Count="0" />
      <LineId Id="305" Count="0" />
      <LineId Id="4976" Count="0" />
      <LineId Id="4981" Count="0" />
      <LineId Id="634" Count="1" />
      <LineId Id="310" Count="0" />
      <LineId Id="312" Count="0" />
      <LineId Id="3946" Count="0" />
      <LineId Id="3961" Count="0" />
      <LineId Id="3947" Count="0" />
      <LineId Id="3962" Count="0" />
      <LineId Id="3948" Count="0" />
      <LineId Id="3963" Count="0" />
      <LineId Id="3949" Count="11" />
      <LineId Id="4015" Count="0" />
      <LineId Id="314" Count="0" />
      <LineId Id="2051" Count="2" />
      <LineId Id="2055" Count="8" />
      <LineId Id="2162" Count="0" />
      <LineId Id="2161" Count="0" />
      <LineId Id="2164" Count="0" />
      <LineId Id="2166" Count="3" />
      <LineId Id="2064" Count="0" />
      <LineId Id="2170" Count="0" />
      <LineId Id="2311" Count="0" />
      <LineId Id="2065" Count="0" />
      <LineId Id="2933" Count="2" />
      <LineId Id="8472" Count="0" />
      <LineId Id="2067" Count="8" />
      <LineId Id="3936" Count="4" />
      <LineId Id="3943" Count="2" />
      <LineId Id="2076" Count="11" />
      <LineId Id="2101" Count="54" />
      <LineId Id="2054" Count="0" />
      <LineId Id="315" Count="1" />
      <LineId Id="1308" Count="2" />
      <LineId Id="6565" Count="2" />
      <LineId Id="6564" Count="0" />
      <LineId Id="1311" Count="1" />
      <LineId Id="631" Count="0" />
      <LineId Id="7140" Count="2" />
      <LineId Id="323" Count="3" />
      <LineId Id="632" Count="0" />
      <LineId Id="327" Count="0" />
      <LineId Id="633" Count="0" />
      <LineId Id="329" Count="1" />
      <LineId Id="5401" Count="0" />
      <LineId Id="5400" Count="0" />
      <LineId Id="5399" Count="0" />
      <LineId Id="331" Count="0" />
      <LineId Id="5402" Count="1" />
      <LineId Id="5434" Count="1" />
      <LineId Id="5408" Count="1" />
      <LineId Id="5436" Count="0" />
      <LineId Id="5417" Count="0" />
      <LineId Id="5437" Count="3" />
      <LineId Id="5418" Count="0" />
      <LineId Id="5441" Count="10" />
      <LineId Id="336" Count="2" />
      <LineId Id="9" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>