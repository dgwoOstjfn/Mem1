<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.16">
  <POU Name="Mo20_St10_transfer_the_housing" Id="{6700f5b8-c211-44f2-9e41-b530fdefbdaf}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK Mo20_St10_transfer_the_housing
(*--------------------------------------------------------------------------------------
Preh IMA Automation Amberg GmbH

<DESC>
=INSERT DESCRIPTION FROM WORKFLOWPLAN=
</DESC>


<CHANGES>
At every change add date, version´s number, abbr. of name and describe change!

Date 		|	Version	|	Author	|	change description		
--------------------------------------------------------------------------------
2017-11-06	|	1.00	|	DWO		|	initial version

</CHANGES>
<VERSION>
1.00
</VERSION>

<DEPENDENCIES>
;
</DEPENDENCIES>



 -- overview of areas for steps --
Steps [000..099]: 	Whatever Block
Steps [100..199]:	Next Whatever Block

  
----------------------------------------------------------------------------------------*)



(* _____________________ *)
(* -- Standard-Inputs -- *)
VAR_INPUT
	OrderNr: 			INT :=E_TAB_MO_20_ST_10;		(* Nr. Actorder *)
	MoNr: 				INT:= 020;		(* Module-Number *)
	StNr: 				INT:= 10;		(* Stationsnumber *)
	BedienEinheit: 		ZENTR_DATA;		(* Central *)
	FaultID: 			BYTE := 0;		(* ID for Error Array *)
	DisplayNr: 			INT := 1;		(* Number of Textdisplay *)
	MPart: 				INT := 1;		(* Machinepart *)
	in_InitChainTxt:	STRING(39);		(* String for Step Chain Diagnosis *)
	in_sKebaKurz:		STRING(gcKebaStKurzLen) := '1234567890'; (* optional - can also be assigned in initialisation paragraph *)
	in_sKebaBez:		STRING(gcKebaStBezLen) 	:= '11111111112222222222333333333344444444445555555555'; (* optional - can also be assigned in initialisation paragraph *)
END_VAR


(* __________________ *)
(* -- RT-Interface -- *)
VAR_INPUT
	RtNr:				INT := 02;
	RtStNr:				SINT := 01;
	RtStartimpuls:		BOOL:=FALSE;	
END_VAR

VAR_IN_OUT
	//io_RtRegister:		ARRAY[1..8] OF ARRAY[1..2] OF DataTeil; // info for all parts within roundtable - the part for the station is accessed at [RtStNr]
	io_RtStarts:		DWORD; // bit array (dword) representing station is working on roundtable (flow based)
	io_RtFreigabe:		DWORD; // bit array (dword) representing station is giving permission for table to move (state based)
	io_RtFault:			DWORD; // bit array (dword) representing error at RtStNr of roundtable
	io_RtWaiting:		DWORD; // bit array (dword) representing waiting at RtStNr of roundtable
	io_RtWarning:		DWORD; // bit array (dword) representing warning at RtStNr of roundtable
END_VAR



(* ====== IF NO FEEDING STATION EXISTS PLEASE DELETE THIS PARAGRAPH AND ELEMINATE SUBSEQUENT ERRORS ====== *)
(* ____________________________ *)
(* -- Handshake with Feeding -- *)
VAR_INPUT PERSISTENT
	in_bOffering			:BOOL:=FALSE;
	in_bOfferEnd			:BOOL:=FALSE;
	in_bPartinHandlingST50	:BOOL:=FALSE;
END_VAR
VAR_OUTPUT PERSISTENT
	out_bEnablePrework		:BOOL:=FALSE;
	out_bReadyToTakeOver	:BOOL:=FALSE;
	out_bTakenOver			:BOOL:=FALSE;
END_VAR
(* ====== IF NO FEEDING STATION EXISTS PLEASE DELETE THIS PARAGRAPH AND ELEMINATE SUBSEQUENT ERRORS ====== *)




(* ________________________ *)
(* -- Standard-Variables -- *)
VAR PERSISTENT
	SWI: 				BOOL := FALSE;	(* Impulse step is changing forward *)
	SWR:				BOOL := FALSE;	(* Impulse step is changing backwards *)
	Schritt: 			INT := 0;		(* Current step *)
	UZ: 				TON;			(* watchtime *)
	Fault: 				BOOL;			(* Stations Error *)
	Waiting:			BOOL;			(* Station Waiting *)
	Warning:			BOOL;			(* Station Warning *)
	Betrieb: 			BOOL;			(* Enable Steps *)
	StatEin: 			BOOL;			(* Station on *)
	AllInPos: 			BOOL;			(* all cylinders in position and not actuated manually *)
	Active:				BOOL;			(* stepchain is marked as active *)
	Transport:			BOOL;			(* manual transport is enabled *)
	InitRun:			BOOL;			(* goto homepos is enabled *)
	CycleRun:			BOOL;			(* mode for single cycle is enabled *)
	ManualRun:			BOOL;			(* move cylinders manually is enabled *)
	BackwardsRun:		BOOL;			(* backwards run is enabled *)
	tonSeitSwi:			TON;			(* time since last change of step *)
	tonSeitAllInPos:	TON;			(* time since AllInPos has become TRUE *)
	i:					INT;			(* index-runner for loops *)
	xx:					FB_StepTracker;	(* auto record steps *)
	StatString:			STRING(10);		(* '+MM=SS' *)
	StartCondition:		BOOL;			(* condition for starting station *)
	StartConditionEmptyRun: BOOL;
	bStart:				BOOL;			(* station's work on roundtable is running *)
	NestNr:				INT;			(* number of nest within fixation *)
	h:					INT;
	j:					INT;
END_VAR

VAR CONSTANT	
NEST1					:INT:=1;
NEST2					:INT:=2;
END_VAR

(* ___________________ *)
(* -- Error-Array 1 -- *)
VAR
	Errors1: ARRAY[1..ErrMaxBits] OF ERRDAT := [
	(* Error 01 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/01            '),
	(* Error 02 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/02            '),
	(* Error 03 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/03            '),
	(* Error 04 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/04            '),
	(* Error 05 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/05            '),
	(* Error 06 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/06            '),
	(* Error 07 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/07            '),
	(* Error 08 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/08            '),
	(* Error 09 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/09            '),
	(* Error 10 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/10            '),
	(* Error 11 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/11            '),
	(* Error 12 *)		(Prio := ErrZyl, Nr:= 89, Txt:='=010_BG1 '), 			//*************** PRESENCE CHECK 
	(* Error 13 *)		(Prio := ErrZyl, Nr:= 89, Txt:='=010_BG2 '), 			//*************** PRESENCE CHECK 
	(* Error 14 *)		(Prio := ErrMeld, Nr:= 2510, Txt:='St10 Transfer '), 	//*************** waiting for feeding
	(* Error 15 *)		(Prio := ErrMeld, Nr:= 2511, Txt:='St10 Transfer '), 	//*************** waiting for feeding end
	(* Error 16 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/16            ')];
	f1: ARRAY [1..ErrMaxBits] OF BOOL := [ErrMaxBits(FALSE)];
	Fehler1: ERRORANZ;
END_VAR

VAR CONSTANT
fePresenceCheck1		:INT:=12;
fePresenceCheck2		:INT:=13;
feWaitOffering			:INT:=14;
feWaitOfferEnd			:INT:=15;
feAwErrorPresence		:INT:=8;
END_VAR



(* _____________________ *)
(* -- Local Variables -- *)
VAR PERSISTENT

	(* == Cylinders == *)
	
	zyl0_pnp_grip1				:ZYL0; (* MM1 *)
	
	zyl0_pnp_grip2				:ZYL0; (* MM2 *)
	
	zyl2_pnp_v_stroke			:ZYL2; (* MM3 *)
	ix_pnp_v_strokeA			:BOOL:=FALSE;
	ix_pnp_v_strokeB			:BOOL:=FALSE;
	
	zyl2_pnp_h_stroke			:ZYL2; (* MM4 *)
	ix_pnp_h_strokeA			:BOOL:=FALSE;
	ix_pnp_h_strokeB			:BOOL:=FALSE;
	
	zyl2_operate_carrier		:ZYL2; (* MM5 *)
	ix_operate_carrierA			:BOOL:=FALSE;
	ix_operate_carrierB			:BOOL:=FALSE;
	
	
	
	(* == Sensors == *)
	ix_CavityCheck1				:BOOL:=FALSE;
	ix_CavityCheck2				:BOOL:=FALSE;
	
	dataHandling				:DataTeil;
	
	bPartNeeded					:BOOL:=FALSE;
	iPartsNeeded				:INT:=0;
END_VAR




(* _____________________ *)
(* -- Function Blocks -- *)
VAR
	awPrecenseError_1			:AWFEHLER;
	awPrecenseError_2			:AWFEHLER;
END_VAR

(* ____________________ *)
(* -- LineController -- *)
VAR
	LC_Cavity1					:FB_LcStationCommandHandler;
	LC_Cavity2					:FB_LcStationCommandHandler;
	//LC							:FB_LcStationCommandHandler;
	//LC_Recipe					:FB_LC_LoadRecipeManager;
	DayCounter					:STRING(40);
	CounterResult				:STRING(40);
	DataIndex					:UDINT := 1;
	DataIndex2					:UDINT := 1;
	
	TEST_Int					:INT;
	ASYS_OrderPartsLeft			:DWORD;
	a							:BYTE;
	b							:DWORD;
END_VAR
VAR PERSISTENT
	OutUserData					:ARRAY[1..100] OF BYTE;
	InUserData					:ARRAY[1..100] OF BYTE;		
	strTempTeileId				:STRING(40) := 'YYYYMMDDHHMMSS';
	TypeNo						:STRING(80);
	SerialNo					:STRING(80);
	udiIndex						:UDINT;
	DINT1						:DINT:=100;
	INT2						:INT:=120;
	DINT3						:DINT:=140;
	DINT4						:DINT:=150;
	DINT5						:DINT:=120;
	DINT6						:DINT:=300;
END_VAR

(* Order Details *)
VAR
	OrderID						:DINT;
	OrderName					:STRING;
	OrderStatus					:WORD;
	TargetSize					:DINT;
	CurrentSize					:DINT;
	
	GmPartNumber				:STRING;
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[(* ____________________ *)
(* -- Initialisation -- *)
IF neustart OR g_bOnlineChange THEN
	StatString 		:= RIGHT(CONCAT( '000',INT_TO_STRING(StNr) ),3); (* three digits station's prefix is being created automatically for station *)
	in_InitChainTxt := CONCAT( StatString, ' §Pick and Place§ §Gehäuse§ ' );
	in_sKebaKurz	:= CONCAT( StatString, ' House'); // 3+7 digits
	in_sKebaBez		:= in_InitChainTxt;
END_IF


KebaInitStation(
	Panelnummer		:= gKebaAktPanel,
	Aktiv			:= TRUE,
	Kurzbezeichnung	:= in_sKebaKurz,
	Bezeichnung		:= in_sKebaBez,
	ManuellAktiv	:= TRUE,
	RueckwaertsAktiv:= FALSE,
	GsAktiv			:= FALSE,
);


(* _______________________________________ *)
(* -- Entry for Step Sequence Diagnosis -- *)
InitChain(
	Step 			:= Schritt,
	InitialState 	:= TRUE,
	Fault 			:= Fault,
	Waiting 		:= Waiting,
	Warning 		:= Warning,
	AllInPos 		:= AllInPos,
	RunOpenDoor 	:= TRUE,
	Txt 			:= in_InitChainTxt,
	BedienEinheit 	:= BedienEinheit,
	Active 			:= Active,
	Transport 		:= Transport,
	InitRun 		:= InitRun,
	CycleRun 		:= CycleRun,
	ManualRun 		:= ManualRun,
	BackwardsRun 	:= BackwardsRun);
InitRun := FALSE;


(* _______________ *)
(* -- Parameter -- *)
StatEin 	:= ActOrd[MPart].ord_stat[OrderNr].sd_ein;



(* ____________ *)
(* -- Inputs -- *)
ix_pnp_v_strokeA		:=_010_M20_MP1_BG3_A;
ix_pnp_v_strokeB		:=_010_M20_MP1_BG3_B;

ix_pnp_h_strokeA		:=_010_M20_MP1_BG4_A;
ix_pnp_h_strokeB		:=_010_M20_MP1_BG4_B;

ix_operate_carrierA		:=_010_M20_MP1_BG5_A;
ix_operate_carrierB		:=_010_M20_MP1_BG5_B;

ix_CavityCheck1			:=_010_M20_MP1_BG1;
ix_CavityCheck2			:=_010_M20_MP1_BG2;
(* _______________________ *)
(* -- Timer / Watchdogs -- *)
UZ( IN:= NOT SWI AND BedienEinheit.grundbed, PT:= T#5s );
tonSeitSwi( IN := NOT SWI AND Bedieneinheit.grundbed, PT := t#30d );
tonSeitAllInPos( IN := AllInPos AND Bedieneinheit.grundbed, PT := t#30d );


(* _______________ *)
(* -- Cylinders -- *)


zyl0_pnp_grip1(
	enable_man	:= Bedieneinheit.ventile_ok, 
	FNrMan		:= 605, 
	on_vz		:= T#500MS, 
	off_vz		:= T#300MS, 
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '1',
	ID			:= FaultId,
	Bild		:= picGreifermodul, 
	BildB		:= picGreifermodulInv,
 );
 
 zyl0_pnp_grip2(
	enable_man	:= Bedieneinheit.ventile_ok, 
	FNrMan		:= 605, 
	on_vz		:= T#500MS, 
	off_vz		:= T#300MS, 
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '2',
	ID			:= FaultId,
	Bild		:= picGreifermodul, 
	BildB		:= picGreifermodulInv,
);

zyl2_pnp_v_stroke(
	grundbed	:= Bedieneinheit.grundbed,
	a			:= ix_pnp_v_strokeA,
	b			:= ix_pnp_v_strokeB,
	enable_man	:= Bedieneinheit.ventile_ok,
	FNr			:= 211,
	FNrMan		:= 611,
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '3',
	ID			:= FaultId,
	Bild		:= picStandard,
	BildB		:= picStandardInv,
);

zyl2_pnp_h_stroke(
	grundbed	:= Bedieneinheit.grundbed,
	a			:= ix_pnp_h_strokeA,
	b			:= ix_pnp_h_strokeB,
	enable_man	:= Bedieneinheit.ventile_ok,
	FNr			:= 210,
	FNrMan		:= 610,
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '4',
	ID			:= FaultId,
	Bild		:= picStandard,
	BildB		:= picStandardInv,
);


zyl2_operate_carrier(
	grundbed	:= Bedieneinheit.grundbed,
	a			:= ix_operate_carrierA,
	b			:= ix_operate_carrierB,
	enable_man	:= Bedieneinheit.ventile_ok,
	FNr			:= 245,
	FNrMan		:= 645,
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '5',
	ID			:= FaultId,
	Bild		:= picStandard,
	BildB		:= picStandardInv,
);


AllInPos :=	zyl0_pnp_grip1.pos
		AND zyl0_pnp_grip2.pos
		AND zyl2_pnp_v_stroke.pos
		AND zyl2_pnp_h_stroke.pos
		AND zyl2_operate_carrier.pos;

(* _____________________ *)
(* -- Line Controller -- *)
LC_Cavity1.in_Data.OutUserData := ADR(OutUserData);
LC_Cavity1.in_Data.OutUserData_BufferSize := SIZEOF(OutUserData);
LC_Cavity1.in_Data.InUserData  := ADR(InUserData);
LC_Cavity1.in_Data.InUserData_Anzahl_Byte := SIZEOF(InUserData);
LC_Cavity1(
		MoNr				:= MoNr, 
		StNr				:= StNr, 
		FaultID				:= FaultID, 
		DisplayNr			:= DisplayNr, 
		in_strBMK			:= 'LC', 
		in_bConnect			:= BedienEinheit.notaus_ok, 
		in_bEnableLog		:= TRUE, 
		in_sRemoteHost		:= IP_LineController, 
		in_uiRemotePort		:= 20101,//INT_TO_UINT(MoNr * 10000 + StNr + Nest1),
		in_uiStationID		:= 201,//LCID_M10_ST110, 
		in_uiStationSubID	:= 1, 
		in_bTelegram64kB	:= FALSE, 
		in_bTypbeschrUebertr:= FALSE
);

LC_Cavity2.in_Data.OutUserData := ADR(OutUserData);
LC_Cavity2.in_Data.OutUserData_BufferSize := SIZEOF(OutUserData);

LC_Cavity2(
		MoNr				:= MoNr, 
		StNr				:= StNr, 
		FaultID				:= FaultID, 
		DisplayNr			:= DisplayNr, 
		in_strBMK			:= 'LC', 
		in_bConnect			:= BedienEinheit.notaus_ok, 
		in_bEnableLog		:= TRUE, 
		in_sRemoteHost		:= IP_LineController, 
		in_uiRemotePort		:= 20102,//INT_TO_UINT(MoNr * 10000 + StNr + Nest2),
		in_uiStationID		:= 201,//LCID_M10_ST110, 
		in_uiStationSubID	:= 2, 
		in_bTelegram64kB	:= FALSE, 
		in_bTypbeschrUebertr:= FALSE
);
(* __________________ *)
(* -- Treat Errors -- *)
Fehler1( ID:= FaultID, FAnz:= DisplayNr, EF:= Errors1, F:= f1 );

Fault	:= zyl0_pnp_grip1.err 		(* Error´s of function blocks *)
		OR zyl0_pnp_grip2.err
		OR zyl2_pnp_v_stroke.err
		OR zyl2_pnp_h_stroke.err
		OR zyl2_operate_carrier.err;	
Warning := FALSE;
Waiting := FALSE;
FOR i := 1 TO ErrMaxBits BY 1 DO
	IF f1[i] THEN
		IF 		Errors1[i].Prio <= ErrZyl 			THEN Fault := TRUE;
		ELSIF	Errors1[i].Prio <= ErrEndl 			THEN Waiting := TRUE; f1[i] := FALSE;
		ELSIF	Errors1[i].Prio <= ErrWechselpos	THEN Warning := TRUE; f1[i] := FALSE; END_IF
	END_IF
END_FOR


// report Error, Waiting and Warning to cell
IF Fault 	THEN io_RtFault 	:= SETBIT32( io_RtFault,   RtStNr ); END_IF
IF Waiting 	THEN io_RtWaiting 	:= SETBIT32( io_RtWaiting, RtStNr ); END_IF
IF Warning	THEN io_RtWarning	:= SETBIT32( io_RtWarning, RtStNr ); END_IF


(* Create Errrors / Misc. Errors *)


(* __________________________________ *)
(* -- Station - Allowed to Operate -- *)
Betrieb := 	Bedieneinheit.betrieb
		AND NOT Fault
		AND NOT ManualRun
		AND BedienEinheit.ventile_ok;


(* ____________________ *)
(* -- Start Station  -- *)
(*
IF 	RtStartimpuls THEN
	StartCondition 
		:= 	StatEin
		AND	arrCarrierData[RtNr][RtStNr][Nest1].PartData.teilestatus = srEmpty
		AND	arrCarrierData[RtNr][RtStNr][Nest2].PartData.teilestatus = srEmpty;				
	IF StartCondition THEN bStart := TRUE; END_IF
END_IF
*)

//ASYS_OrderPartsLeft:=9999;  //DWOCOM
IF 	RtStartimpuls THEN

	bPartNeeded	 := FALSE;
	iPartsNeeded := 0;

	// X-Parts are needed...
	FOR j := 1 TO 4 BY 1 DO
		IF arrCarrierData[1][j][1].PartDataPcb.teilestatus >= srGood THEN iPartsNeeded := iPartsNeeded + 1 ; END_IF
		IF arrCarrierData[1][j][2].PartDataPcb.teilestatus >= srGood THEN iPartsNeeded := iPartsNeeded + 1 ; END_IF
		IF arrCarrierData[1][j][3].PartDataPcb.teilestatus >= srGood THEN iPartsNeeded := iPartsNeeded + 1 ; END_IF
		IF arrCarrierData[1][j][4].PartDataPcb.teilestatus >= srGood THEN iPartsNeeded := iPartsNeeded + 1 ; END_IF
	END_FOR

	IF in_bPartinHandlingST50 THEN iPartsNeeded := iPartsNeeded + 2 ; END_IF

	// ...some parts are already on it's way... 
	FOR h := 2 TO 5 BY 1 DO
		IF  arrCarrierData[2][h][1].PartDataPcb.teilestatus >= srbad THEN iPartsNeeded := iPartsNeeded - 1;END_IF
		IF  arrCarrierData[2][h][2].PartDataPcb.teilestatus >= srbad THEN iPartsNeeded := iPartsNeeded - 1;END_IF
	END_FOR
	
	bPartNeeded := (iPartsNeeded > 0);

	StartCondition 			:= 	StatEin
								AND	arrCarrierData[RtNr][RtStNr][Nest1].PartData.teilestatus = srEmpty
								AND	arrCarrierData[RtNr][RtStNr][Nest2].PartData.teilestatus = srEmpty	
								AND NOT Bedieneinheit.mpart[Mpart].hm_leer;
						
	//  Empty Run is active, but parts are still needed (for parts in roundtable 2)
	StartConditionEmptyRun	:=		StatEin
								AND	arrCarrierData[RtNr][RtStNr][Nest1].PartData.teilestatus = srEmpty
								AND	arrCarrierData[RtNr][RtStNr][Nest2].PartData.teilestatus = srEmpty
								AND Bedieneinheit.mpart[Mpart].hm_leer
								AND bPartNeeded;
						
	IF (StartCondition OR StartConditionEmptyRun) THEN bStart := TRUE; END_IF

END_IF


(* ________________ *)
(* -- Step-Chain -- *)
xx( iStep := Schritt );

(* reset flags *)
out_bEnablePrework := StatEin AND (NOT Bedieneinheit.mpart[Mpart].hm_leer OR bStart);
SWI := FALSE;

CASE Schritt OF
0:	xx.x := 'in basepos. - wait for prework or station´s start';
	IF  AllInPos
	AND bStart
		//OR 	(out_bEnablePrework AND StatEin)	)
	AND BedienEinheit.anl_ein
	AND Betrieb THEN
		Schritt := Schritt + 1 ;
		SWI := TRUE;
	END_IF

1:xx.x := 'PartsLeft';
	a:=5;
	b:=9999;
	DataIndex := 1;
	F_LcSetbyte(ADR(InUserData[DataIndex]),a,DataIndex);
	F_LcSetdword(ADR(InUserData[DataIndex]),b, DataIndex);
	IF NOT LC_Cavity1.out_bBusy THEN
		LC_Cavity1.in_Data.SerialNo:= 'ASYS_OrderPartsLeft';			//+1 by each cycle
		LC_Cavity1.in_Data.AssyLocation := 4;		
		LC_Cavity1.in_Data.OPcode := ENU_LC_OpCode.setVariable;
		LC_Cavity1.in_bSendTelegram := TRUE;
	END_IF

	IF LC_Cavity1.out_bBusy AND NOT LC_Cavity1.out_bError THEN
		Schritt := Schritt + 9;
		SWI := TRUE;
		LC_Cavity1.in_bSendTelegram := FALSE;
	END_IF

2: xx.x := 'Wait for result of OP15 = checkSNRState from LC';
	IF NOT LC_Cavity1.out_bBusy THEN
		IF LC_Cavity1.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackSucces THEN
			
			Schritt := Schritt + 1; 		//dwocom
			SWI := TRUE;
		
		END_IF
	END_IF	

	
10: xx.x := 'Get order details (OP91) from LineController';	
	LC_Cavity1.getOrderDetails(SerialNo := '');
	IF LC_Cavity1.comGetOrderDetails.bDone THEN
		IF LC_Cavity1.comGetOrderDetails.bValid THEN
		
			udiIndex 	:= 1;
			OrderID 	:= F_LcGetLong( ADR(OutUserData[udiIndex]), udiIndex);
			OrderName	:= F_LcGetString( ADR(OutUserData[udiIndex]), udiIndex);
			TypeNo		:= F_LcGetString( ADR(OutUserData[udiIndex]), udiIndex);
			OrderStatus	:= F_LcGetWord( ADR(OutUserData[udiIndex]), udiIndex);
			TargetSize 	:= F_LcGetLong( ADR(OutUserData[udiIndex]), udiIndex);
			CurrentSize := F_LcGetLong( ADR(OutUserData[udiIndex]), udiIndex);

			Schritt := Schritt + 10;
			SWI := TRUE;
			arrCarrierData[RtNr][RtStNr][Nest1].PartData.strTypeNr:=TypeNo;
		ELSE
			// Error from LineController			
///			f1[feLcGetOrderDetailsFailed] 	:= TRUE;
			Schritt := 0;
			SWI 	:= TRUE;	
		END_IF 			
	END_IF

19: xx.x := 'Empty step for errorhandling';
	IF AllInPos 
	AND Betrieb
	THEN
		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF 	
	
20:xx.x:= 'Get recipe (OP40) from LC';
	LC_Cavity1.getRecipe(TypeNo);

	IF LC_Cavity1.comGetRecipe.bDone THEN

		IF LC_Cavity1.comGetRecipe.bValid THEN
			udiIndex 		:= 1;
			//TEST_Int		:=F_LcGetinteger( ADR(OutUserData[udiIndex]), udiIndex);
			GmPartNumber	:= F_LcGetString( ADR(OutUserData[udiIndex]), udiIndex);
			arrCarrierData[RtNr][RtStNr][Nest1].PartData.Mo20_St010.GMPartSWVersion:= F_LcGetString( ADR(OutUserData[udiIndex]), udiIndex);
			arrCarrierData[RtNr][RtStNr][Nest1].PartData.Mo20_St010.GMPartNumber:=GmPartNumber;
			Schritt := Schritt + 10;
			SWI := TRUE;
		ELSE // Error from LineController
			 // create a new part 
///			f1[feLcGetRecipeFailed] := TRUE;

			Schritt := 19;
			SWI 	:= TRUE;				
		END_IF
	END_IF

30: xx.x := 'Create ID and GetCounterValue (OP44) from LineController';	
	//Create Part ID
	strTempTeileId := (* YY *)	RIGHT(WORD_TO_STRING(timestructActualTime.wYear),2);				
	strTempTeileId := (* DOY *)	CONCAT(strTempTeileId,RIGHT(CONCAT('000', WORD_TO_STRING(F_GetDOYOfYearMonthDay( wYear := timestructActualTime.wYear, wMonth := timestructActualTime.wMonth, wDay := timestructActualTime.wDay ))),3));

	LC_Cavity1.getCounterValue(strTempTeileId);
	IF LC_Cavity1.comgetCounterValue.bDone THEN
		IF LC_Cavity1.comgetCounterValue.bValid THEN
			(* save the number *)
			CounterResult := LC_Cavity1.out_Data.SerialNo;
			strTempTeileId := CONCAT( strTempTeileID, RIGHT(Concat ( '00000', CounterResult),5));
			Schritt := Schritt + 2;
			SWI := TRUE;
			arrCarrierData[RtNr][RtStNr][Nest1].PartData.strTeileId:=strTempTeileId;
		ELSE
			// Error from LineController
			// create a new part 			
			//f1[feLcGetCounterValueFailed] := TRUE;

			Schritt := 1;
			SWI 	:= TRUE;	
		END_IF 			
	END_IF

32:xx.x := 'Check Serial number in LineController';

	IF NOT LC_Cavity1.out_bBusy THEN
		LC_Cavity1.in_Data.SerialNo:= arrCarrierData[RtNr][RtStNr][Nest1].PartData.strTeileId;			//+1 by each cycle
		LC_Cavity1.in_Data.TypeNo  := arrCarrierData[RtNr][RtStNr][Nest1].PartData.strTypeNr;
		LC_Cavity1.in_Data.AssyLocation := 0;
		LC_Cavity1.in_Data.OPcode := ENU_LC_OpCode.checkSNRState;
		LC_Cavity1.in_bSendTelegram := TRUE;
	END_IF

	IF LC_Cavity1.out_bBusy AND NOT LC_Cavity1.out_bError THEN
		Schritt := Schritt + 3;
		SWI := TRUE;
		LC_Cavity1.in_bSendTelegram := FALSE;
	END_IF

35: xx.x := 'Wait for result of OP15 = checkSNRState from LC';
	IF NOT LC_Cavity1.out_bBusy THEN
		IF NOT LC_Cavity1.out_bError AND LC_Cavity1.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackSucces THEN
			(* merge parts *)
			Schritt := Schritt + 5;
			SWI := TRUE;
		ELSE
			IF LC_Cavity1.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackReserved  THEN // TCP/IP-Fehler
				Schritt := 30;
				SWI := TRUE;
			
			END_IF
		END_IF
	END_IF	

40:xx.x := 'assign order to SNR';

	IF NOT LC_Cavity1.out_bBusy THEN
		LC_Cavity1.in_Data.SerialNo:= arrCarrierData[RtNr][RtStNr][Nest1].PartData.strTeileId;			//+1 by each cycle
		LC_Cavity1.in_Data.TypeNo  := DINT_TO_STRING(OrderID);
		LC_Cavity1.in_Data.OPcode := 14;
		LC_Cavity1.in_bSendTelegram := TRUE;
	END_IF

	IF LC_Cavity1.out_bBusy AND NOT LC_Cavity1.out_bError THEN
		Schritt := Schritt + 5;
		SWI := TRUE;
		LC_Cavity1.in_bSendTelegram := FALSE;
	END_IF

45: xx.x := 'Wait for result of OP14';
	IF NOT LC_Cavity1.out_bBusy THEN
		IF NOT LC_Cavity1.out_bError AND LC_Cavity1.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackSucces THEN
			(* merge parts *)
			Schritt := Schritt + 5;
			SWI := TRUE;
		ELSE
			IF LC_Cavity1.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackReserved  THEN // TCP/IP-Fehler
				Schritt := 39;
				SWI := TRUE;
			
			END_IF
		END_IF
	END_IF	
	
50: xx.x := 'Get order details (OP91) from LineController';	
	LC_Cavity2.getOrderDetails(SerialNo := '');
	IF LC_Cavity2.comGetOrderDetails.bDone THEN
		IF LC_Cavity2.comGetOrderDetails.bValid THEN
		
			udiIndex 	:= 1;
			OrderID 	:= F_LcGetLong( ADR(OutUserData[udiIndex]), udiIndex);
			OrderName	:= F_LcGetString( ADR(OutUserData[udiIndex]), udiIndex);
			TypeNo		:= F_LcGetString( ADR(OutUserData[udiIndex]), udiIndex);
			OrderStatus	:= F_LcGetWord( ADR(OutUserData[udiIndex]), udiIndex);
			TargetSize 	:= F_LcGetLong( ADR(OutUserData[udiIndex]), udiIndex);
			CurrentSize := F_LcGetLong( ADR(OutUserData[udiIndex]), udiIndex);

			Schritt := Schritt + 10;
			SWI := TRUE;
			arrCarrierData[RtNr][RtStNr][Nest2].PartData.strTypeNr:=TypeNo;
		ELSE
			// Error from LineController			
///			f1[feLcGetOrderDetailsFailed] 	:= TRUE;
			Schritt := 0;
			SWI 	:= TRUE;	
		END_IF 			
	END_IF

59: xx.x := 'Empty step for errorhandling';
	IF AllInPos 
	AND Betrieb
	THEN
		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF 	
	
60:xx.x:= 'Get recipe (OP40) from LC';
	LC_Cavity2.getRecipe(TypeNo);

	IF LC_Cavity2.comGetRecipe.bDone THEN

		IF LC_Cavity2.comGetRecipe.bValid THEN
			udiIndex 		:= 1;
			//TEST_Int		:=F_LcGetinteger( ADR(OutUserData[udiIndex]), udiIndex);
			GmPartNumber	:= F_LcGetString( ADR(OutUserData[udiIndex]), udiIndex);
			arrCarrierData[RtNr][RtStNr][Nest1].PartData.Mo20_St010.GMPartSWVersion:= F_LcGetString( ADR(OutUserData[udiIndex]), udiIndex);
			arrCarrierData[RtNr][RtStNr][Nest2].PartData.Mo20_St010.GMPartNumber:=GmPartNumber;
			Schritt := Schritt + 10;
			SWI := TRUE;
		ELSE // Error from LineController
			 // create a new part 
///			f1[feLcGetRecipeFailed] := TRUE;

			Schritt := 59;
			SWI 	:= TRUE;				
		END_IF
	END_IF

70: xx.x := 'Create ID and GetCounterValue (OP44) from LineController';	
	//Create Part ID
	strTempTeileId := (* YY *)	RIGHT(WORD_TO_STRING(timestructActualTime.wYear),2);				
	strTempTeileId := (* DOY *)	CONCAT(strTempTeileId,RIGHT(CONCAT('000', WORD_TO_STRING(F_GetDOYOfYearMonthDay( wYear := timestructActualTime.wYear, wMonth := timestructActualTime.wMonth, wDay := timestructActualTime.wDay ))),3));

	LC_Cavity2.getCounterValue(strTempTeileId);
	IF LC_Cavity2.comgetCounterValue.bDone THEN
		IF LC_Cavity2.comgetCounterValue.bValid THEN
			(* save the number *)
			CounterResult := LC_Cavity2.out_Data.SerialNo;
			strTempTeileId := CONCAT( strTempTeileID, RIGHT(Concat ( '00000', CounterResult),5));
			Schritt := Schritt + 2;
			SWI := TRUE;
			arrCarrierData[RtNr][RtStNr][Nest2].PartData.strTeileId:=strTempTeileId;
		ELSE
			// Error from LineController
			// create a new part 			
			//f1[feLcGetCounterValueFailed] := TRUE;

			Schritt := 1;
			SWI 	:= TRUE;	
		END_IF 			
	END_IF

72:xx.x := 'Check Serial number in LineController';

	IF NOT LC_Cavity2.out_bBusy THEN
		LC_Cavity2.in_Data.SerialNo:= arrCarrierData[RtNr][RtStNr][Nest2].PartData.strTeileId;			//+1 by each cycle
		LC_Cavity2.in_Data.TypeNo  := arrCarrierData[RtNr][RtStNr][Nest2].PartData.strTypeNr;
		LC_Cavity2.in_Data.AssyLocation := 0;
		LC_Cavity2.in_Data.OPcode := ENU_LC_OpCode.checkSNRState;
		LC_Cavity2.in_bSendTelegram := TRUE;
	END_IF

	IF LC_Cavity2.out_bBusy AND NOT LC_Cavity2.out_bError THEN
		Schritt := Schritt + 3;
		SWI := TRUE;
		LC_Cavity2.in_bSendTelegram := FALSE;
	END_IF

75: xx.x := 'Wait for result of OP15 = checkSNRState from LC';
	IF NOT LC_Cavity2.out_bBusy THEN
		IF NOT LC_Cavity2.out_bError AND LC_Cavity2.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackSucces THEN
			(* merge parts *)
			Schritt := Schritt + 10;
			SWI := TRUE;
		ELSE
			IF LC_Cavity2.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackReserved  THEN // TCP/IP-Fehler
				Schritt := 70;
				SWI := TRUE;
			
			END_IF
		END_IF
	END_IF		

85:xx.x := 'assign order to SNR';

	IF NOT LC_Cavity2.out_bBusy THEN
		LC_Cavity2.in_Data.SerialNo:= arrCarrierData[RtNr][RtStNr][Nest2].PartData.strTeileId;			//+1 by each cycle
		LC_Cavity2.in_Data.TypeNo  := DINT_TO_STRING(OrderID);
		LC_Cavity2.in_Data.OPcode := 14;
		LC_Cavity2.in_bSendTelegram := TRUE;
	END_IF

	IF LC_Cavity2.out_bBusy AND NOT LC_Cavity2.out_bError THEN
		Schritt := Schritt + 5;
		SWI := TRUE;
		LC_Cavity2.in_bSendTelegram := FALSE;
	END_IF

90: xx.x := 'Wait for result of OP14';
	IF NOT LC_Cavity2.out_bBusy THEN
		IF NOT LC_Cavity2.out_bError AND LC_Cavity2.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackSucces THEN
			(* merge parts *)
			Schritt := Schritt + 20;
			SWI := TRUE;
		ELSE
			IF LC_Cavity2.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackReserved  THEN // TCP/IP-Fehler
				Schritt := 84;
				SWI := TRUE;
			
			END_IF
		END_IF
	END_IF	
	
110:	xx.x := 'wait for feeding of the housing'; 
	IF 	AllInPos
	AND Betrieb THEN
		out_bEnablePrework:=TRUE;
		IF (uz.q AND NOT in_bOffering )THEN
			f1[feWaitOffering]	:=TRUE;	
		ELSIF in_bOffering THEN
			f1[feWaitOffering]	:=FALSE;
			Schritt := Schritt + 10;			
			SWI := TRUE;
		END_IF		
	END_IF	
	

120:	xx.x := 'MM3 Vertical -> ON (downwards)';
	IF 	AllInPos
	AND Betrieb THEN
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF		

125:	xx.x := 'MM1 MM2 Grippers -> ON (pick part)';
	IF 	AllInPos
	AND Betrieb THEN
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF		
	
130:	xx.x := 'wait for End of the housing-feeding';
	out_bReadyToTakeOver :=TRUE;
	IF 	AllInPos
	AND Betrieb THEN
		IF (uz.q AND NOT in_bOfferEnd )THEN
			f1[feWaitOfferEnd]	:=TRUE;	
		ELSIF in_bOfferEnd THEN
			f1[feWaitOfferEnd]	:=FALSE;
			Schritt := Schritt + 10;			
			SWI := TRUE;
			out_bReadyToTakeOver :=FALSE;
		END_IF
	END_IF	

	
140:	xx.x := 'MM3 Vertical -> OFF (upwards)';
	IF 	AllInPos
	AND Betrieb  THEN
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF	


150:	xx.x := 'MM4 PnP hori. Stroke -> ON (insert position)'; 
	xx.xx:= 'MM5 Operate Carrier -> ON (carrier open) ';
	out_bTakenOver :=TRUE;
	IF 	AllInPos
	AND Betrieb 
	AND NOT (ix_CavityCheck1 OR ix_CavityCheck2)
	THEN
		Schritt := Schritt + 10;
		SWI := TRUE;
		out_bTakenOver :=FALSE;
	END_IF	


160:	xx.x := 'MM3 Vertical -> ON (downwards)';
	xx.xx:= 'Waiting for Presence Check';
	IF 	AllInPos
	AND Betrieb   THEN
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF	
	
	
170:	xx.x:= 'MM5 Operate Carrier -> OFF (carrier closed) ';
	IF 	AllInPos
	AND Betrieb THEN
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF	
	
175:	xx.x := 'MM1 MM2 Grippers -> OFF (place part)';
	IF 	AllInPos
	AND Betrieb THEN
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF	


180:	xx.x := 'MM3 Vertical -> OFF (upwards)';
	IF 	AllInPos
	AND Betrieb  THEN
		arrCarrierData[RtNr][RtStNr][Nest1].PartData.StNrLast					:= MoNr*100+StNr;
		arrCarrierData[RtNr][RtStNr][Nest2].PartData.StNrLast					:= MoNr*100+StNr;
		(*One or more carriers are still empty*)
		IF ix_CavityCheck1 THEN 
			awPrecenseError_1.igut	:= TRUE; 
			arrCarrierData[RtNr][RtStNr][Nest1].PartData.Mo20_St010.bHousingInsert := TRUE; 
			arrCarrierData[RtNr][RtStNr][Nest1].PartData.teilestatus						:= srGood;
		ELSIF NOT ix_CavityCheck1 AND uz.q THEN
			awPrecenseError_1.ischl	:= TRUE; 
			arrCarrierData[RtNr][RtStNr][Nest1].PartData.teilestatus						:= srEmpty;
			arrCarrierData[RtNr][RtStNr][Nest1].PartData.StNrSchlechtGesetzt				:= StNr;
			arrCarrierData[RtNr][RtStNr][Nest1].PartData.iFehlercode						:= bcM20_St010_PresenceError_1; 
			f1[fePresenceCheck1]:=TRUE;
			BDEIncCounter( FALSE, bcM20_St010_PresenceError_1, 1, ActOrd[MPart].ord_id, MPart);
			BDEIncCounter( TRUE	, bcM20_St010_PresenceError_1, 1, ActOrd[MPart].ord_id, MPart);
		END_IF
		
		IF ix_CavityCheck2 THEN 
			awPrecenseError_2.igut	:= TRUE; 
			arrCarrierData[RtNr][RtStNr][Nest2].PartData.Mo20_St010.bHousingInsert := TRUE; 
			arrCarrierData[RtNr][RtStNr][Nest2].PartData.teilestatus						:= srGood;
		ELSIF NOT ix_CavityCheck2 AND uz.q THEN
			awPrecenseError_2.ischl	:= TRUE; 
			arrCarrierData[RtNr][RtStNr][Nest2].PartData.teilestatus						:= srEmpty;
			arrCarrierData[RtNr][RtStNr][Nest2].PartData.StNrSchlechtGesetzt				:= StNr;
			arrCarrierData[RtNr][RtStNr][Nest2].PartData.iFehlercode						:= bcM20_St010_PresenceError_2; 
			f1[fePresenceCheck2]:=TRUE;
			BDEIncCounter( FALSE, bcM20_St010_PresenceError_2, 1, ActOrd[MPart].ord_id, MPart);
			BDEIncCounter( TRUE	, bcM20_St010_PresenceError_2, 1, ActOrd[MPart].ord_id, MPart);
		END_IF
				
		(*After PresenceCheck and Data Saving*)
		IF (arrCarrierData[RtNr][RtStNr][Nest1].PartData.teilestatus = srgood AND arrCarrierData[RtNr][RtStNr][Nest2].PartData.teilestatus = srgood)
		THEN			 
			 Schritt := Schritt + 2;
			 SWI := TRUE;
		ELSE 
			 Schritt := Schritt + 1;
			 SWI := TRUE;
		END_IF
	END_IF
	
181:	xx.x := 'Waiting for ErrorReset';
	f1[fePresenceCheck1] := NOT ix_CavityCheck1;
	f1[fePresenceCheck2] := NOT ix_CavityCheck2;
	IF 	NOT f1[fePresenceCheck1] 
	AND NOT f1[fePresenceCheck2] 
	AND ix_CavityCheck1
	AND ix_CavityCheck2
	THEN
		IF ix_CavityCheck1 THEN 
			arrCarrierData[RtNr][RtStNr][Nest1].PartData.Mo20_St010.bHousingInsert := TRUE; 
			arrCarrierData[RtNr][RtStNr][Nest1].PartData.teilestatus						:= srGood;
		ELSE
			arrCarrierData[RtNr][RtStNr][Nest1].PartData.teilestatus						:= srEmpty;
		END_IF
		
		IF ix_CavityCheck2 THEN 
			arrCarrierData[RtNr][RtStNr][Nest2].PartData.Mo20_St010.bHousingInsert := TRUE; 
			arrCarrierData[RtNr][RtStNr][Nest2].PartData.teilestatus						:= srGood;
		ELSE
			arrCarrierData[RtNr][RtStNr][Nest2].PartData.teilestatus						:= srEmpty;
		END_IF
		
	 	Schritt := Schritt + 1;  //DWOCOM
		SWI := TRUE;
	END_IF
	
(*Step for Line Controller Upload*)	
182: xx.xx:= 'LineController socket ready';
	IF	NOT LC_Cavity1.out_bBusy AND arrCarrierData[RtNr][RtStNr][Nest1].PartData.teilestatus = srGood THEN

		Schritt := Schritt + 1;
		SWI := TRUE;
	ELSIF arrCarrierData[RtNr][RtStNr][Nest1].PartData.teilestatus = srEmpty THEN
		Schritt := 186;
		SWI := TRUE;
	END_IF

183:xx.x := 'Upload result to LC';
	IF (arrCarrierData[RtNr][RtStNr][Nest1].PartData.teilestatus = srGood) THEN
		LC_Cavity1.UploadStateAndResultData(	arrCarrierData[RtNr][RtStNr][Nest1].PartData.strTypeNr,
										arrCarrierData[RtNr][RtStNr][Nest1].PartData.strTeileId,
										0,(*Fail_Location*)
										0(*Fail_Type*)
									);
	ELSIF (arrCarrierData[RtNr][RtStNr][Nest1].PartData.iFehlercode = bcM20_St010_PresenceError_1) THEN
		LC_Cavity1.UploadStateAndResultData(	arrCarrierData[RtNr][RtStNr][Nest1].PartData.strTypeNr,
										arrCarrierData[RtNr][RtStNr][Nest1].PartData.strTeileId,
										bcM20_St010_PresenceError_1,(*Fail_Location*)
										LCID_FAIL_PRESENCE//LCID_FAIL_PRESENCE(*Fail_Type*) 
									);
	END_IF
	IF (LC_Cavity1.comUploadStateAndResultData.bStarted OR LC_Cavity1.comUploadStateAndResultData.bDone) THEN
		Schritt := Schritt + 2;
		SWI := TRUE;
	END_IF;	

185:xx.x := 'spare-step for Error Presence; ';
   xx.xx:= 'Reset Start; ';
	IF	AllInPos
	AND	Betrieb 
	AND NOT f1[feAwErrorPresence]
	THEN
		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF

	
186: xx.xx:= 'LineController socket ready';
	IF	NOT LC_Cavity2.out_bBusy AND arrCarrierData[RtNr][RtStNr][Nest2].PartData.teilestatus = srGood THEN

		Schritt := Schritt + 1;
		SWI := TRUE;
	ELSIF arrCarrierData[RtNr][RtStNr][Nest2].PartData.teilestatus = srEmpty THEN
		Schritt := 190;
		SWI := TRUE;
	END_IF

187:xx.x := 'Upload result to LC';
	IF (arrCarrierData[RtNr][RtStNr][Nest2].PartData.teilestatus = srGood) THEN
		LC_Cavity2.UploadStateAndResultData(	arrCarrierData[RtNr][RtStNr][Nest2].PartData.strTypeNr,
										arrCarrierData[RtNr][RtStNr][Nest2].PartData.strTeileId,
										0,(*Fail_Location*)
										0(*Fail_Type*)
									);
	ELSIF (arrCarrierData[RtNr][RtStNr][Nest2].PartData.iFehlercode = bcM20_St010_PresenceError_2) THEN
		LC_Cavity2.UploadStateAndResultData(	arrCarrierData[RtNr][RtStNr][Nest2].PartData.strTypeNr,
										arrCarrierData[RtNr][RtStNr][Nest2].PartData.strTeileId,
										bcM20_St010_PresenceError_2,(*Fail_Location*)
										LCID_FAIL_PRESENCE//LCID_FAIL_PRESENCE(*Fail_Type*)
									);
	END_IF
	IF (LC_Cavity2.comUploadStateAndResultData.bStarted OR LC_Cavity2.comUploadStateAndResultData.bDone) THEN
		Schritt := Schritt + 2;
		SWI := TRUE;
	END_IF;	

189:xx.x := 'spare-step for Error Presence; ';
   xx.xx:= 'Reset Start; ';
	IF	AllInPos
	AND	Betrieb 
	AND NOT f1[feAwErrorPresence]
	THEN
		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF	
	

190:	xx.x := 'MM4 PnP hori. Stroke -> OFF (home position)'; 
	IF 	AllInPos
	AND Betrieb  THEN
		(* -> station´s work on roundtable has ended *)
		bStart := FALSE;
		Schritt := 0;
		SWI := TRUE;
	END_IF		
		
END_CASE

awPrecenseError_1( cntmax	:= FehlStop[OrderNr] );
IF awPrecenseError_1.fehler THEN f1[fePresenceCheck1] := TRUE; END_IF
awPrecenseError_1.igut	:= FALSE; 
awPrecenseError_1.ischl	:= FALSE; 

awPrecenseError_2( cntmax	:= FehlStop[OrderNr] );
IF awPrecenseError_2.fehler THEN f1[fePresenceCheck2] := TRUE; END_IF
awPrecenseError_2.igut	:= FALSE; 
awPrecenseError_2.ischl	:= FALSE; 

(* ____________________ *)
(* -- React to Steps -- *)
IF NOT ManualRun THEN
	
	zyl0_pnp_grip1.on 		:= 	( (Schritt >= 125) AND (Schritt < 175) );
							
	zyl0_pnp_grip2.on 		:= 	( (Schritt >= 125) AND (Schritt < 175) );
							
	zyl2_pnp_v_stroke.on 	:= 	( (Schritt >= 120) AND (Schritt < 140) )
							OR	( (Schritt >= 160) AND (Schritt < 180) );
							
	zyl2_pnp_h_stroke.on 	:= 	( (Schritt >= 150) AND (Schritt < 190) );
							
	zyl2_operate_carrier.on 	:= 	( (Schritt >= 150) AND (Schritt < 170) );
							
END_IF



(* ____________________ *)
(* -- Error Messages by Steps -- *)



(* _____________________________________ *)
(* -- Stop Roundtable Condition-Based -- *)
IF  	((zyl2_pnp_v_stroke.b OR zyl2_pnp_v_stroke.y OR NOT zyl2_pnp_v_stroke.a )
	AND  (zyl2_pnp_h_stroke.b OR zyl2_pnp_h_stroke.y OR NOT zyl2_pnp_h_stroke.a ))
	OR  (zyl2_operate_carrier.b OR zyl2_operate_carrier.y OR NOT zyl2_operate_carrier.a)
 THEN 
	F_ResetFrgRtWithText(TRUE, RtNr, RtStNr, '020MM3 §Vertical§ or 020MM4 §Horizontal§ or 020MM5 §Operate Carrier§ §not§ §in§ §base-pos.§', io_RtFreigabe); //DWOCOM too long should be renamed
END_IF


(* ______________________________________ *)
(* -- Report Station is working on RT  -- *)
io_RtStarts := CSETBIT32(io_RtStarts, RtStNr, bStart);


(* _________________ *)
(* -- Set outputs -- *)

IF ManualRun THEN (* assign cylinderoutputs .y (by "AND Bedieneinheit.ventile_ok") *)
	_010_M20_MP1_WZ6_QM1_MB1         	:=		zyl0_pnp_grip1.y AND Bedieneinheit.ventile_ok;
	_010_M20_MP1_WZ6_QM1_MB2         	:=	not zyl0_pnp_grip1.y AND Bedieneinheit.ventile_ok;
	_010_M20_MP1_WZ6_QM2_MB1         	:=		zyl0_pnp_grip2.y AND Bedieneinheit.ventile_ok;
	_010_M20_MP1_WZ6_QM2_MB2         	:=	not zyl0_pnp_grip2.y AND Bedieneinheit.ventile_ok;
	_010_M20_MP1_WZ6_QM3_MB1         	:=		zyl2_pnp_v_stroke.y AND Bedieneinheit.ventile_ok;
	_010_M20_MP1_WZ6_QM3_MB2         	:=	not zyl2_pnp_v_stroke.y AND Bedieneinheit.ventile_ok;
	_010_M20_MP1_WZ6_QM4_MB1         	:=		zyl2_pnp_h_stroke.y AND Bedieneinheit.ventile_ok;
	_010_M20_MP1_WZ6_QM4_MB2         	:=	not zyl2_pnp_h_stroke.y AND Bedieneinheit.ventile_ok;
	_010_M20_MP1_WZ6_QM5_MB1         	:=		zyl2_operate_carrier.y AND Bedieneinheit.ventile_ok;
	_010_M20_MP1_WZ6_QM5_MB2  			:=	not zyl2_operate_carrier.y AND Bedieneinheit.ventile_ok;
ELSE (* assign cylinderoutputs .on (by "AND Bedieneinheit.ventile_ok") *)
	_010_M20_MP1_WZ6_QM1_MB1         	:=		zyl0_pnp_grip1.on AND Bedieneinheit.ventile_ok;
	_010_M20_MP1_WZ6_QM1_MB2         	:=	not zyl0_pnp_grip1.on AND Bedieneinheit.ventile_ok;
	_010_M20_MP1_WZ6_QM2_MB1         	:=		zyl0_pnp_grip2.on AND Bedieneinheit.ventile_ok;
	_010_M20_MP1_WZ6_QM2_MB2         	:=	not zyl0_pnp_grip2.on AND Bedieneinheit.ventile_ok;
	_010_M20_MP1_WZ6_QM3_MB1         	:=		zyl2_pnp_v_stroke.on AND Bedieneinheit.ventile_ok;
	_010_M20_MP1_WZ6_QM3_MB2         	:=	not zyl2_pnp_v_stroke.on AND Bedieneinheit.ventile_ok;
	_010_M20_MP1_WZ6_QM4_MB1         	:=		zyl2_pnp_h_stroke.on AND Bedieneinheit.ventile_ok;
	_010_M20_MP1_WZ6_QM4_MB2         	:=	not zyl2_pnp_h_stroke.on AND Bedieneinheit.ventile_ok;
	_010_M20_MP1_WZ6_QM5_MB1         	:=		zyl2_operate_carrier.on AND Bedieneinheit.ventile_ok;
	_010_M20_MP1_WZ6_QM5_MB2  			:=	not zyl2_operate_carrier.on AND Bedieneinheit.ventile_ok;
END_IF

]]></ST>
    </Implementation>
    <LineIds Name="Mo20_St10_transfer_the_housing">
      <LineId Id="589" Count="4" />
      <LineId Id="789" Count="2" />
      <LineId Id="960" Count="0" />
      <LineId Id="959" Count="0" />
      <LineId Id="792" Count="8" />
      <LineId Id="154" Count="0" />
      <LineId Id="595" Count="19" />
      <LineId Id="175" Count="7" />
      <LineId Id="615" Count="0" />
      <LineId Id="184" Count="0" />
      <LineId Id="186" Count="0" />
      <LineId Id="2708" Count="2" />
      <LineId Id="616" Count="0" />
      <LineId Id="2712" Count="1" />
      <LineId Id="2711" Count="0" />
      <LineId Id="2715" Count="0" />
      <LineId Id="2714" Count="0" />
      <LineId Id="2716" Count="0" />
      <LineId Id="617" Count="0" />
      <LineId Id="188" Count="5" />
      <LineId Id="618" Count="1" />
      <LineId Id="196" Count="0" />
      <LineId Id="1492" Count="0" />
      <LineId Id="1494" Count="0" />
      <LineId Id="1496" Count="3" />
      <LineId Id="1510" Count="2" />
      <LineId Id="1504" Count="1" />
      <LineId Id="2033" Count="0" />
      <LineId Id="1493" Count="0" />
      <LineId Id="1691" Count="0" />
      <LineId Id="1693" Count="0" />
      <LineId Id="1709" Count="8" />
      <LineId Id="2032" Count="0" />
      <LineId Id="1718" Count="1" />
      <LineId Id="1721" Count="0" />
      <LineId Id="1744" Count="9" />
      <LineId Id="1779" Count="0" />
      <LineId Id="2031" Count="0" />
      <LineId Id="1720" Count="0" />
      <LineId Id="1755" Count="1" />
      <LineId Id="1780" Count="10" />
      <LineId Id="2029" Count="0" />
      <LineId Id="1791" Count="0" />
      <LineId Id="2034" Count="2" />
      <LineId Id="2059" Count="11" />
      <LineId Id="1828" Count="0" />
      <LineId Id="1754" Count="0" />
      <LineId Id="1491" Count="0" />
      <LineId Id="210" Count="0" />
      <LineId Id="1863" Count="0" />
      <LineId Id="1865" Count="2" />
      <LineId Id="4350" Count="2" />
      <LineId Id="6893" Count="1" />
      <LineId Id="7915" Count="0" />
      <LineId Id="6895" Count="33" />
      <LineId Id="4610" Count="0" />
      <LineId Id="620" Count="1" />
      <LineId Id="221" Count="1" />
      <LineId Id="1868" Count="3" />
      <LineId Id="223" Count="10" />
      <LineId Id="622" Count="1" />
      <LineId Id="1138" Count="2" />
      <LineId Id="239" Count="0" />
      <LineId Id="241" Count="3" />
      <LineId Id="627" Count="1" />
      <LineId Id="247" Count="7" />
      <LineId Id="6285" Count="0" />
      <LineId Id="255" Count="2" />
      <LineId Id="5170" Count="0" />
      <LineId Id="1883" Count="0" />
      <LineId Id="260" Count="1" />
      <LineId Id="6274" Count="1" />
      <LineId Id="263" Count="0" />
      <LineId Id="6236" Count="8" />
      <LineId Id="6270" Count="0" />
      <LineId Id="6272" Count="0" />
      <LineId Id="6245" Count="4" />
      <LineId Id="6277" Count="0" />
      <LineId Id="6250" Count="2" />
      <LineId Id="6278" Count="0" />
      <LineId Id="6253" Count="1" />
      <LineId Id="6279" Count="1" />
      <LineId Id="6255" Count="0" />
      <LineId Id="6257" Count="4" />
      <LineId Id="6281" Count="0" />
      <LineId Id="6262" Count="4" />
      <LineId Id="6235" Count="0" />
      <LineId Id="6234" Count="0" />
      <LineId Id="264" Count="10" />
      <LineId Id="276" Count="7" />
      <LineId Id="7875" Count="0" />
      <LineId Id="7877" Count="0" />
      <LineId Id="7909" Count="0" />
      <LineId Id="7914" Count="0" />
      <LineId Id="7913" Count="0" />
      <LineId Id="7878" Count="0" />
      <LineId Id="7910" Count="0" />
      <LineId Id="7879" Count="1" />
      <LineId Id="7882" Count="8" />
      <LineId Id="7876" Count="0" />
      <LineId Id="7892" Count="0" />
      <LineId Id="7894" Count="5" />
      <LineId Id="7905" Count="2" />
      <LineId Id="7893" Count="0" />
      <LineId Id="5672" Count="0" />
      <LineId Id="6929" Count="14" />
      <LineId Id="7277" Count="0" />
      <LineId Id="6944" Count="5" />
      <LineId Id="6586" Count="0" />
      <LineId Id="6968" Count="0" />
      <LineId Id="6970" Count="5" />
      <LineId Id="6587" Count="0" />
      <LineId Id="6969" Count="0" />
      <LineId Id="6950" Count="7" />
      <LineId Id="6976" Count="0" />
      <LineId Id="8163" Count="0" />
      <LineId Id="6958" Count="9" />
      <LineId Id="4612" Count="0" />
      <LineId Id="7221" Count="0" />
      <LineId Id="7223" Count="53" />
      <LineId Id="8680" Count="0" />
      <LineId Id="8682" Count="27" />
      <LineId Id="7522" Count="0" />
      <LineId Id="8681" Count="0" />
      <LineId Id="7523" Count="40" />
      <LineId Id="8164" Count="0" />
      <LineId Id="7564" Count="64" />
      <LineId Id="7222" Count="0" />
      <LineId Id="8710" Count="0" />
      <LineId Id="8712" Count="27" />
      <LineId Id="8711" Count="0" />
      <LineId Id="4341" Count="0" />
      <LineId Id="1889" Count="0" />
      <LineId Id="1891" Count="0" />
      <LineId Id="1893" Count="0" />
      <LineId Id="4004" Count="0" />
      <LineId Id="2498" Count="0" />
      <LineId Id="2500" Count="0" />
      <LineId Id="2502" Count="1" />
      <LineId Id="2506" Count="0" />
      <LineId Id="2504" Count="0" />
      <LineId Id="2501" Count="0" />
      <LineId Id="1885" Count="1" />
      <LineId Id="1896" Count="1" />
      <LineId Id="1899" Count="3" />
      <LineId Id="1887" Count="0" />
      <LineId Id="3790" Count="1" />
      <LineId Id="3793" Count="3" />
      <LineId Id="1903" Count="1" />
      <LineId Id="1906" Count="0" />
      <LineId Id="3389" Count="0" />
      <LineId Id="1908" Count="1" />
      <LineId Id="2507" Count="4" />
      <LineId Id="1911" Count="0" />
      <LineId Id="3390" Count="0" />
      <LineId Id="2512" Count="0" />
      <LineId Id="1905" Count="0" />
      <LineId Id="2497" Count="0" />
      <LineId Id="1912" Count="0" />
      <LineId Id="1914" Count="0" />
      <LineId Id="1916" Count="3" />
      <LineId Id="1913" Count="0" />
      <LineId Id="1920" Count="1" />
      <LineId Id="1927" Count="0" />
      <LineId Id="3798" Count="0" />
      <LineId Id="1929" Count="0" />
      <LineId Id="3588" Count="0" />
      <LineId Id="1930" Count="0" />
      <LineId Id="5442" Count="1" />
      <LineId Id="1931" Count="1" />
      <LineId Id="3589" Count="0" />
      <LineId Id="1922" Count="2" />
      <LineId Id="1933" Count="0" />
      <LineId Id="2984" Count="0" />
      <LineId Id="1935" Count="1" />
      <LineId Id="5168" Count="1" />
      <LineId Id="1946" Count="0" />
      <LineId Id="4724" Count="1" />
      <LineId Id="1947" Count="0" />
      <LineId Id="1949" Count="3" />
      <LineId Id="1939" Count="0" />
      <LineId Id="3799" Count="0" />
      <LineId Id="3801" Count="0" />
      <LineId Id="3803" Count="3" />
      <LineId Id="3800" Count="0" />
      <LineId Id="2071" Count="0" />
      <LineId Id="1940" Count="0" />
      <LineId Id="1953" Count="0" />
      <LineId Id="1955" Count="1" />
      <LineId Id="5171" Count="0" />
      <LineId Id="5043" Count="2" />
      <LineId Id="5172" Count="6" />
      <LineId Id="5053" Count="6" />
      <LineId Id="5179" Count="6" />
      <LineId Id="5067" Count="18" />
      <LineId Id="9237" Count="0" />
      <LineId Id="9236" Count="0" />
      <LineId Id="5086" Count="0" />
      <LineId Id="8987" Count="1" />
      <LineId Id="5087" Count="0" />
      <LineId Id="8421" Count="4" />
      <LineId Id="8420" Count="0" />
      <LineId Id="8426" Count="0" />
      <LineId Id="8413" Count="0" />
      <LineId Id="8415" Count="0" />
      <LineId Id="8412" Count="0" />
      <LineId Id="8416" Count="3" />
      <LineId Id="5088" Count="5" />
      <LineId Id="5096" Count="3" />
      <LineId Id="8427" Count="2" />
      <LineId Id="5100" Count="2" />
      <LineId Id="5186" Count="15" />
      <LineId Id="5119" Count="3" />
      <LineId Id="7629" Count="1" />
      <LineId Id="5125" Count="7" />
      <LineId Id="5135" Count="3" />
      <LineId Id="8430" Count="2" />
      <LineId Id="5139" Count="2" />
      <LineId Id="5202" Count="15" />
      <LineId Id="5158" Count="9" />
      <LineId Id="1941" Count="1" />
      <LineId Id="1960" Count="1" />
      <LineId Id="1963" Count="1" />
      <LineId Id="1967" Count="1" />
      <LineId Id="1965" Count="1" />
      <LineId Id="1943" Count="1" />
      <LineId Id="305" Count="1" />
      <LineId Id="2986" Count="2" />
      <LineId Id="2985" Count="0" />
      <LineId Id="2989" Count="3" />
      <LineId Id="307" Count="0" />
      <LineId Id="2993" Count="0" />
      <LineId Id="634" Count="1" />
      <LineId Id="310" Count="0" />
      <LineId Id="1973" Count="0" />
      <LineId Id="312" Count="0" />
      <LineId Id="1974" Count="0" />
      <LineId Id="1971" Count="0" />
      <LineId Id="1975" Count="2" />
      <LineId Id="1979" Count="0" />
      <LineId Id="1981" Count="1" />
      <LineId Id="1984" Count="1" />
      <LineId Id="314" Count="0" />
      <LineId Id="2003" Count="2" />
      <LineId Id="2008" Count="0" />
      <LineId Id="2006" Count="0" />
      <LineId Id="2013" Count="0" />
      <LineId Id="2007" Count="0" />
      <LineId Id="316" Count="0" />
      <LineId Id="1308" Count="2" />
      <LineId Id="3590" Count="1" />
      <LineId Id="3191" Count="0" />
      <LineId Id="1311" Count="1" />
      <LineId Id="631" Count="0" />
      <LineId Id="323" Count="3" />
      <LineId Id="632" Count="0" />
      <LineId Id="327" Count="0" />
      <LineId Id="633" Count="0" />
      <LineId Id="329" Count="2" />
      <LineId Id="2717" Count="8" />
      <LineId Id="332" Count="0" />
      <LineId Id="334" Count="0" />
      <LineId Id="2726" Count="8" />
      <LineId Id="335" Count="0" />
      <LineId Id="337" Count="1" />
      <LineId Id="9" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>