<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.16">
  <POU Name="Mo20_St20_plasma_cleaning_for_housing" Id="{b3a9a508-9a34-4892-89fb-60f503f21c57}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK Mo20_St20_plasma_cleaning_for_housing
(*--------------------------------------------------------------------------------------
Preh IMA Automation Amberg GmbH

<DESC>
=INSERT DESCRIPTION FROM WORKFLOWPLAN=
</DESC>


<CHANGES>

At every change add date, version´s number, abbr. of name and describe change!

Date 		|	Version	|	Author	|	change description		
--------------------------------------------------------------------------------
2017-11-06	|	1.00	|	DWO		|	initial version

</CHANGES>
<VERSION>
1.00
</VERSION>

<DEPENDENCIES>
;
</DEPENDENCIES>



 -- overview of areas for steps --
Steps [000..099]: 	Whatever Block
Steps [100..199]:	Next Whatever Block

  
----------------------------------------------------------------------------------------*)



(* _____________________ *)
(* -- Standard-Inputs -- *)
VAR_INPUT
	OrderNr: 			INT :=E_TAB_MO_20_ST_20;		(* Nr. Actorder *)
	MoNr: 				INT:= 020;		(* Module-Number *)
	StNr: 				INT:= 20;		(* Stationsnumber *)
	BedienEinheit: 		ZENTR_DATA;		(* Central *)
	FaultID: 			BYTE := 0;		(* ID for Error Array *)
	DisplayNr: 			INT := 1;		(* Number of Textdisplay *)
	MPart: 				INT := 1;		(* Machinepart *)
	in_InitChainTxt:	STRING(39);		(* String for Step Chain Diagnosis *)
	in_sKebaKurz:		STRING(gcKebaStKurzLen) := '1234567890'; (* optional - can also be assigned in initialisation paragraph *)
	in_sKebaBez:		STRING(gcKebaStBezLen) 	:= '11111111112222222222333333333344444444445555555555'; (* optional - can also be assigned in initialisation paragraph *)
END_VAR


(* __________________ *)
(* -- RT-Interface -- *)
VAR_INPUT
	RtNr:				INT := 02;
	RtStNr:				SINT := 02;
	RtStartimpuls:		BOOL:=FALSE;	
END_VAR

VAR_IN_OUT
	//io_RtRegister:		ARRAY[1..8] OF ARRAY [1..2] OF  DataTeil; // info for all parts within roundtable - the part for the station is accessed at [RtStNr]
	io_RtStarts:		DWORD; // bit array (dword) representing station is working on roundtable (flow based)
	io_RtFreigabe:		DWORD; // bit array (dword) representing station is giving permission for table to move (state based)
	io_RtFault:			DWORD; // bit array (dword) representing error at RtStNr of roundtable
	io_RtWaiting:		DWORD; // bit array (dword) representing waiting at RtStNr of roundtable
	io_RtWarning:		DWORD; // bit array (dword) representing warning at RtStNr of roundtable
END_VAR


(* ________________________ *)
(* -- Standard-Variables -- *)
VAR PERSISTENT
	SWI: 				BOOL := FALSE;	(* Impulse step is changing forward *)
	SWR:				BOOL := FALSE;	(* Impulse step is changing backwards *)
	Schritt: 			INT := 0;		(* Current step *)
	UZ: 				TON;			(* watchtime *)
	Fault: 				BOOL;			(* Stations Error *)
	Waiting:			BOOL;			(* Station Waiting *)
	Warning:			BOOL;			(* Station Warning *)
	Betrieb: 			BOOL;			(* Enable Steps *)
	StatEin: 			BOOL;			(* Station on *)
	AllInPos: 			BOOL;			(* all cylinders in position and not actuated manually *)
	Active:				BOOL;			(* stepchain is marked as active *)
	Transport:			BOOL;			(* manual transport is enabled *)
	InitRun:			BOOL;			(* goto homepos is enabled *)
	CycleRun:			BOOL;			(* mode for single cycle is enabled *)
	ManualRun:			BOOL;			(* move cylinders manually is enabled *)
	BackwardsRun:		BOOL;			(* backwards run is enabled *)
	tonSeitSwi:			TON;			(* time since last change of step *)
	tonSeitAllInPos:	TON;			(* time since AllInPos has become TRUE *)
	i:					INT;			(* index-runner for loops *)
	xx:					FB_StepTracker;	(* auto record steps *)
	StatString:			STRING(10);		(* '+MM=SS' *)
	StartCondition:		BOOL;			(* condition for starting station *)
	bStart:				BOOL;			(* station's work on roundtable is running *)
	NestNr:				INT;			(* number of nest within fixation *)
	
	rtTestPart:			r_trig;
	iCounter:			INT;			
END_VAR

VAR CONSTANT	
Nest1						:INT:=1;
Nest2						:INT:=2;
END_VAR

(* ___________________ *)
(* -- Error-Array 1 -- *)
VAR
	Errors1: ARRAY[1..ErrMaxBits] OF ERRDAT := [
	(* Error 01 *)		(Prio := ErrZyl, Nr:= 1425, Txt:='=020-EZ1 '),
	(* Error 02 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/02            '),
	(* Error 03 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/03            '),
	(* Error 04 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/04            '),
	(* Error 05 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/05            '),
	(* Error 06 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/06            '),
	(* Error 07 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/07            '),
	(* Error 08 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/08            '),
	(* Error 09 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/09            '),
	(* Error 10 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/10            '),
	(* Error 11 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/11            '),
	(* Error 12 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/12            '),
	(* Error 13 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/13            '),
	(* Error 14 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/14            '),
	(* Error 15 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/15            '),
	(* Error 16 *)		(Prio := ErrZyl, Nr:= 510, Txt:='/16            ')];
	f1: ARRAY [1..ErrMaxBits] OF BOOL := [ErrMaxBits(FALSE)];
	Fehler1: ERRORANZ;




END_VAR

VAR CONSTANT
feawErrorCleaning			:INT:= 01;
END_VAR



(* _____________________ *)
(* -- Local Variables -- *)
VAR PERSISTENT

	(* == Cylinders == *)
	zyl0_grip1				:ZYL0; (* MM1 *)
	
	zyl0_grip2				:ZYL0; (* MM2 *)
	
	zyl2_vertical_stroke	:ZYL2; (* MM3 *)
	ix_vertical_strokeA		:BOOL:=FALSE;
	ix_vertical_strokeB		:BOOL:=FALSE;
	
	zyl2_operate_Carrier	:ZYL2; (* MM4 *)
	ix_Operate_CarrierA		:BOOL:=FALSE;
	ix_Operate_CarrierB		:BOOL:=FALSE;
	
	zyl2_appr_h_stroke		:ZYL2; (* MM5 *)
	ix_appr_h_strokeA		:BOOL:=FALSE;
	ix_appr_h_strokeB		:BOOL:=FALSE;
	
	
	(* ----- P1-TA1 Horizontalhub ------ *)	
	ix_axX_P_Stop			:BOOL:=FALSE;
	ix_axX_N_Stop			:BOOL:=FALSE;
	ix_axX_Ready			:BOOL:=true;
	ix_axX_STO_aktive		:BOOL:=FALSE;	
	axXID					:USINT:=10;
	
	ix_axX_ServoBereit		:BOOL:=FALSE;
	ix_axX_MotionComplete	:BOOL:=FALSE;
	qx_axX_ReglerFreigabe	:BOOL:=FALSE;
	qx_axX_EndstufeFreigabe	:BOOL:=FALSE;
	
	(* position *)
	lraxXSpeedPositioning			:LREAL:=200.0;
	lraxXSpeedPositioning_Moving	:LREAL:=200.0;		//DWOCOM JUST FOR TEST
	lraxXSpeedPositioning_Cleaning	:LREAL:=100.0;		//DWOCOM JUST FOR TEST
	lraxXWorkPos			:LREAL:=93.5;
	lraxXHomePos			:LREAL:=0.0;
	lraxXmittelPos			:LREAL:=58.0;		//reserve
	
	SchrittaxJumpBack		:INT:=0;
	_baxJumpBackDemanded	:BOOL:=FALSE;		//requirment for JumpBack
	_bStepBackAllowed		:BOOL:=FALSE;
	_bMoveAxisAllowed		:BOOL:=FALSE;
	_bWorkAreaToMoveAllowed		:BOOL:=FALSE;
	_bHomeAreaToMoveAllowed		:BOOL:=FALSE;

	(* PlasmaTreat *)
	bySelectedRecipe		:BYTE;
	bCleanBackwardsToo		:BOOL;							// TRUE  => Clean Twice => Forwards (Start->Stop) and Backwards (Stop->Start)
	
	bCleaningSuccesful		:BOOL:=TRUE;
	ixPlasma_ESTOP_OK		:BOOL:=FALSE;
	ixPlasma_Ready			:BOOL:=FALSE;
	ixPlasma_Error			:BOOL:=FALSE;
	ixPlasma_Warning		:BOOL:=FALSE;
	ixPlasma_OK				:BOOL:=FALSE;
	qx_Plasma_Generator_EIN	:BOOL:=FALSE;
	qx_Plasma_Generator_AUS	:BOOL:=FALSE;
	qx_Plasma_Quittirung_Str:BOOL:=FALSE;
	qx_Plasma_Intermitting	:BOOL:=FALSE;
END_VAR




(* _____________________ *)
(* -- Function Blocks -- *)
VAR

awErrorCleaning			:AWFEHLER;		//X-Times Error

EZ1_plasma				:FB_Plasmatreat_PlasmaCleaning;

axX						:FB_Achse_mit_Keba;

END_VAR


(* ____________________ *)
(* -- LineController -- *)
VAR
	LC_Cavity1					:FB_LcStationCommandHandler;
	LC_Cavity2					:FB_LcStationCommandHandler;
	TypeNo						:STRING(40);
	DataIndex					:UDINT := 1;
	udiIndex1						:UDINT;
	DataIndex2						:UDINT;
END_VAR

VAR PERSISTENT
	OutUserData1					:ARRAY[1..100] OF BYTE;
	InUserData1					:ARRAY[1..100] OF BYTE;
	OutUserData2					:ARRAY[1..100] OF BYTE;
	InUserData2				:ARRAY[1..100] OF BYTE;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[(* ____________________ *)
(* -- Initialisation -- *)
IF neustart OR g_bOnlineChange THEN
	StatString 		:= RIGHT(CONCAT( '000',INT_TO_STRING(StNr) ),3); (* three digits station's prefix is being created automatically for station *)
	in_InitChainTxt := CONCAT( StatString, ' Plasma §Cleaning§' );
	in_sKebaKurz	:= CONCAT( StatString, 'P.Clean'); // 3+7 digits
	in_sKebaBez		:= in_InitChainTxt;
END_IF


KebaInitStation(
	Panelnummer		:= gKebaAktPanel,
	Aktiv			:= TRUE,
	Kurzbezeichnung	:= in_sKebaKurz,
	Bezeichnung		:= in_sKebaBez,
	ManuellAktiv	:= TRUE,
	RueckwaertsAktiv:= FALSE,
	GsAktiv			:= FALSE,
);


(* ________________________ *)
(* == Drive Dimensioning From FCT== *)

(* -- Data ML1-Axis ==53=020TA1 --
	Controller	CMMP-AS-C2-3A-M3
	Motor		EMMS-AS-70-M-LS-TS
	Axis		EGSL-BS-45-200-10P
	Gear Ratio 1 : 1

	Application Environment
    Total LOAD M					= 1.9 KG
	
	Motor Basic
	Maximum Current	I_max			= 1.60 A
	Rated Current I_n				= 0.63 A
	
	Axis General Limitations
	max. Velocity v_max				= 800.00 mm/s
	Shutdown Following Error 		= 20 mm
	Overspeed Protection I_prot		= 1400 mm/s
	
	Axis Stop Decelerations
	Deceleration a_max				= 25.0 m/s²
	
	Emergency-Stop-Ramp
    t_min = v_max / a_max      800 mm/s / 25 m/s² =   32.0 ms
*)


(* _______________________________________ *)
(* -- Entry for Step Sequence Diagnosis -- *)
InitChain(
	Step 			:= Schritt,
	InitialState 	:= TRUE,
	Fault 			:= Fault,
	Waiting 		:= Waiting,
	Warning 		:= Warning,
	AllInPos 		:= AllInPos,
	RunOpenDoor 	:= TRUE,
	Txt 			:= in_InitChainTxt,
	BedienEinheit 	:= BedienEinheit,
	Active 			:= Active,
	Transport 		:= Transport,
	InitRun 		:= InitRun,
	CycleRun 		:= CycleRun,
	ManualRun 		:= ManualRun,
	BackwardsRun 	:= BackwardsRun);
InitRun := FALSE;


(* _______________ *)
(* -- Parameter -- *)
StatEin 	:= ActOrd[MPart].ord_stat[OrderNr].sd_ein;

(*TA1 test parameter*)
//lraxXWorkPos			:=90.5;					//90					//60.77
//lraxXHomePos			:=1.23;						//1.23					//-28
//lraxXmittelPos			:=51.0;					//50.0					//20.77

(* ____________ *)
(* -- Inputs -- *)
(*Axis Festo Input*)
ix_axX_P_Stop			:=_020_M20_MP1_BG1_P;
ix_axX_N_Stop			:=_020_M20_MP1_BG1_N;
ix_axX_Ready			:=_020_M20_P1_TA1_X1_24;
ix_axX_MotionComplete	:=_020_M20_P1_TA1_X1_12;
ix_axX_STO_aktive		:=_020_M20_P1_TA1_X40;

(*Plasma Input*)
ixPlasma_ESTOP_OK		:=_020_M20_MP1_EZ1_X40_2D;
ixPlasma_Ready			:=_020_M20_MP1_EZ1_X40_4D;
ixPlasma_Error			:=_020_M20_MP1_EZ1_X40_6D;
ixPlasma_Warning		:=_020_M20_MP1_EZ1_X40_8D;
ixPlasma_OK				:=_020_M20_MP1_EZ1_X40;


(*Cylinder Input*)
ix_vertical_strokeA		:=_020_M20_MP1_BG3_A;
ix_vertical_strokeB		:=_020_M20_MP1_BG3_B;

ix_Operate_CarrierA		:=_020_M20_MP1_BG4_A;
ix_Operate_CarrierB		:=_020_M20_MP1_BG4_B;

ix_appr_h_strokeA		:=_020_M20_MP1_BG5_A;
ix_appr_h_strokeB		:=_020_M20_MP1_BG5_B;



(* _______________________ *)
(* -- Timer / Watchdogs -- *)
UZ( IN:= NOT SWI AND BedienEinheit.grundbed, PT:= T#5s );
tonSeitSwi( IN := NOT SWI AND Bedieneinheit.grundbed, PT := t#30d );
tonSeitAllInPos( IN := AllInPos AND Bedieneinheit.grundbed, PT := T#30D );

(* _______________ *)
(* -- Cylinders -- *)


zyl0_grip1(
	enable_man	:= Bedieneinheit.ventile_ok, 
	FNrMan		:= 605, 
	on_vz		:= T#100MS, 
	off_vz		:= T#100MS, 
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '1',
	ID			:= FaultId,
	Bild		:= picGreifermodul, 
	BildB		:= picGreifermodulInv,
 );

zyl0_grip2(
	enable_man	:= Bedieneinheit.ventile_ok, 
	FNrMan		:= 605, 
	on_vz		:= T#100MS, 
	off_vz		:= T#100MS, 
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '2',
	ID			:= FaultId,
	Bild		:= picGreifermodul, 
	BildB		:= picGreifermodulInv,
 );


 zyl2_vertical_stroke(
	grundbed	:= Bedieneinheit.grundbed,
	a			:= ix_vertical_strokeA,
	b			:= ix_vertical_strokeB,
	enable_man	:= Bedieneinheit.ventile_ok,
	FNr			:= 211,
	FNrMan		:= 611,
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '3',
	ID			:= FaultId,
	Bild		:= picStandard,
	BildB		:= picStandardInv,
);
 
    
zyl2_operate_Carrier(
	grundbed	:= Bedieneinheit.grundbed,
	a			:= ix_Operate_CarrierA,
	b			:= ix_Operate_CarrierB,
	enable_man	:= Bedieneinheit.ventile_ok,
	FNr			:= 245,
	FNrMan		:= 645,
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '4',
	ID			:= FaultId,
	Bild		:= picStandard,
	BildB		:= picStandardInv,
);

zyl2_appr_h_stroke(
	grundbed	:= Bedieneinheit.grundbed,
	a			:= ix_appr_h_strokeA,
	b			:= ix_appr_h_strokeB,
	enable_man	:= Bedieneinheit.ventile_ok,
	FNr			:= 210,
	FNrMan		:= 610,
	FAnz		:= DisplayNr,
	StNr		:= StatString,
	ZylNr		:= '5',
	ID			:= FaultId,
	Bild		:= picStandard,
	BildB		:= picStandardInv,
);


AllInPos 		:=	zyl0_grip1.pos
				AND zyl0_grip2.pos
				AND	zyl2_vertical_stroke.pos
				AND zyl2_operate_Carrier.pos
				AND zyl2_appr_h_stroke.pos;

			
(* _____________________ *)
(* -- Line Controller -- *)
LC_Cavity1.in_Data.OutUserData := ADR(OutUserData1);
LC_Cavity1.in_Data.OutUserData_BufferSize := SIZEOF(OutUserData1);
LC_Cavity1.in_Data.InUserData  := ADR(InUserData1);
LC_Cavity1.in_Data.InUserData_Anzahl_Byte := SIZEOF(InUserData1);
LC_Cavity1(
		MoNr				:= MoNr, 
		StNr				:= StNr, 
		FaultID				:= FaultID, 
		DisplayNr			:= DisplayNr, 
		in_strBMK			:= 'LC', 
		in_bConnect			:= BedienEinheit.notaus_ok, 
		in_bEnableLog		:= TRUE, 
		in_sRemoteHost		:= IP_LineController, 
		in_uiRemotePort		:= 20201,//INT_TO_UINT(MoNr * 10000 + StNr + Nest1),
		in_uiStationID		:= 202,
		in_uiStationSubID	:= 1, 
		in_bTelegram64kB	:= FALSE, 
		in_bTypbeschrUebertr:= FALSE
);

LC_Cavity2.in_Data.OutUserData := ADR(OutUserData2);
LC_Cavity2.in_Data.OutUserData_BufferSize := SIZEOF(OutUserData2);
LC_Cavity2.in_Data.InUserData  := ADR(InUserData2);
LC_Cavity2.in_Data.InUserData_Anzahl_Byte := SIZEOF(InUserData2);
LC_Cavity2(
		MoNr				:= MoNr, 
		StNr				:= StNr, 
		FaultID				:= FaultID, 
		DisplayNr			:= DisplayNr, 
		in_strBMK			:= 'LC', 
		in_bConnect			:= BedienEinheit.notaus_ok, 
		in_bEnableLog		:= TRUE, 
		in_sRemoteHost		:= IP_LineController, 
		in_uiRemotePort		:= 20202,//INT_TO_UINT(MoNr * 10000 + StNr + Nest2),
		in_uiStationID		:= 202,
		in_uiStationSubID	:= 2, 
		in_bTelegram64kB	:= FALSE, 
		in_bTypbeschrUebertr:= FALSE
);	
				
(* -- Treat Errors -- *)
Fehler1( ID:= FaultID, FAnz:= DisplayNr, EF:= Errors1, F:= f1 );

Fault			:=	zyl0_grip1.err				(* Error´s of function blocks *)
				OR  zyl0_grip2.err
				OR 	zyl2_vertical_stroke.err
				OR  zyl2_operate_Carrier.err
				OR  zyl2_appr_h_stroke.err
				OR	axX.out_bFault
				OR	EZ1_plasma.ixError;
				
Warning := FALSE;
Waiting := FALSE;
FOR i := 1 TO ErrMaxBits BY 1 DO
	IF f1[i] THEN
		IF 		Errors1[i].Prio <= ErrZyl 			THEN Fault := TRUE;
		ELSIF	Errors1[i].Prio <= ErrEndl 			THEN Waiting := TRUE; f1[i] := FALSE;
		ELSIF	Errors1[i].Prio <= ErrWechselpos	THEN Warning := TRUE; f1[i] := FALSE; END_IF
	END_IF
END_FOR


// report Error, Waiting and Warning to cell
IF Fault 	THEN io_RtFault 	:= SETBIT32( io_RtFault,   RtStNr ); END_IF
IF Waiting 	THEN io_RtWaiting 	:= SETBIT32( io_RtWaiting, RtStNr ); END_IF
IF Warning	THEN io_RtWarning	:= SETBIT32( io_RtWarning, RtStNr ); END_IF


(* Create Errrors / Misc. Errors *)


(* __________________________________ *)
(* -- Station - Allowed to Operate -- *)
Betrieb := 	Bedieneinheit.betrieb
		AND NOT Fault
		AND NOT ManualRun
		AND BedienEinheit.ventile_ok;


(* ____________________ *)
(* -- Start Station  -- *)
IF 	RtStartimpuls THEN
	StartCondition 
		:= 	StatEin
		AND	(arrCarrierData[RtNr][RtStNr][Nest1].PartData.teilestatus >= srGood
		OR	 arrCarrierData[RtNr][RtStNr][Nest2].PartData.teilestatus >= srGood);
					
	IF StartCondition THEN bStart := TRUE; END_IF
END_IF

rtTestPart(clk:=gKebaDataToSps[PANEL_M20].Bedienung.Taste_F2);
IF rtTestPart.Q AND iCounter=0 THEN
	iCounter:=40;
END_IF
(* ________________ *)
(* -- Step-Chain -- *)
xx( iStep := Schritt );

(* reset flags *)
SWI := FALSE;
//EZ1_plasma.in_bPlasmaOn	:=FALSE;
_bStepBackAllowed := FALSE;

CASE Schritt OF
0:	xx.x := 'in basepos. - wait for prework or station´s start';
	SchrittAxJumpBack := Schritt;		// In Case of an Error => Return to this step!
	IF  AllInPos
	AND bStart
	AND BedienEinheit.anl_ein
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF

1:xx.x:= 'Get recipe (OP40) from LC';
	LC_Cavity1.in_Data.TypeNo  := arrCarrierData[RtNr][RtStNr][Nest1].PartData.strTypeNr;
	LC_Cavity1.getRecipe(TypeNo);
	IF LC_Cavity1.comGetRecipe.bDone THEN

		IF LC_Cavity1.comGetRecipe.bValid THEN
			udiIndex1 		:= 1;
			lraxXSpeedPositioning_Moving:=REAL_TO_LREAL( F_LcGetreal( ADR(OutUserData1[udiIndex1]), udiIndex1));
			lraxXSpeedPositioning_Cleaning:=REAL_TO_LREAL( F_LcGetreal( ADR(OutUserData1[udiIndex1]), udiIndex1));			
			lraxXHomePos:=REAL_TO_LREAL( F_LcGetreal( ADR(OutUserData1[udiIndex1]), udiIndex1));			
			lraxXmittelPos:=REAL_TO_LREAL( F_LcGetreal( ADR(OutUserData1[udiIndex1]), udiIndex1));
			lraxXWorkPos:=REAL_TO_LREAL( F_LcGetreal( ADR(OutUserData1[udiIndex1]), udiIndex1));			
			Schritt := Schritt + 1;
			SWI := TRUE;
		ELSE // Error from LineController
			 // create a new part 
///			f1[feLcGetRecipeFailed] := TRUE;

			Schritt := 0;
			SWI 	:= TRUE;				
		END_IF
	END_IF

2:xx.x := 'Check Serial number in LineController';

	IF NOT LC_Cavity1.out_bBusy THEN
		LC_Cavity1.in_Data.SerialNo:= arrCarrierData[RtNr][RtStNr][Nest1].PartData.strTeileId;			//+1 by each cycle
		LC_Cavity1.in_Data.TypeNo  := arrCarrierData[RtNr][RtStNr][Nest1].PartData.strTypeNr;
		LC_Cavity1.in_Data.AssyLocation := 0;
		LC_Cavity1.in_Data.OPcode := ENU_LC_OpCode.checkSNRState;
		LC_Cavity1.in_bSendTelegram := TRUE;
	END_IF

	IF LC_Cavity1.out_bBusy AND NOT LC_Cavity1.out_bError THEN
		Schritt := Schritt + 1;
		SWI := TRUE;
		LC_Cavity1.in_bSendTelegram := FALSE;
	END_IF

3: xx.x := 'Wait for result of OP15 = checkSNRState from LC';
	IF NOT LC_Cavity1.out_bBusy THEN
		IF NOT LC_Cavity1.out_bError AND LC_Cavity1.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackSucces THEN
			(* merge parts *)
			Schritt := Schritt + 1;
			SWI := TRUE;
		ELSE
			IF LC_Cavity1.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackReserved  THEN // TCP/IP-Fehler
				Schritt := 2;
				SWI := TRUE;
			
			END_IF
		END_IF
	END_IF

4:xx.x := 'Check Serial number in LineController';

	IF NOT LC_Cavity2.out_bBusy THEN
		LC_Cavity2.in_Data.SerialNo:= arrCarrierData[RtNr][RtStNr][Nest2].PartData.strTeileId;			//+1 by each cycle
		LC_Cavity2.in_Data.TypeNo  := arrCarrierData[RtNr][RtStNr][Nest2].PartData.strTypeNr;
		LC_Cavity2.in_Data.AssyLocation := 0;
		LC_Cavity2.in_Data.OPcode := ENU_LC_OpCode.checkSNRState;
		LC_Cavity2.in_bSendTelegram := TRUE;
	END_IF

	IF LC_Cavity2.out_bBusy AND NOT LC_Cavity2.out_bError THEN
		Schritt := Schritt + 1;
		SWI := TRUE;
		LC_Cavity2.in_bSendTelegram := FALSE;
	END_IF

5: xx.x := 'Wait for result of OP15 = checkSNRState from LC';
	IF NOT LC_Cavity2.out_bBusy THEN
		IF NOT LC_Cavity2.out_bError AND LC_Cavity2.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackSucces THEN
			(* merge parts *)
			Schritt := Schritt + 2;
			SWI := TRUE;
		ELSE
			IF LC_Cavity2.out_Data.ACK_Numer = ENU_LC_Ack_Number.ackReserved  THEN // TCP/IP-Fehler
				Schritt := 4;
				SWI := TRUE;
			
			END_IF
		END_IF
	END_IF		
	
7:	xx.x := 'ML1 Pick and Place Horizontal -> return step';
	schrittAxJumpBack		:=schritt;
	_bStepBackAllowed		:=TRUE;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bBereitFuerPos
	THEN
		axX.in_lrPosSoll		:= lraxXHomePos;
		lraxXSpeedPositioning	:=lraxXSpeedPositioning_Moving;
		axX.in_bStartPosAbsolute:=TRUE;
		(*ML1 drives to work position by jumpback process*)
		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF		
		
8:	xx.x := 'ML1 Pick and Place Horizontal -> AHEAD (cleaning Position)';
	axX.in_lrPosSoll		:= lraxXHomePos;
	lraxXSpeedPositioning	:= lraxXSpeedPositioning_Moving;
	axX.in_bStartPosAbsolute:=TRUE;
	_bStepBackAllowed		:=TRUE;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bMoveAbsoluteDone
	THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 2;
		SWI := TRUE;
	END_IF		

10:	xx.x := 'MM3 Vertical -> ON (downwards)';
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		EZ1_plasma.in_bPlasmaOn	:=BedienEinheit.anl_ein AND NOT Fault;
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF	

15:	xx.x:= 'MM1 MM2 Gripper 1&2 -> ON (Parts fix) ';
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		EZ1_plasma.in_bPlasmaOn	:=BedienEinheit.anl_ein AND NOT Fault;
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF	
		
20:	xx.x := 'MM4 Operate Carrier -> ON (Carrier open)';
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		EZ1_plasma.in_bPlasmaOn	:=BedienEinheit.anl_ein AND NOT Fault;
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF		
		
30:	xx.x := 'MM3 Vertical -> OFF (upwards)';
	xx.xx:= 'waiting for Plasma completely Open';
	EZ1_plasma.in_bPlasmaOn	:=BedienEinheit.anl_ein AND NOT Fault;
	IF 	AllInPos
	AND Betrieb	
	THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 4;
		SWI := TRUE;
	END_IF	

	(* ML1 go to mittleposition with moving speed*)
34:	xx.x := 'ML1 Pick and Place Horizontal -> return step';
	schrittAxJumpBack		:=schritt;
	_bStepBackAllowed		:=TRUE;
	EZ1_plasma.in_bPlasmaOn	:=BedienEinheit.anl_ein AND NOT Fault;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bBereitFuerPos
	THEN
		axX.in_lrPosSoll		:= lraxXmittelPos;
		lraxXSpeedPositioning	:= lraxXSpeedPositioning_Moving;
		axX.in_bStartPosAbsolute:=TRUE;
		(*ML1 drives to work position by jumpback process*)
		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF		
		
35:	xx.x := 'ML1 Pick and Place Horizontal -> AHEAD (middle Position)';
	axX.in_lrPosSoll		:= lraxXmittelPos;
	lraxXSpeedPositioning	:= lraxXSpeedPositioning_Moving;
	axX.in_bStartPosAbsolute:=TRUE;
	_bStepBackAllowed		:=TRUE;
	EZ1_plasma.in_bPlasmaOn	:=BedienEinheit.anl_ein AND NOT Fault;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bMoveAbsoluteDone
	AND EZ1_plasma.out_CleaningInProgress 
	THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF		

40:	xx.x := 'ML1 Pick and Place Horizontal -> return step';
	schrittAxJumpBack		:=schritt;
	_bStepBackAllowed		:=TRUE;
	EZ1_plasma.in_bPlasmaOn	:=BedienEinheit.anl_ein AND NOT Fault;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bBereitFuerPos
	THEN
		axX.in_lrPosSoll		:= lraxXWorkPos;
		lraxXSpeedPositioning	:= lraxXSpeedPositioning_Cleaning;
		axX.in_bStartPosAbsolute:=TRUE;
		(*ML1 drives to work position by jumpback process*)
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF		
		
50:	xx.x := 'ML1 Pick and Place Horizontal -> AHEAD (cleaning Position)';
	axX.in_lrPosSoll		:= lraxXWorkPos;
	lraxXSpeedPositioning	:= lraxXSpeedPositioning_Cleaning;
	axX.in_bStartPosAbsolute:=TRUE;
	_bStepBackAllowed		:=TRUE;
	EZ1_plasma.in_bPlasmaOn	:=BedienEinheit.anl_ein AND NOT Fault;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bMoveAbsoluteDone
	THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF		
			
60:	xx.x := 'MM5 Appr. hori. Stroke -> ON (2. Cleaning Position)';
	xx.xx:= 'waiting for Plasma saving Data';
	arrCarrierData[RtNr][RtStNr][Nest1].PartData.StNrLast					:= StNr;
	arrCarrierData[RtNr][RtStNr][Nest1].PartData.Mo20_St020.bCleaningDone 	:= TRUE;
	EZ1_plasma.in_bPlasmaOn	:=BedienEinheit.anl_ein AND NOT Fault;
	IF EZ1_plasma.out_CleaningSuccessful THEN
		(*cleaning succesfully, good parts*)
		awErrorCleaning.igut	:= TRUE; 
		arrCarrierData[RtNr][RtStNr][Nest1].PartData.Mo20_St020.lrAxXPosStartCleaning := lraxXmittelPos; 
		arrCarrierData[RtNr][RtStNr][Nest1].PartData.Mo20_St020.lrAxXPosStopCleaning  := lraxXWorkPos;
		arrCarrierData[RtNr][RtStNr][Nest1].PartData.Mo20_St020.lrAxXSpeedCleaning	  := lraxXSpeedPositioning_Cleaning/3;
	ELSE
		(*bad parts*)
		awErrorCleaning.ischl	:= TRUE; 
		arrCarrierData[RtNr][RtStNr][Nest1].PartData.teilestatus						:= srBad;
		arrCarrierData[RtNr][RtStNr][Nest1].PartData.StNrSchlechtGesetzt				:= StNr;
		arrCarrierData[RtNr][RtStNr][Nest1].PartData.iFehlercode						:= bcM20_St020_CleaningFailed_1; 			//declaration in gvl_machineconfig
			
		BDEIncCounter( FALSE, bcM20_St020_CleaningFailed_1, 1, ActOrd[MPart].ord_id, MPart);
		BDEIncCounter( TRUE	, bcM20_St020_CleaningFailed_1, 1, ActOrd[MPart].ord_id, MPart);	
	END_IF																		
	EZ1_plasma.in_bPlasmaOn	:=BedienEinheit.anl_ein AND NOT Fault;
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 4;
		SWI := TRUE;
	END_IF		

(* ML1 go to mittleposition with cleaning speed*)
64:	xx.x := 'ML1 Pick and Place Horizontal -> return step';
	schrittAxJumpBack		:=schritt;
	_bStepBackAllowed		:=TRUE;
	EZ1_plasma.in_bPlasmaOn	:=BedienEinheit.anl_ein AND NOT Fault;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bBereitFuerPos
	THEN
		axX.in_lrPosSoll		:= lraxXmittelPos;
		lraxXSpeedPositioning	:= lraxXSpeedPositioning_Cleaning;
		axX.in_bStartPosAbsolute:=TRUE;
		(*ML1 drives to work position by jumpback process*)
		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF		
		
65:	xx.x := 'ML1 Pick and Place Horizontal -> BACK (mittle Position)';
	axX.in_lrPosSoll		:= lraxXmittelPos;
	lraxXSpeedPositioning	:= lraxXSpeedPositioning_Cleaning;
	axX.in_bStartPosAbsolute:=TRUE;
	_bStepBackAllowed		:=TRUE;
	EZ1_plasma.in_bPlasmaOn	:=BedienEinheit.anl_ein AND NOT Fault;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bMoveAbsoluteDone
	THEN
		EZ1_plasma.in_bPlasmaOn	:=FALSE;
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF		
	
70:	xx.x := 'ML1 Pick and Place Horizontal -> return step';
	schrittAxJumpBack		:=schritt;
	_bStepBackAllowed		:=TRUE;
	EZ1_plasma.in_bPlasmaOn	:=FALSE;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bBereitFuerPos
	THEN
		axX.in_lrPosSoll		:= lraxXHomePos;
		lraxXSpeedPositioning	:= lraxXSpeedPositioning_Moving;
		axX.in_bStartPosAbsolute:=TRUE;
		(*ML1 drives to home position by jumpback process*)
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF		
		
80:	xx.x := 'ML1 Pick and Place Horizontal -> BACK (home Position)';
	_bStepBackAllowed		:=TRUE;
	axX.in_lrPosSoll		:= lraxXHomePos;
	lraxXSpeedPositioning	:= lraxXSpeedPositioning_Moving;
	axX.in_bStartPosAbsolute:=TRUE;
	EZ1_plasma.in_bPlasmaOn	:=FALSE;
	IF 	AllInPos
	AND Betrieb 
	AND axX.out_bMoveAbsoluteDone
	THEN
		_bStepBackAllowed	:=FALSE;
		EZ1_plasma.in_bPlasmaOn	:=FALSE;
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF			
		
90:	xx.x:= 'waiting for Plasma OFF and saving Data';
	EZ1_plasma.in_bPlasmaOn	:=FALSE;
	IF 	AllInPos
	AND Betrieb 
	AND NOT EZ1_plasma.out_CleaningInProgress
	THEN
		
		arrCarrierData[RtNr][RtStNr][Nest2].PartData.StNrLast					:= StNr;
		arrCarrierData[RtNr][RtStNr][Nest2].PartData.Mo20_St020.bCleaningDone 	:= TRUE;

		IF EZ1_plasma.out_CleaningSuccessful THEN
			(*cleaning succesfully, good parts*)
			awErrorCleaning.igut	:= TRUE; 
			arrCarrierData[RtNr][RtStNr][Nest2].PartData.Mo20_St020.lrAxXPosStartCleaning := lraxXmittelPos; 
			arrCarrierData[RtNr][RtStNr][Nest2].PartData.Mo20_St020.lrAxXPosStopCleaning  := lraxXworkPos;
			arrCarrierData[RtNr][RtStNr][Nest2].PartData.Mo20_St020.lrAxXSpeedCleaning	  := lraxXSpeedPositioning_Cleaning/3;
		ELSE
			(*bad parts*)
			awErrorCleaning.ischl	:= TRUE; 
			arrCarrierData[RtNr][RtStNr][Nest2].PartData.teilestatus						:= srBad;
			arrCarrierData[RtNr][RtStNr][Nest2].PartData.StNrSchlechtGesetzt				:= StNr;
			arrCarrierData[RtNr][RtStNr][Nest2].PartData.iFehlercode						:= bcM20_St020_CleaningFailed_2; 
			
			BDEIncCounter( FALSE, bcM20_St020_CleaningFailed_2, 1, ActOrd[MPart].ord_id, MPart);
			BDEIncCounter( TRUE	, bcM20_St020_CleaningFailed_2, 1, ActOrd[MPart].ord_id, MPart);	
		END_IF																		//reset this flag after data saving
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF	

95:xx.x := 'Reset Start';
	EZ1_plasma.in_bPlasmaOn	:=FALSE;
	IF	AllInPos
	AND	Betrieb 
	AND NOT f1[feawErrorCleaning] 
	THEN
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF
	
100:xx.x := 'MM3 Vertical -> ON (downwards)';
	xx.xx := 'MM5 Appr. hori. Stroke -> OFF (1. Cleaning Position)';
	EZ1_plasma.in_bPlasmaOn	:=FALSE;
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 10;
		SWI := TRUE;
	END_IF		
	
110:xx.x := 'MM4 Operate Carrier -> OFF (carrier closed)';
	EZ1_plasma.in_bPlasmaOn	:=FALSE;
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 5;
		SWI := TRUE;
	END_IF

115:xx.x := 'MM1 MM2 Gripper 1&2 -> OFF (Parts release)';
	EZ1_plasma.in_bPlasmaOn	:=FALSE;
	IF 	AllInPos
	AND Betrieb THEN
		_bStepBackAllowed	:=FALSE;
		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF		

(*Step for Line Controller Upload*)	
116: xx.xx:= 'LineController socket ready';
	IF	NOT LC_Cavity1.out_bBusy THEN

		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF

117:xx.x := 'Upload result to LC';
	DataIndex2 := 1;
	F_LcSetReal(ADR(InUserData1[DataIndex2]),LREAL_TO_REAL(arrCarrierData[RtNr][RtStNr][Nest1].PartData.Mo20_St020.lrAxXSpeedCleaning), DataIndex2);
	F_LcSetReal(ADR(InUserData1[DataIndex2]),LREAL_TO_REAL(arrCarrierData[RtNr][RtStNr][Nest1].PartData.Mo20_St020.lrAxXPosSTARTCleaning), DataIndex2);
	F_LcSetReal(ADR(InUserData1[DataIndex2]),LREAL_TO_REAL(arrCarrierData[RtNr][RtStNr][Nest1].PartData.Mo20_St020.lrAxXPosSTOPCleaning), DataIndex2);
	IF (arrCarrierData[RtNr][RtStNr][Nest1].PartData.teilestatus = srGood) THEN
		LC_Cavity1.UploadStateAndResultData(	arrCarrierData[RtNr][RtStNr][Nest1].PartData.strTypeNr,
										arrCarrierData[RtNr][RtStNr][Nest1].PartData.strTeileId,
										0,(*Fail_Location*)
										0(*Fail_Type*)
									);
	ELSIF (arrCarrierData[RtNr][RtStNr][Nest1].PartData.iFehlercode = bcM20_St020_CleaningFailed_1) THEN
		LC_Cavity1.UploadStateAndResultData(	arrCarrierData[RtNr][RtStNr][Nest1].PartData.strTypeNr,
										arrCarrierData[RtNr][RtStNr][Nest1].PartData.strTeileId,
										bcM20_St020_CleaningFailed_1,(*Fail_Location*)
										LCID_FAIL_PLASMA_CLEANING//LCID_FAIL_PRESENCE(*Fail_Type*) 
									);
	END_IF
	IF (LC_Cavity1.comUploadStateAndResultData.bStarted OR LC_Cavity1.comUploadStateAndResultData.bDone) THEN
		Schritt := Schritt + 2;
		SWI := TRUE;
	END_IF;	
	
118: xx.xx:= 'LineController socket ready';
	IF	NOT LC_Cavity2.out_bBusy THEN

		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF

119:xx.x := 'Upload result to LC';
	DataIndex2 := 1;
	F_LcSetReal(ADR(InUserData2[DataIndex2]),LREAL_TO_REAL(arrCarrierData[RtNr][RtStNr][Nest2].PartData.Mo20_St020.lrAxXSpeedCleaning), DataIndex2);
	F_LcSetReal(ADR(InUserData2[DataIndex2]),LREAL_TO_REAL(arrCarrierData[RtNr][RtStNr][Nest2].PartData.Mo20_St020.lrAxXPosSTARTCleaning), DataIndex2);
	F_LcSetReal(ADR(InUserData2[DataIndex2]),LREAL_TO_REAL(arrCarrierData[RtNr][RtStNr][Nest2].PartData.Mo20_St020.lrAxXPosSTOPCleaning), DataIndex2);
	IF (arrCarrierData[RtNr][RtStNr][Nest2].PartData.teilestatus = srGood) THEN
		LC_Cavity2.UploadStateAndResultData(	arrCarrierData[RtNr][RtStNr][Nest2].PartData.strTypeNr,
										arrCarrierData[RtNr][RtStNr][Nest2].PartData.strTeileId,
										0,(*Fail_Location*)
										0(*Fail_Type*)
									);
	ELSIF (arrCarrierData[RtNr][RtStNr][Nest2].PartData.iFehlercode = bcM20_St020_CleaningFailed_2) THEN
		LC_Cavity2.UploadStateAndResultData(	arrCarrierData[RtNr][RtStNr][Nest2].PartData.strTypeNr,
										arrCarrierData[RtNr][RtStNr][Nest2].PartData.strTeileId,
										bcM20_St020_CleaningFailed_2,(*Fail_Location*)
										LCID_FAIL_PLASMA_CLEANING//LCID_FAIL_PRESENCE(*Fail_Type*)
									);
	END_IF
	IF (LC_Cavity2.comUploadStateAndResultData.bStarted OR LC_Cavity2.comUploadStateAndResultData.bDone) THEN
		Schritt := Schritt + 1;
		SWI := TRUE;
	END_IF;	
	
120:xx.x := 'MM3 Vertical -> OFF (upwards)';
	EZ1_plasma.in_bPlasmaOn	:=FALSE;
	IF 	AllInPos
	AND Betrieb THEN
		IF iCounter> 0 THEN
			arrCarrierData[RtNr][RtStNr][Nest1].PartData.Mo20_St020.TestPart:=TRUE;
			arrCarrierData[RtNr][RtStNr][Nest2].PartData.Mo20_St020.TestPart:=TRUE;
			iCounter:=iCounter-2;
		ELSE
			iCounter:=0;
		END_IF
		bStart := FALSE;
		Schritt := 0;
		SWI := TRUE;
	END_IF		
		
END_CASE


(* -- Error by cleaning X-times in a Row -- *)
awErrorCleaning( cntmax	:= FehlStop[OrderNr] );
IF awErrorCleaning.fehler THEN f1[feawErrorCleaning] := TRUE; END_IF
awErrorCleaning.igut	:= FALSE; 
awErrorCleaning.ischl	:= FALSE; 

(* ____________________ *)
(* -- React to Steps -- *)
IF NOT ManualRun THEN
	
	zyl0_grip1.on 				:= 	 (Schritt >= 15) AND (Schritt < 115);
	zyl0_grip2.on 				:= 	 (Schritt >= 15) AND (Schritt < 115);
	
	zyl2_vertical_stroke.on		:=	( (Schritt >= 10)  AND (Schritt < 30) )  
								OR 	( (Schritt >= 100) AND (Schritt < 120) );		
	
	zyl2_operate_Carrier.on		:=	(Schritt >= 20) AND (Schritt < 110);
	
	zyl2_appr_h_stroke.on		:=	(Schritt >= 60) AND (Schritt < 100);
	
	
	
END_IF


(* _______________ *)
(* -- Axes Festo Servocontroller -- *)
axXID	:=cAx_M20_St20_TA1;



(* prevent structure crash*)

_bWorkAreaToMoveAllowed			:=	(axX.out_lrPosIst>(lraxXWorkPos - 5.00))     //DWOCOM(Toleranz) value is not right, should be inputted before ST commission
						  AND 	(axX.out_lrPosIst<(lraxXWorkPos + 5.00));

_bMoveAxisAllowed			:=	(zyl2_vertical_stroke.a
						AND NOT  zyl2_vertical_stroke.y);

//Jump back if...
IF(		Bedieneinheit.notaus_ok = FALSE			// if jumpback is allowed
	OR	Bedieneinheit.ventile_ok =FALSE
	OR  Bedieneinheit.grundbed = FALSE
	OR  Bedieneinheit.schutz_ok = FALSE
	OR  axX.out_bFault
	OR  ( NOT   _bWorkAreaToMoveAllowed
		AND (schritt >= 60 AND schritt <64))
	AND _bStepBackAllowed)
	AND FALSE
 THEN 
	_baxJumpBackDemanded	:=TRUE;
	
ELSIF _baxJumpBackDemanded						//start the process of jumpback
	AND Betrieb
 THEN 
	_baxJumpBackDemanded	:=FALSE;
	Schritt :=	SchrittAxJumpBack;
	SWI	:= TRUE;

END_IF



(*-------- Plasma----DWOCOM----*)
EZ1_plasma(
	OrderNr					:= OrderNr, 
	MoNr					:= MoNr, 
	StNr					:= StNr, 
	BedienEinheit			:= BedienEinheit, 
	FaultID					:= FaultID, 
	DisplayNr				:= DisplayNr, 
	MPart					:= MPart, 
	inGeraeteName			:= '=020-EZ1', 
	inStatString			:= StatString, 
	in_bEnable				:= StatEin AND BedienEinheit.schutz_ok, 
	in_byRecipe					:= 1,		(*DWOCOM*)  
	//in_byRecipe					:= bySelectedRecipe,
	in_bFeldbusOk				:= NOT MAIN.M20.fbBusdiag.out_bModulStop, 
	in_bEnableProfinetError		:= BedienEinheit.grundbed AND NOT MAIN.M20.fbBusdiag.out_bModulStop AND t_erkenn.Q,
	in_IgnorePlasmaDeactivated	:= bCleanBackwardsToo 	AND NOT BedienEinheit.mpart[Mpart].hm_leer,
	in_IgnoreRotationDeactivated:= TRUE 				AND NOT BedienEinheit.mpart[Mpart].hm_leer,
	ixEmergencyStopOK			:= _020_M20_MP1_EZ1_X40_2D AND BedienEinheit.notaus_ok, 
	ixPlasmaReady				:= _020_M20_MP1_EZ1_X40_4D, 
	ixError						:= NOT _020_M20_MP1_EZ1_X40_6D, 
	ixWarning					:= _020_M20_MP1_EZ1_X40_8D, 
	ixPlasmaOK					:= _020_M20_MP1_EZ1_X40,
);

_020_M20_P1_KF2	:=  	EZ1_plasma.qx_GeneratorOFF;
_020_M20_P1_KF4	:=		EZ1_plasma.qx_GeneratorON;
_020_M20_P1_KF5	:=		EZ1_plasma.qx_Intermitting;	
_020_M20_P1_KF3	:=		EZ1_plasma.qx_AcknowledgmentError;
		
(* PlasmaCleaning Check in Process //DWOCOM for Test*)
(*IF  NOT EZ1_plasma.out_CleaningInProgress
	AND (schritt = 50 OR schritt = 80) 
	AND (axX.out_lrPosIst>lraxXHomePos) 
	AND (axX.out_lrPosIst<lraxXWorkPos) 
THEN 
	bCleaningSuccesful	:=FALSE;
END_IF*)


(*-------- Axis Input --------*)

axX(
	BedienEinheit							:= BedienEinheit, 
	FaultID									:= FaultID, 
	DisplayNr								:= DisplayNr, 
	ixP_Stop								:= (NOT ix_axX_P_Stop) AND _bMoveAxisAllowed, 
	ixN_Stop								:= (NOT ix_axX_N_Stop) AND _bMoveAxisAllowed, 
	ixRef									:= FALSE, 									
	in_strAchsbezeichnung					:= '=20-TA1', 
	in_strP_Stop							:= '=020-BG1.P', 
	in_strN_Stop							:= '=020-BG1.N', 
	ixBtb									:= Bedieneinheit.grundbed OR ix_axX_Ready, 
	in_bSvvVersorgt							:= BedienEinheit.hauptstrom_ok, 
	in_bSvvFreigabe							:= BedienEinheit.grundbed AND BedienEinheit.schutz_ok, 
	in_bSoftwareEnable						:= StatEin, 
	in_lrVelocityPercentAuto				:= lraxXSpeedPositioning/3, 
	in_lrVelocityPercentManual				:= lraxXSpeedPositioning/3, 
	in_lrVelocityGuardOpen					:= 25.0, 
	in_bSuchrichtungRefPos					:= TRUE,			//DWOCOM
	Axis									:= g_arrAxisRef [axXID], 
	bBremse									:= FALSE,
	in_bRefKeinResetSchleppfehler 			:= TRUE,
	);	

	
	axX.in_bJogForward			:= FALSE;
	axX.in_bJogBackwards		:= FALSE;
	axX.in_bStartPosAbsolute	:= FALSE;
	axX.in_bStartPosAbsolute_2	:= FALSE;					//normally dont need to use it
	axX.in_bNotHalt				:= FALSE;
	axX.in_lrAcceleration		:= 0;
	axX.in_lrDeceleration		:= 0;
	axX.in_bStopTransport		:= NOT bedieneinheit.betr_ein;
	
	
	F_InitAchseOhneKoordsysteme(
		iAchsId						:= axXID, 
		iActionButtonSlow			:= -1, 
		iActionButtonFast			:= -1, 
		strBetriebsmittelname		:= 'M020=St20-TA1', 
		strKlartextname				:= 'X-Axis', 
		strEinheitennameWeg			:= 'mm', 
		strEinheitennameSpeed		:= 'mm/s', 
		bAbsolutAchse				:= true,  				  //not sure 
		 );						
	



	//Insert target- and actuel Position in Axis structure
	g_Achsen[axXID].iAnzKoordsysteme													:=1;
	g_Achsen[axXID].arr_stCoord[cCoordMachine].strName									:='Position';
	g_Achsen[axXID].arr_stCoord[cCoordMachine].lrIstPos									:=axX.out_lrPosIst;
	g_Achsen[axXID].arr_stCoord[cCoordMachine].lrSollPos								:=axX.in_lrPosSoll;
	
	

	
	
(* _____________________________________ *)
(* -- Stop Roundtable Condition-Based -- *)
IF  	((zyl2_vertical_stroke.b OR zyl2_vertical_stroke.y OR NOT zyl2_vertical_stroke.a )
	AND  (zyl2_appr_h_stroke.b OR zyl2_appr_h_stroke.y OR NOT zyl2_appr_h_stroke.a ))
	OR   (zyl2_operate_carrier.b OR zyl2_operate_carrier.y OR NOT zyl2_operate_carrier.a)
THEN 
	F_ResetFrgRtWithText(TRUE, RtNr, RtStNr, '020MM3 §Vertical§ §not§ §in§ §base-pos.§', io_RtFreigabe); (*DWOCOM Name should be changed, too long if write every cyl. down*)
END_IF


(* ______________________________________ *)
(* -- Report Station is working on RT  -- *)
io_RtStarts := CSETBIT32(io_RtStarts, RtStNr, bStart);


(* _________________ *)
(* -- Set outputs -- *)

(*Festo Serco Output*)
_020_M20_P1_TA1_X1_9		:=axX.qxEnable;								//qx_axX_ReglerFreigabe    DWOCOM
_020_M20_P1_TA1_X1_21		:=axX.qxEnable;								//qx_axX_EndstufeFreigabe	DWOCOM

(*Plasma Output*)
qx_Plasma_Generator_AUS		:=_020_M20_P1_KF2;
qx_Plasma_Intermitting		:=_020_M20_P1_KF5;
qx_Plasma_Generator_EIN		:=_020_M20_P1_KF4;
qx_Plasma_Quittirung_Str	:=_020_M20_P1_KF3;

(*Cylinder Output*)
IF ManualRun THEN (* assign cylinderoutputs .y (by "AND Bedieneinheit.ventile_ok") *)
	_020_M20_MP1_WZ1_QM1_MB1         	:=		zyl0_grip1.y AND Bedieneinheit.ventile_ok;
	_020_M20_MP1_WZ1_QM1_MB2        	:=	not zyl0_grip1.y AND Bedieneinheit.ventile_ok;
	_020_M20_MP1_WZ1_QM2_MB1         	:=		zyl0_grip2.y AND Bedieneinheit.ventile_ok;
	_020_M20_MP1_WZ1_QM2_MB2         	:=	not zyl0_grip2.y AND Bedieneinheit.ventile_ok;
	_020_M20_MP1_WZ1_QM3_MB1         	:=		zyl2_vertical_stroke.y AND Bedieneinheit.ventile_ok;
	_020_M20_MP1_WZ1_QM3_MB2         	:=	not zyl2_vertical_stroke.y AND Bedieneinheit.ventile_ok;
	_020_M20_MP1_WZ7_QM4_MB1         	:=		zyl2_operate_Carrier.y AND Bedieneinheit.ventile_ok;
	_020_M20_MP1_WZ7_QM4_MB2         	:=	NOT zyl2_operate_Carrier.y AND Bedieneinheit.ventile_ok;
	_020_M20_MP1_WZ7_QM5_MB1         	:=		zyl2_appr_h_stroke.y AND Bedieneinheit.ventile_ok;
	_020_M20_MP1_WZ7_QM5_MB2  			:=	NOT zyl2_appr_h_stroke.y AND Bedieneinheit.ventile_ok;
ELSE (* assign cylinderoutputs .on (by "AND Bedieneinheit.ventile_ok") *)
	_020_M20_MP1_WZ1_QM1_MB1         	:=		zyl0_grip1.on AND Bedieneinheit.ventile_ok;
	_020_M20_MP1_WZ1_QM1_MB2        	:=	not zyl0_grip1.on AND Bedieneinheit.ventile_ok;
	_020_M20_MP1_WZ1_QM2_MB1         	:=		zyl0_grip2.on AND Bedieneinheit.ventile_ok;
	_020_M20_MP1_WZ1_QM2_MB2         	:=	not zyl0_grip2.on AND Bedieneinheit.ventile_ok;
	_020_M20_MP1_WZ1_QM3_MB1         	:=		zyl2_vertical_stroke.on AND Bedieneinheit.ventile_ok;
	_020_M20_MP1_WZ1_QM3_MB2         	:=	not zyl2_vertical_stroke.on AND Bedieneinheit.ventile_ok;
	_020_M20_MP1_WZ7_QM4_MB1         	:=		zyl2_operate_Carrier.on AND Bedieneinheit.ventile_ok;
	_020_M20_MP1_WZ7_QM4_MB2         	:=	NOT zyl2_operate_Carrier.on AND Bedieneinheit.ventile_ok;
	_020_M20_MP1_WZ7_QM5_MB1         	:=		zyl2_appr_h_stroke.on AND Bedieneinheit.ventile_ok;
	_020_M20_MP1_WZ7_QM5_MB2  			:=	NOT zyl2_appr_h_stroke.on AND Bedieneinheit.ventile_ok;
END_IF

]]></ST>
    </Implementation>
    <LineIds Name="Mo20_St20_plasma_cleaning_for_housing">
      <LineId Id="589" Count="2" />
      <LineId Id="2115" Count="1" />
      <LineId Id="5212" Count="0" />
      <LineId Id="790" Count="1" />
      <LineId Id="960" Count="0" />
      <LineId Id="959" Count="0" />
      <LineId Id="792" Count="8" />
      <LineId Id="154" Count="0" />
      <LineId Id="4739" Count="0" />
      <LineId Id="5676" Count="26" />
      <LineId Id="4788" Count="0" />
      <LineId Id="4787" Count="0" />
      <LineId Id="596" Count="18" />
      <LineId Id="175" Count="6" />
      <LineId Id="7120" Count="1" />
      <LineId Id="7119" Count="0" />
      <LineId Id="182" Count="0" />
      <LineId Id="615" Count="0" />
      <LineId Id="184" Count="0" />
      <LineId Id="4446" Count="0" />
      <LineId Id="4449" Count="0" />
      <LineId Id="4447" Count="1" />
      <LineId Id="4452" Count="0" />
      <LineId Id="4454" Count="0" />
      <LineId Id="4456" Count="0" />
      <LineId Id="4455" Count="0" />
      <LineId Id="4464" Count="3" />
      <LineId Id="4458" Count="0" />
      <LineId Id="4468" Count="1" />
      <LineId Id="4457" Count="0" />
      <LineId Id="4470" Count="1" />
      <LineId Id="4473" Count="0" />
      <LineId Id="4472" Count="0" />
      <LineId Id="4474" Count="0" />
      <LineId Id="4476" Count="1" />
      <LineId Id="4475" Count="0" />
      <LineId Id="4445" Count="0" />
      <LineId Id="186" Count="0" />
      <LineId Id="616" Count="1" />
      <LineId Id="188" Count="3" />
      <LineId Id="2600" Count="0" />
      <LineId Id="618" Count="1" />
      <LineId Id="1495" Count="0" />
      <LineId Id="2118" Count="0" />
      <LineId Id="1516" Count="0" />
      <LineId Id="1532" Count="9" />
      <LineId Id="1496" Count="1" />
      <LineId Id="1542" Count="0" />
      <LineId Id="1558" Count="9" />
      <LineId Id="1498" Count="1" />
      <LineId Id="1572" Count="1" />
      <LineId Id="1596" Count="11" />
      <LineId Id="1569" Count="2" />
      <LineId Id="1797" Count="0" />
      <LineId Id="1820" Count="11" />
      <LineId Id="1609" Count="1" />
      <LineId Id="1832" Count="0" />
      <LineId Id="1855" Count="11" />
      <LineId Id="1611" Count="1" />
      <LineId Id="1608" Count="0" />
      <LineId Id="210" Count="0" />
      <LineId Id="1867" Count="3" />
      <LineId Id="8262" Count="0" />
      <LineId Id="4182" Count="0" />
      <LineId Id="8265" Count="3" />
      <LineId Id="8724" Count="0" />
      <LineId Id="8269" Count="18" />
      <LineId Id="8726" Count="0" />
      <LineId Id="8288" Count="14" />
      <LineId Id="8264" Count="0" />
      <LineId Id="8263" Count="0" />
      <LineId Id="621" Count="0" />
      <LineId Id="221" Count="1" />
      <LineId Id="1872" Count="3" />
      <LineId Id="223" Count="0" />
      <LineId Id="3120" Count="0" />
      <LineId Id="3232" Count="0" />
      <LineId Id="3121" Count="0" />
      <LineId Id="224" Count="9" />
      <LineId Id="622" Count="1" />
      <LineId Id="1138" Count="2" />
      <LineId Id="239" Count="0" />
      <LineId Id="241" Count="3" />
      <LineId Id="627" Count="1" />
      <LineId Id="247" Count="10" />
      <LineId Id="1880" Count="0" />
      <LineId Id="258" Count="3" />
      <LineId Id="263" Count="1" />
      <LineId Id="8974" Count="2" />
      <LineId Id="265" Count="4" />
      <LineId Id="7342" Count="0" />
      <LineId Id="271" Count="1" />
      <LineId Id="3122" Count="0" />
      <LineId Id="273" Count="1" />
      <LineId Id="276" Count="0" />
      <LineId Id="6681" Count="0" />
      <LineId Id="277" Count="0" />
      <LineId Id="279" Count="2" />
      <LineId Id="3143" Count="0" />
      <LineId Id="282" Count="1" />
      <LineId Id="8537" Count="0" />
      <LineId Id="8658" Count="0" />
      <LineId Id="8657" Count="0" />
      <LineId Id="8588" Count="0" />
      <LineId Id="8572" Count="3" />
      <LineId Id="8590" Count="0" />
      <LineId Id="8593" Count="0" />
      <LineId Id="8592" Count="0" />
      <LineId Id="8576" Count="0" />
      <LineId Id="8594" Count="0" />
      <LineId Id="8579" Count="8" />
      <LineId Id="8538" Count="0" />
      <LineId Id="8595" Count="0" />
      <LineId Id="8597" Count="28" />
      <LineId Id="8596" Count="0" />
      <LineId Id="8627" Count="29" />
      <LineId Id="8626" Count="0" />
      <LineId Id="6350" Count="0" />
      <LineId Id="6352" Count="7" />
      <LineId Id="6425" Count="0" />
      <LineId Id="6360" Count="7" />
      <LineId Id="6426" Count="0" />
      <LineId Id="6368" Count="8" />
      <LineId Id="6351" Count="0" />
      <LineId Id="1881" Count="0" />
      <LineId Id="1891" Count="0" />
      <LineId Id="1894" Count="2" />
      <LineId Id="7341" Count="0" />
      <LineId Id="3144" Count="0" />
      <LineId Id="1897" Count="0" />
      <LineId Id="285" Count="0" />
      <LineId Id="6377" Count="0" />
      <LineId Id="6379" Count="0" />
      <LineId Id="6381" Count="2" />
      <LineId Id="7340" Count="0" />
      <LineId Id="6384" Count="1" />
      <LineId Id="6378" Count="0" />
      <LineId Id="1882" Count="0" />
      <LineId Id="1899" Count="0" />
      <LineId Id="1902" Count="2" />
      <LineId Id="3887" Count="0" />
      <LineId Id="3145" Count="0" />
      <LineId Id="1905" Count="0" />
      <LineId Id="1884" Count="1" />
      <LineId Id="1906" Count="2" />
      <LineId Id="3888" Count="0" />
      <LineId Id="1909" Count="0" />
      <LineId Id="2598" Count="0" />
      <LineId Id="1910" Count="0" />
      <LineId Id="3146" Count="0" />
      <LineId Id="1911" Count="1" />
      <LineId Id="6431" Count="0" />
      <LineId Id="6398" Count="3" />
      <LineId Id="7785" Count="0" />
      <LineId Id="6402" Count="4" />
      <LineId Id="6427" Count="0" />
      <LineId Id="6407" Count="7" />
      <LineId Id="6428" Count="0" />
      <LineId Id="6415" Count="1" />
      <LineId Id="7786" Count="0" />
      <LineId Id="6417" Count="2" />
      <LineId Id="7784" Count="0" />
      <LineId Id="6420" Count="3" />
      <LineId Id="6397" Count="0" />
      <LineId Id="3126" Count="3" />
      <LineId Id="7787" Count="0" />
      <LineId Id="3889" Count="0" />
      <LineId Id="3130" Count="0" />
      <LineId Id="3134" Count="0" />
      <LineId Id="3133" Count="0" />
      <LineId Id="3131" Count="0" />
      <LineId Id="6429" Count="0" />
      <LineId Id="3137" Count="0" />
      <LineId Id="3136" Count="0" />
      <LineId Id="3140" Count="0" />
      <LineId Id="3132" Count="0" />
      <LineId Id="1888" Count="0" />
      <LineId Id="2578" Count="0" />
      <LineId Id="1919" Count="1" />
      <LineId Id="6430" Count="0" />
      <LineId Id="3141" Count="0" />
      <LineId Id="1921" Count="0" />
      <LineId Id="7788" Count="0" />
      <LineId Id="3890" Count="0" />
      <LineId Id="1922" Count="0" />
      <LineId Id="3138" Count="1" />
      <LineId Id="1923" Count="0" />
      <LineId Id="3142" Count="0" />
      <LineId Id="1924" Count="1" />
      <LineId Id="1913" Count="0" />
      <LineId Id="2312" Count="0" />
      <LineId Id="4237" Count="0" />
      <LineId Id="4219" Count="1" />
      <LineId Id="7789" Count="0" />
      <LineId Id="4221" Count="6" />
      <LineId Id="4236" Count="0" />
      <LineId Id="4229" Count="6" />
      <LineId Id="2314" Count="0" />
      <LineId Id="4218" Count="0" />
      <LineId Id="3891" Count="0" />
      <LineId Id="2315" Count="1" />
      <LineId Id="3147" Count="0" />
      <LineId Id="2317" Count="0" />
      <LineId Id="2304" Count="0" />
      <LineId Id="6432" Count="0" />
      <LineId Id="6434" Count="3" />
      <LineId Id="7790" Count="0" />
      <LineId Id="6438" Count="16" />
      <LineId Id="7791" Count="0" />
      <LineId Id="6455" Count="3" />
      <LineId Id="7562" Count="0" />
      <LineId Id="6459" Count="2" />
      <LineId Id="6433" Count="0" />
      <LineId Id="2305" Count="0" />
      <LineId Id="3153" Count="2" />
      <LineId Id="7563" Count="0" />
      <LineId Id="3892" Count="0" />
      <LineId Id="3156" Count="3" />
      <LineId Id="6462" Count="0" />
      <LineId Id="3160" Count="5" />
      <LineId Id="3167" Count="1" />
      <LineId Id="3893" Count="0" />
      <LineId Id="6463" Count="0" />
      <LineId Id="3169" Count="0" />
      <LineId Id="7792" Count="0" />
      <LineId Id="3170" Count="4" />
      <LineId Id="3898" Count="0" />
      <LineId Id="3175" Count="1" />
      <LineId Id="2308" Count="0" />
      <LineId Id="2587" Count="0" />
      <LineId Id="2591" Count="0" />
      <LineId Id="2594" Count="0" />
      <LineId Id="3894" Count="0" />
      <LineId Id="2595" Count="0" />
      <LineId Id="3899" Count="0" />
      <LineId Id="6394" Count="0" />
      <LineId Id="3900" Count="0" />
      <LineId Id="3902" Count="0" />
      <LineId Id="3904" Count="0" />
      <LineId Id="3908" Count="3" />
      <LineId Id="3922" Count="1" />
      <LineId Id="3921" Count="0" />
      <LineId Id="3914" Count="0" />
      <LineId Id="3945" Count="0" />
      <LineId Id="4172" Count="0" />
      <LineId Id="3924" Count="1" />
      <LineId Id="3918" Count="0" />
      <LineId Id="3926" Count="0" />
      <LineId Id="3919" Count="1" />
      <LineId Id="3907" Count="0" />
      <LineId Id="2596" Count="0" />
      <LineId Id="3150" Count="0" />
      <LineId Id="2597" Count="0" />
      <LineId Id="2590" Count="0" />
      <LineId Id="3955" Count="0" />
      <LineId Id="3957" Count="0" />
      <LineId Id="3959" Count="0" />
      <LineId Id="7793" Count="0" />
      <LineId Id="3960" Count="2" />
      <LineId Id="8016" Count="0" />
      <LineId Id="3965" Count="0" />
      <LineId Id="3956" Count="0" />
      <LineId Id="2309" Count="0" />
      <LineId Id="2332" Count="0" />
      <LineId Id="6395" Count="0" />
      <LineId Id="2335" Count="0" />
      <LineId Id="7794" Count="0" />
      <LineId Id="2336" Count="1" />
      <LineId Id="3151" Count="0" />
      <LineId Id="2338" Count="0" />
      <LineId Id="2310" Count="1" />
      <LineId Id="2350" Count="0" />
      <LineId Id="2352" Count="0" />
      <LineId Id="7795" Count="0" />
      <LineId Id="2353" Count="1" />
      <LineId Id="3152" Count="0" />
      <LineId Id="2355" Count="0" />
      <LineId Id="2339" Count="0" />
      <LineId Id="6387" Count="2" />
      <LineId Id="7796" Count="0" />
      <LineId Id="6390" Count="3" />
      <LineId Id="6386" Count="0" />
      <LineId Id="8659" Count="0" />
      <LineId Id="8661" Count="8" />
      <LineId Id="8727" Count="2" />
      <LineId Id="8670" Count="0" />
      <LineId Id="8723" Count="0" />
      <LineId Id="8671" Count="15" />
      <LineId Id="8698" Count="8" />
      <LineId Id="8732" Count="2" />
      <LineId Id="8707" Count="0" />
      <LineId Id="8731" Count="0" />
      <LineId Id="8708" Count="14" />
      <LineId Id="8660" Count="0" />
      <LineId Id="1916" Count="0" />
      <LineId Id="2356" Count="0" />
      <LineId Id="2359" Count="0" />
      <LineId Id="7797" Count="0" />
      <LineId Id="2360" Count="0" />
      <LineId Id="8978" Count="1" />
      <LineId Id="8981" Count="3" />
      <LineId Id="8980" Count="0" />
      <LineId Id="2364" Count="0" />
      <LineId Id="2366" Count="0" />
      <LineId Id="2362" Count="0" />
      <LineId Id="2340" Count="1" />
      <LineId Id="305" Count="1" />
      <LineId Id="3948" Count="0" />
      <LineId Id="3950" Count="3" />
      <LineId Id="3949" Count="0" />
      <LineId Id="307" Count="0" />
      <LineId Id="634" Count="1" />
      <LineId Id="310" Count="0" />
      <LineId Id="312" Count="0" />
      <LineId Id="2402" Count="0" />
      <LineId Id="2394" Count="2" />
      <LineId Id="2403" Count="0" />
      <LineId Id="2398" Count="1" />
      <LineId Id="2401" Count="0" />
      <LineId Id="2404" Count="0" />
      <LineId Id="3679" Count="1" />
      <LineId Id="3236" Count="0" />
      <LineId Id="314" Count="1" />
      <LineId Id="2638" Count="0" />
      <LineId Id="2648" Count="0" />
      <LineId Id="6900" Count="0" />
      <LineId Id="2640" Count="0" />
      <LineId Id="3442" Count="1" />
      <LineId Id="2652" Count="0" />
      <LineId Id="2651" Count="0" />
      <LineId Id="2653" Count="0" />
      <LineId Id="2650" Count="0" />
      <LineId Id="2655" Count="0" />
      <LineId Id="2641" Count="1" />
      <LineId Id="2657" Count="0" />
      <LineId Id="2659" Count="0" />
      <LineId Id="2658" Count="0" />
      <LineId Id="2660" Count="0" />
      <LineId Id="2662" Count="6" />
      <LineId Id="9224" Count="0" />
      <LineId Id="2669" Count="2" />
      <LineId Id="2643" Count="0" />
      <LineId Id="2673" Count="1" />
      <LineId Id="2672" Count="0" />
      <LineId Id="2675" Count="1" />
      <LineId Id="2645" Count="2" />
      <LineId Id="3177" Count="2" />
      <LineId Id="3183" Count="0" />
      <LineId Id="3928" Count="9" />
      <LineId Id="5443" Count="0" />
      <LineId Id="7343" Count="0" />
      <LineId Id="5444" Count="8" />
      <LineId Id="5222" Count="0" />
      <LineId Id="3180" Count="0" />
      <LineId Id="5456" Count="2" />
      <LineId Id="3221" Count="0" />
      <LineId Id="5459" Count="0" />
      <LineId Id="4189" Count="0" />
      <LineId Id="4191" Count="0" />
      <LineId Id="4193" Count="3" />
      <LineId Id="4192" Count="0" />
      <LineId Id="2678" Count="0" />
      <LineId Id="2680" Count="0" />
      <LineId Id="5917" Count="0" />
      <LineId Id="2681" Count="0" />
      <LineId Id="2683" Count="0" />
      <LineId Id="2785" Count="9" />
      <LineId Id="2796" Count="3" />
      <LineId Id="2809" Count="2" />
      <LineId Id="6134" Count="0" />
      <LineId Id="2880" Count="0" />
      <LineId Id="6132" Count="1" />
      <LineId Id="2679" Count="0" />
      <LineId Id="2887" Count="0" />
      <LineId Id="316" Count="0" />
      <LineId Id="3681" Count="0" />
      <LineId Id="2891" Count="4" />
      <LineId Id="2897" Count="3" />
      <LineId Id="2903" Count="7" />
      <LineId Id="2901" Count="0" />
      <LineId Id="2911" Count="0" />
      <LineId Id="2902" Count="0" />
      <LineId Id="3472" Count="1" />
      <LineId Id="3471" Count="0" />
      <LineId Id="2896" Count="0" />
      <LineId Id="3107" Count="0" />
      <LineId Id="3109" Count="4" />
      <LineId Id="2888" Count="2" />
      <LineId Id="1308" Count="1" />
      <LineId Id="5460" Count="1" />
      <LineId Id="1310" Count="0" />
      <LineId Id="5000" Count="0" />
      <LineId Id="1311" Count="1" />
      <LineId Id="631" Count="0" />
      <LineId Id="323" Count="3" />
      <LineId Id="632" Count="0" />
      <LineId Id="327" Count="0" />
      <LineId Id="633" Count="0" />
      <LineId Id="329" Count="1" />
      <LineId Id="4478" Count="2" />
      <LineId Id="4486" Count="1" />
      <LineId Id="4489" Count="2" />
      <LineId Id="4488" Count="0" />
      <LineId Id="4492" Count="0" />
      <LineId Id="4485" Count="0" />
      <LineId Id="4494" Count="11" />
      <LineId Id="4519" Count="8" />
      <LineId Id="4515" Count="0" />
      <LineId Id="4493" Count="0" />
      <LineId Id="338" Count="0" />
      <LineId Id="9" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>